MAINTAINERS:F:	drivers/mtd/spi-nor/nxp-spifi.c
MAINTAINERS:F:	drivers/spi/spi-nuc900.c
MAINTAINERS:F:	drivers/spi/spi-qup.c
MAINTAINERS:F:	drivers/spi/spi-atmel.*
MAINTAINERS:F:	drivers/mtd/spi-nor/fsl-quadspi.c
MAINTAINERS:F:	drivers/spi/spi-pxa2xx*
MAINTAINERS:F:	Documentation/devicetree/bindings/spi/spi-samsung.txt
MAINTAINERS:F:	drivers/spi/spi-s3c*
MAINTAINERS:F:	include/linux/platform_data/spi-s3c64xx.h
MAINTAINERS:T:	git git://git.infradead.org/linux-mtd.git spi-nor/fixes
MAINTAINERS:T:	git git://git.infradead.org/linux-mtd.git spi-nor/next
MAINTAINERS:F:	drivers/mtd/spi-nor/
MAINTAINERS:F:	include/linux/mtd/spi-nor.h
MAINTAINERS:Q:	http://patchwork.kernel.org/project/spi-devel-general/list/
MAINTAINERS:F:	drivers/spi/spi-tegra*
MAINTAINERS:F:	drivers/spi/spi-xtensa-xtfpga.c
modules.builtin:kernel/drivers/mtd/spi-nor/spi-nor.ko
modules.builtin:kernel/drivers/spi/spi-sun6i.ko
Binary file .git/index matches
drivers/base/regmap/regmap-spi.c:	return &async_spi->core;
drivers/base/regmap/regmap-spi.c:	return __regmap_init(&spi->dev, &regmap_spi, &spi->dev, config,
drivers/base/regmap/regmap-spi.c:	return __devm_regmap_init(&spi->dev, &regmap_spi, &spi->dev, config,
drivers/regulator/tps6524x-regulator.c:	struct device *dev = &spi->dev;
drivers/regulator/tps6524x-regulator.c:	hw = devm_kzalloc(&spi->dev, sizeof(struct tps6524x), GFP_KERNEL);
drivers/mfd/ezx-pcap.c:	struct pcap_platform_data *pdata = dev_get_platdata(&pcap->spi->dev);
drivers/mfd/ezx-pcap.c:	pdev->dev.parent = &pcap->spi->dev;
drivers/mfd/ezx-pcap.c:	device_for_each_child(&spi->dev, NULL, pcap_remove_subdev);
drivers/mfd/ezx-pcap.c:	struct pcap_platform_data *pdata = dev_get_platdata(&spi->dev);
drivers/mfd/ezx-pcap.c:	pcap = devm_kzalloc(&spi->dev, sizeof(*pcap), GFP_KERNEL);
drivers/mfd/ezx-pcap.c:	spi->bits_per_word = 32;
drivers/mfd/ezx-pcap.c:	spi->mode = SPI_MODE_0 | (pdata->config & PCAP_CS_AH ? SPI_CS_HIGH : 0);
drivers/mfd/ezx-pcap.c:		dev_err(&spi->dev, "can't create pcap thread\n");
drivers/mfd/ezx-pcap.c:	irq_set_irq_type(spi->irq, IRQ_TYPE_EDGE_RISING);
drivers/mfd/ezx-pcap.c:	irq_set_chained_handler_and_data(spi->irq, pcap_irq_handler, pcap);
drivers/mfd/ezx-pcap.c:	irq_set_irq_wake(spi->irq, 1);
drivers/mfd/ezx-pcap.c:	ret = devm_request_irq(&spi->dev, adc_irq, pcap_adc_irq, 0, "ADC",
drivers/mfd/ezx-pcap.c:	device_for_each_child(&spi->dev, NULL, pcap_remove_subdev);
drivers/mfd/mc13xxx-spi.c:	mc13xxx = devm_kzalloc(&spi->dev, sizeof(*mc13xxx), GFP_KERNEL);
drivers/mfd/mc13xxx-spi.c:	dev_set_drvdata(&spi->dev, mc13xxx);
drivers/mfd/mc13xxx-spi.c:	spi->mode = SPI_MODE_0 | SPI_CS_HIGH;
drivers/mfd/mc13xxx-spi.c:	mc13xxx->irq = spi->irq;
drivers/mfd/mc13xxx-spi.c:	spi->max_speed_hz = spi->max_speed_hz ? : 26000000;
drivers/mfd/mc13xxx-spi.c:	mc13xxx->regmap = devm_regmap_init(&spi->dev, &regmap_mc13xxx_bus,
drivers/mfd/mc13xxx-spi.c:					   &spi->dev,
drivers/mfd/mc13xxx-spi.c:		dev_err(&spi->dev, "Failed to initialize regmap: %d\n", ret);
drivers/mfd/mc13xxx-spi.c:	if (spi->dev.of_node) {
drivers/mfd/mc13xxx-spi.c:			of_match_device(mc13xxx_dt_ids, &spi->dev);
drivers/mfd/mc13xxx-spi.c:	return mc13xxx_common_init(&spi->dev);
drivers/mfd/mc13xxx-spi.c:	return mc13xxx_common_exit(&spi->dev);
drivers/mfd/da9052-spi.c:	da9052 = devm_kzalloc(&spi->dev, sizeof(struct da9052), GFP_KERNEL);
drivers/mfd/da9052-spi.c:	spi->mode = SPI_MODE_0;
drivers/mfd/da9052-spi.c:	spi->bits_per_word = 8;
drivers/mfd/da9052-spi.c:	da9052->dev = &spi->dev;
drivers/mfd/da9052-spi.c:	da9052->chip_irq = spi->irq;
drivers/mfd/da9052-spi.c:		dev_err(&spi->dev, "Failed to allocate register map: %d\n",
drivers/mfd/cros_ec_spi.c:	trans.delay_usecs = ec_spi->end_of_msg_delay;
drivers/mfd/cros_ec_spi.c:	ret = spi_sync_locked(ec_spi->spi, &msg);
drivers/mfd/cros_ec_spi.c:	ec_spi->last_transfer_ns = ktime_get_ns();
drivers/mfd/cros_ec_spi.c:	ret = spi_sync_locked(ec_spi->spi, &msg);
drivers/mfd/cros_ec_spi.c:	delay = ktime_get_ns() - ec_spi->last_transfer_ns;
drivers/mfd/cros_ec_spi.c:	spi_bus_lock(ec_spi->spi->master);
drivers/mfd/cros_ec_spi.c:	if (ec_spi->start_of_msg_delay) {
drivers/mfd/cros_ec_spi.c:		trans_delay.delay_usecs = ec_spi->start_of_msg_delay;
drivers/mfd/cros_ec_spi.c:	ret = spi_sync_locked(ec_spi->spi, &msg);
drivers/mfd/cros_ec_spi.c:	spi_bus_unlock(ec_spi->spi->master);
drivers/mfd/cros_ec_spi.c:	delay = ktime_get_ns() - ec_spi->last_transfer_ns;
drivers/mfd/cros_ec_spi.c:	spi_bus_lock(ec_spi->spi->master);
drivers/mfd/cros_ec_spi.c:	ret = spi_sync_locked(ec_spi->spi, &msg);
drivers/mfd/cros_ec_spi.c:	spi_bus_unlock(ec_spi->spi->master);
drivers/mfd/cros_ec_spi.c:	ret = of_property_read_u32(np, "google,cros-ec-spi-pre-delay", &val);
drivers/mfd/cros_ec_spi.c:		ec_spi->start_of_msg_delay = val;
drivers/mfd/cros_ec_spi.c:	ret = of_property_read_u32(np, "google,cros-ec-spi-msg-delay", &val);
drivers/mfd/cros_ec_spi.c:		ec_spi->end_of_msg_delay = val;
drivers/mfd/cros_ec_spi.c:	struct device *dev = &spi->dev;
drivers/mfd/cros_ec_spi.c:	spi->bits_per_word = 8;
drivers/mfd/cros_ec_spi.c:	spi->mode = SPI_MODE_0;
drivers/mfd/cros_ec_spi.c:	ec_spi->spi = spi;
drivers/mfd/cros_ec_spi.c:	ec_dev->irq = spi->irq;
drivers/mfd/cros_ec_spi.c:	ec_dev->phys_name = dev_name(&ec_spi->spi->dev);
drivers/mfd/cros_ec_spi.c:	ec_spi->last_transfer_ns = ktime_get_ns();
drivers/mfd/cros_ec_spi.c:	device_init_wakeup(&spi->dev, true);
drivers/mfd/altera-a10sr.c:	a10sr = devm_kzalloc(&spi->dev, sizeof(*a10sr),
drivers/mfd/altera-a10sr.c:	spi->mode = SPI_MODE_3;
drivers/mfd/altera-a10sr.c:	spi->bits_per_word = 8;
drivers/mfd/altera-a10sr.c:	a10sr->dev = &spi->dev;
drivers/mfd/altera-a10sr.c:		dev_err(&spi->dev, "Failed to allocate register map: %d\n",
drivers/mfd/sprd-sc27xx-spi.c:	pdata = of_device_get_match_data(&spi->dev);
drivers/mfd/sprd-sc27xx-spi.c:		dev_err(&spi->dev, "No matching driver data found\n");
drivers/mfd/sprd-sc27xx-spi.c:	ddata = devm_kzalloc(&spi->dev, sizeof(*ddata), GFP_KERNEL);
drivers/mfd/sprd-sc27xx-spi.c:	ddata->regmap = devm_regmap_init(&spi->dev, &sprd_pmic_regmap,
drivers/mfd/sprd-sc27xx-spi.c:					 &spi->dev, &sprd_pmic_config);
drivers/mfd/sprd-sc27xx-spi.c:		dev_err(&spi->dev, "Failed to allocate register map %d\n", ret);
drivers/mfd/sprd-sc27xx-spi.c:	ddata->dev = &spi->dev;
drivers/mfd/sprd-sc27xx-spi.c:	ddata->irq = spi->irq;
drivers/mfd/sprd-sc27xx-spi.c:	ddata->irq_chip.name = dev_name(&spi->dev);
drivers/mfd/sprd-sc27xx-spi.c:	ddata->irqs = devm_kzalloc(&spi->dev, sizeof(struct regmap_irq) *
drivers/mfd/sprd-sc27xx-spi.c:	ret = devm_regmap_add_irq_chip(&spi->dev, ddata->regmap, ddata->irq,
drivers/mfd/sprd-sc27xx-spi.c:		dev_err(&spi->dev, "Failed to add PMIC irq chip %d\n", ret);
drivers/mfd/sprd-sc27xx-spi.c:	ret = devm_mfd_add_devices(&spi->dev, PLATFORM_DEVID_AUTO,
drivers/mfd/sprd-sc27xx-spi.c:		dev_err(&spi->dev, "Failed to register device %d\n", ret);
drivers/mfd/wm831x-spi.c:	struct wm831x_pdata *pdata = dev_get_platdata(&spi->dev);
drivers/mfd/wm831x-spi.c:	if (spi->dev.of_node) {
drivers/mfd/wm831x-spi.c:		of_id = of_match_device(wm831x_of_match, &spi->dev);
drivers/mfd/wm831x-spi.c:			dev_err(&spi->dev, "Failed to match device\n");
drivers/mfd/wm831x-spi.c:	wm831x = devm_kzalloc(&spi->dev, sizeof(struct wm831x), GFP_KERNEL);
drivers/mfd/wm831x-spi.c:	spi->mode = SPI_MODE_0;
drivers/mfd/wm831x-spi.c:	wm831x->dev = &spi->dev;
drivers/mfd/wm831x-spi.c:	return wm831x_device_init(wm831x, spi->irq);
drivers/mfd/stmpe-spi.c:	spi->bits_per_word = 8;
drivers/mfd/stmpe-spi.c:		spi_reg_write(stmpe, STMPE811_REG_SPI_CFG, spi->mode);
drivers/mfd/stmpe-spi.c:		dev_dbg(&spi->dev, "spi_setup failed\n");
drivers/mfd/stmpe-spi.c:	if (spi->max_speed_hz > 1000000) {
drivers/mfd/stmpe-spi.c:		dev_dbg(&spi->dev, "f(sample) %d KHz?\n",
drivers/mfd/stmpe-spi.c:				(spi->max_speed_hz/1000));
drivers/mfd/stmpe-spi.c:	spi_ci.irq = spi->irq;
drivers/mfd/stmpe-spi.c:	spi_ci.dev = &spi->dev;
drivers/mfd/arizona-spi.c:	if (spi->dev.of_node)
drivers/mfd/arizona-spi.c:		type = arizona_of_get_type(&spi->dev);
drivers/mfd/arizona-spi.c:		dev_err(&spi->dev, "Unknown device type %ld\n", type);
drivers/mfd/arizona-spi.c:		dev_err(&spi->dev,
drivers/mfd/arizona-spi.c:	arizona = devm_kzalloc(&spi->dev, sizeof(*arizona), GFP_KERNEL);
drivers/mfd/arizona-spi.c:		dev_err(&spi->dev, "Failed to allocate register map: %d\n",
drivers/mfd/arizona-spi.c:	arizona->dev = &spi->dev;
drivers/mfd/arizona-spi.c:	arizona->irq = spi->irq;
drivers/mfd/tps65912-spi.c:	tps = devm_kzalloc(&spi->dev, sizeof(*tps), GFP_KERNEL);
drivers/mfd/tps65912-spi.c:	tps->dev = &spi->dev;
drivers/mfd/tps65912-spi.c:	tps->irq = spi->irq;
drivers/mfd/motorola-cpcap.c:	ret = cpcap_get_vendor(&cpcap->spi->dev, cpcap->regmap, &vendor);
drivers/mfd/motorola-cpcap.c:	ret = cpcap_get_revision(&cpcap->spi->dev, cpcap->regmap, &rev);
drivers/mfd/motorola-cpcap.c:	dev_info(&cpcap->spi->dev, "CPCAP vendor: %s rev: %i.%i (%x)\n",
drivers/mfd/motorola-cpcap.c:		dev_info(&cpcap->spi->dev,
drivers/mfd/motorola-cpcap.c:	ret = devm_regmap_add_irq_chip(&cpcap->spi->dev, cpcap->regmap,
drivers/mfd/motorola-cpcap.c:				       cpcap->spi->irq,
drivers/mfd/motorola-cpcap.c:				       irq_get_trigger_type(cpcap->spi->irq) |
drivers/mfd/motorola-cpcap.c:		dev_err(&cpcap->spi->dev, "could not add irq chip %i: %i\n",
drivers/mfd/motorola-cpcap.c:	cpcap->irqs = devm_kzalloc(&cpcap->spi->dev,
drivers/mfd/motorola-cpcap.c:	enable_irq_wake(cpcap->spi->irq);
drivers/mfd/motorola-cpcap.c:	match = of_match_device(of_match_ptr(cpcap_of_match), &spi->dev);
drivers/mfd/motorola-cpcap.c:	cpcap = devm_kzalloc(&spi->dev, sizeof(*cpcap), GFP_KERNEL);
drivers/mfd/motorola-cpcap.c:	spi->bits_per_word = 16;
drivers/mfd/motorola-cpcap.c:	spi->mode = SPI_MODE_0 | SPI_CS_HIGH;
drivers/mfd/motorola-cpcap.c:		dev_err(&cpcap->spi->dev, "Failed to initialize regmap: %d\n",
drivers/mfd/motorola-cpcap.c:		dev_err(&cpcap->spi->dev, "Failed to detect CPCAP: %i\n", ret);
drivers/mfd/motorola-cpcap.c:	return devm_of_platform_populate(&cpcap->spi->dev);
drivers/modules.builtin:kernel/drivers/mtd/spi-nor/spi-nor.ko
drivers/modules.builtin:kernel/drivers/spi/spi-sun6i.ko
drivers/misc/lis3lv02d/lis3lv02d_spi.c:	spi->bits_per_word = 8;
drivers/misc/lis3lv02d/lis3lv02d_spi.c:	spi->mode = SPI_MODE_0;
drivers/misc/lis3lv02d/lis3lv02d_spi.c:	lis3_dev.irq		= spi->irq;
drivers/misc/lis3lv02d/lis3lv02d_spi.c:	lis3_dev.pdata		= spi->dev.platform_data;
drivers/misc/lis3lv02d/lis3lv02d_spi.c:	if (of_match_device(lis302dl_spi_dt_ids, &spi->dev)) {
drivers/misc/lis3lv02d/lis3lv02d_spi.c:		lis3_dev.of_node = spi->dev.of_node;
drivers/misc/lattice-ecp3-config.c:		dev_err(&spi->dev, "Cannot load firmware, aborting\n");
drivers/misc/lattice-ecp3-config.c:		dev_err(&spi->dev, "Error: Firmware size is 0!\n");
drivers/misc/lattice-ecp3-config.c:	dev_dbg(&spi->dev, "FPGA JTAG ID=%08x\n", jedec_id);
drivers/misc/lattice-ecp3-config.c:		dev_err(&spi->dev,
drivers/misc/lattice-ecp3-config.c:	dev_info(&spi->dev, "FPGA %s detected\n", ecp3_dev[i].name);
drivers/misc/lattice-ecp3-config.c:	dev_dbg(&spi->dev, "FPGA Status=%08x\n", status);
drivers/misc/lattice-ecp3-config.c:		dev_err(&spi->dev, "Error: Can't allocate memory!\n");
drivers/misc/lattice-ecp3-config.c:		dev_err(&spi->dev,
drivers/misc/lattice-ecp3-config.c:	dev_info(&spi->dev, "Configuring the FPGA...\n");
drivers/misc/lattice-ecp3-config.c:	dev_dbg(&spi->dev, "FPGA Status=%08x\n", status);
drivers/misc/lattice-ecp3-config.c:		dev_info(&spi->dev, "FPGA successfully configured!\n");
drivers/misc/lattice-ecp3-config.c:		dev_info(&spi->dev, "FPGA not configured (DONE not set)\n");
drivers/misc/lattice-ecp3-config.c:	data = devm_kzalloc(&spi->dev, sizeof(*data), GFP_KERNEL);
drivers/misc/lattice-ecp3-config.c:		dev_err(&spi->dev, "Memory allocation for fpga_data failed\n");
drivers/misc/lattice-ecp3-config.c:				      FIRMWARE_NAME, &spi->dev,
drivers/misc/lattice-ecp3-config.c:		dev_err(&spi->dev, "Firmware loading failed with %d!\n", err);
drivers/misc/lattice-ecp3-config.c:	dev_info(&spi->dev, "FPGA bitstream configuration driver registered\n");
drivers/misc/ad525x_dpot-spi.c:	return ad_dpot_probe(&spi->dev, &bdata,
drivers/misc/ad525x_dpot-spi.c:	return ad_dpot_remove(&spi->dev);
drivers/misc/eeprom/eeprom_93xx46.c:		dev_dbg(&edev->spi->dev, "read cmd 0x%x, %d Hz\n",
drivers/misc/eeprom/eeprom_93xx46.c:			cmd_addr, edev->spi->max_speed_hz);
drivers/misc/eeprom/eeprom_93xx46.c:			dev_err(&edev->spi->dev, "read %zu bytes at %d: err. %d\n",
drivers/misc/eeprom/eeprom_93xx46.c:	dev_dbg(&edev->spi->dev, "ew%s cmd 0x%04x, %d bits\n",
drivers/misc/eeprom/eeprom_93xx46.c:		dev_err(&edev->spi->dev, "erase/write %sable error %d\n",
drivers/misc/eeprom/eeprom_93xx46.c:	dev_dbg(&edev->spi->dev, "write cmd 0x%x\n", cmd_addr);
drivers/misc/eeprom/eeprom_93xx46.c:			dev_err(&edev->spi->dev, "write failed at %d: %d\n",
drivers/misc/eeprom/eeprom_93xx46.c:	dev_dbg(&edev->spi->dev, "eral cmd 0x%04x, %d bits\n", cmd_addr, bits);
drivers/misc/eeprom/eeprom_93xx46.c:		dev_err(&edev->spi->dev, "erase error %d\n", ret);
drivers/misc/eeprom/eeprom_93xx46.c:		of_match_device(eeprom_93xx46_of_table, &spi->dev);
drivers/misc/eeprom/eeprom_93xx46.c:	struct device_node *np = spi->dev.of_node;
drivers/misc/eeprom/eeprom_93xx46.c:	pd = devm_kzalloc(&spi->dev, sizeof(*pd), GFP_KERNEL);
drivers/misc/eeprom/eeprom_93xx46.c:		dev_err(&spi->dev, "data-size property not found\n");
drivers/misc/eeprom/eeprom_93xx46.c:		dev_err(&spi->dev, "invalid data-size (%d)\n", tmp);
drivers/misc/eeprom/eeprom_93xx46.c:	pd->select = devm_gpiod_get_optional(&spi->dev, "select",
drivers/misc/eeprom/eeprom_93xx46.c:	spi->dev.platform_data = pd;
drivers/misc/eeprom/eeprom_93xx46.c:	if (spi->dev.of_node) {
drivers/misc/eeprom/eeprom_93xx46.c:	pd = spi->dev.platform_data;
drivers/misc/eeprom/eeprom_93xx46.c:		dev_err(&spi->dev, "missing platform data\n");
drivers/misc/eeprom/eeprom_93xx46.c:		dev_err(&spi->dev, "unspecified address type\n");
drivers/misc/eeprom/eeprom_93xx46.c:	edev->nvmem_config.name = dev_name(&spi->dev);
drivers/misc/eeprom/eeprom_93xx46.c:	edev->nvmem_config.dev = &spi->dev;
drivers/misc/eeprom/eeprom_93xx46.c:	edev->nvmem_config.base_dev = &spi->dev;
drivers/misc/eeprom/eeprom_93xx46.c:	dev_info(&spi->dev, "%d-bit eeprom %s\n",
drivers/misc/eeprom/eeprom_93xx46.c:		if (device_create_file(&spi->dev, &dev_attr_erase))
drivers/misc/eeprom/eeprom_93xx46.c:			dev_err(&spi->dev, "can't create erase interface\n");
drivers/misc/eeprom/eeprom_93xx46.c:		device_remove_file(&spi->dev, &dev_attr_erase);
drivers/misc/eeprom/at25.c:	dev_dbg(&at25->spi->dev, "read %zu bytes at %d --> %zd\n",
drivers/misc/eeprom/at25.c:			dev_dbg(&at25->spi->dev, "WREN --> %d\n", status);
drivers/misc/eeprom/at25.c:		dev_dbg(&at25->spi->dev, "write %u bytes at %u --> %d\n",
drivers/misc/eeprom/at25.c:				dev_dbg(&at25->spi->dev,
drivers/misc/eeprom/at25.c:			dev_err(&at25->spi->dev,
drivers/misc/eeprom/at25.c:	if (!spi->dev.platform_data) {
drivers/misc/eeprom/at25.c:		err = at25_fw_to_chip(&spi->dev, &chip);
drivers/misc/eeprom/at25.c:		chip = *(struct spi_eeprom *)spi->dev.platform_data;
drivers/misc/eeprom/at25.c:		dev_dbg(&spi->dev, "unsupported address type\n");
drivers/misc/eeprom/at25.c:		dev_dbg(&spi->dev, "rdsr --> %d (%02x)\n", sr, sr);
drivers/misc/eeprom/at25.c:	at25 = devm_kzalloc(&spi->dev, sizeof(struct at25_data), GFP_KERNEL);
drivers/misc/eeprom/at25.c:	at25->nvmem_config.name = dev_name(&spi->dev);
drivers/misc/eeprom/at25.c:	at25->nvmem_config.dev = &spi->dev;
drivers/misc/eeprom/at25.c:	at25->nvmem_config.base_dev = &spi->dev;
drivers/misc/eeprom/at25.c:	dev_info(&spi->dev, "%d %s %s eeprom%s, pagesize %u\n",
drivers/fpga/altera-ps-spi.c:	conf = devm_kzalloc(&spi->dev, sizeof(*conf), GFP_KERNEL);
drivers/fpga/altera-ps-spi.c:	of_id = of_match_device(of_ef_match, &spi->dev);
drivers/fpga/altera-ps-spi.c:	conf->config = devm_gpiod_get(&spi->dev, "nconfig", GPIOD_OUT_HIGH);
drivers/fpga/altera-ps-spi.c:		dev_err(&spi->dev, "Failed to get config gpio: %ld\n",
drivers/fpga/altera-ps-spi.c:	conf->status = devm_gpiod_get(&spi->dev, "nstat", GPIOD_IN);
drivers/fpga/altera-ps-spi.c:		dev_err(&spi->dev, "Failed to get status gpio: %ld\n",
drivers/fpga/altera-ps-spi.c:	conf->confd = devm_gpiod_get(&spi->dev, "confd", GPIOD_IN);
drivers/fpga/altera-ps-spi.c:		dev_warn(&spi->dev, "Not using confd gpio: %ld\n",
drivers/fpga/altera-ps-spi.c:		 dev_driver_string(&spi->dev), dev_name(&spi->dev));
drivers/fpga/altera-ps-spi.c:	return fpga_mgr_register(&spi->dev, conf->mgr_name,
drivers/fpga/altera-ps-spi.c:	fpga_mgr_unregister(&spi->dev);
drivers/fpga/xilinx-spi.c:		dev_err(&spi->dev, "applying CCLK cycles failed: %d\n", ret);
drivers/fpga/xilinx-spi.c:	conf = devm_kzalloc(&spi->dev, sizeof(*conf), GFP_KERNEL);
drivers/fpga/xilinx-spi.c:	conf->prog_b = devm_gpiod_get(&spi->dev, "prog_b", GPIOD_OUT_LOW);
drivers/fpga/xilinx-spi.c:		dev_err(&spi->dev, "Failed to get PROGRAM_B gpio: %ld\n",
drivers/fpga/xilinx-spi.c:	conf->done = devm_gpiod_get(&spi->dev, "done", GPIOD_IN);
drivers/fpga/xilinx-spi.c:		dev_err(&spi->dev, "Failed to get DONE gpio: %ld\n",
drivers/fpga/xilinx-spi.c:	return fpga_mgr_register(&spi->dev, "Xilinx Slave Serial FPGA Manager",
drivers/fpga/xilinx-spi.c:	fpga_mgr_unregister(&spi->dev);
drivers/fpga/ice40-spi.c:	struct device *dev = &spi->dev;
drivers/fpga/ice40-spi.c:	priv = devm_kzalloc(&spi->dev, sizeof(*priv), GFP_KERNEL);
drivers/fpga/ice40-spi.c:	if (spi->max_speed_hz > ICE40_SPI_MAX_SPEED) {
drivers/fpga/ice40-spi.c:	if (spi->max_speed_hz < ICE40_SPI_MIN_SPEED) {
drivers/fpga/ice40-spi.c:	if (spi->mode & SPI_CPHA) {
drivers/fpga/ice40-spi.c:	fpga_mgr_unregister(&spi->dev);
drivers/edac/altera_edac.c:	return altr_init_a10_ecc_device_type("altr,socfpga-qspi-ecc");
drivers/edac/altera_edac.c:	{ .compatible = "altr,socfpga-qspi-ecc", .data = &a10_qspiecc_data },
drivers/edac/altera_edac.c:		    of_device_is_compatible(child, "altr,socfpga-qspi-ecc") ||
drivers/iio/pressure/zpa2326_spi.c:		dev_err(&spi->dev, "failed to init registers map");
drivers/iio/pressure/zpa2326_spi.c:	spi->mode = SPI_MODE_3;
drivers/iio/pressure/zpa2326_spi.c:	spi->max_speed_hz = min(spi->max_speed_hz, 1000000U);
drivers/iio/pressure/zpa2326_spi.c:	spi->bits_per_word = 8;
drivers/iio/pressure/zpa2326_spi.c:	return zpa2326_probe(&spi->dev, spi_get_device_id(spi)->name,
drivers/iio/pressure/zpa2326_spi.c:			     spi->irq, ZPA2326_DEVICE_ID, regmap);
drivers/iio/pressure/zpa2326_spi.c:	zpa2326_remove(&spi->dev);
drivers/iio/pressure/mpl115_spi.c:	return mpl115_probe(&spi->dev, id->name, &mpl115_spi_ops);
drivers/iio/pressure/bmp280-spi.c:	spi->bits_per_word = 8;
drivers/iio/pressure/bmp280-spi.c:		dev_err(&spi->dev, "spi_setup failed!\n");
drivers/iio/pressure/bmp280-spi.c:	regmap = devm_regmap_init(&spi->dev,
drivers/iio/pressure/bmp280-spi.c:				  &spi->dev,
drivers/iio/pressure/bmp280-spi.c:		dev_err(&spi->dev, "failed to allocate register map\n");
drivers/iio/pressure/bmp280-spi.c:	return bmp280_common_probe(&spi->dev,
drivers/iio/pressure/bmp280-spi.c:				   spi->irq);
drivers/iio/pressure/bmp280-spi.c:	return bmp280_common_remove(&spi->dev);
drivers/iio/pressure/st_pressure_spi.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*press_data));
drivers/iio/pressure/st_pressure_spi.c:	st_sensors_of_name_probe(&spi->dev, st_press_of_match,
drivers/iio/pressure/st_pressure_spi.c:				 spi->modalias, sizeof(spi->modalias));
drivers/iio/pressure/ms5611_spi.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/iio/pressure/ms5611_spi.c:	spi->mode = SPI_MODE_0;
drivers/iio/pressure/ms5611_spi.c:	spi->max_speed_hz = 20000000;
drivers/iio/pressure/ms5611_spi.c:	spi->bits_per_word = 8;
drivers/iio/pressure/ms5611_spi.c:	return ms5611_probe(indio_dev, &spi->dev, spi_get_device_id(spi)->name,
drivers/iio/dummy/iio_simple_dummy.c:	 * indio_dev->dev.parent = &spi->dev;
drivers/iio/dummy/iio_simple_dummy.c: * Documentation/spi/spi-summary
drivers/iio/common/st_sensors/st_sensors_spi.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/common/st_sensors/st_sensors_spi.c:	indio_dev->name = spi->modalias;
drivers/iio/common/st_sensors/st_sensors_spi.c:	sdata->dev = &spi->dev;
drivers/iio/common/st_sensors/st_sensors_core.c:	if (((np && of_property_read_bool(np, "spi-3wire")) ||
drivers/iio/common/ssp_sensors/ssp_spi.c:#define SSP_DEV (&data->spi->dev)
drivers/iio/common/ssp_sensors/ssp_dev.c:				dev_err(&data->spi->dev,
drivers/iio/common/ssp_sensors/ssp_dev.c:		dev_err(&data->spi->dev,
drivers/iio/common/ssp_sensors/ssp_dev.c:	dev_info(&data->spi->dev, "current shutdown = %d, old = %d\n", enable,
drivers/iio/common/ssp_sensors/ssp_dev.c:		enable_irq(data->spi->irq);
drivers/iio/common/ssp_sensors/ssp_dev.c:		enable_irq_wake(data->spi->irq);
drivers/iio/common/ssp_sensors/ssp_dev.c:		disable_irq(data->spi->irq);
drivers/iio/common/ssp_sensors/ssp_dev.c:		disable_irq_wake(data->spi->irq);
drivers/iio/common/ssp_sensors/ssp_dev.c:		dev_warn(&data->spi->dev, "current shutdown = %d, old = %d\n",
drivers/iio/common/ssp_sensors/ssp_dev.c:			dev_warn(&data->spi->dev,
drivers/iio/common/ssp_sensors/ssp_dev.c:		dev_err(&data->spi->dev, "SSP_INVALID_REVISION\n");
drivers/iio/common/ssp_sensors/ssp_dev.c:	dev_info(&data->spi->dev,
drivers/iio/common/ssp_sensors/ssp_dev.c:	dev_err(&data->spi->dev, "%s - Sensor state: 0x%x, RC: %u, CC: %u\n",
drivers/iio/common/ssp_sensors/ssp_dev.c:			dev_err(&data->spi->dev, "Enabling sensor failed\n");
drivers/iio/common/ssp_sensors/ssp_dev.c:			dev_err(&data->spi->dev,
drivers/iio/common/ssp_sensors/ssp_dev.c:		dev_err(&data->spi->dev, "Changing sensor delay failed\n");
drivers/iio/common/ssp_sensors/ssp_dev.c:			dev_err(&data->spi->dev, "Remove sensor fail\n");
drivers/iio/common/ssp_sensors/ssp_dev.c:		dev_err(&data->spi->dev, "%s - MCU %s ret = %d\n", __func__,
drivers/iio/common/ssp_sensors/ssp_dev.c:	dev_info(&data->spi->dev, "MCU device ID = %d\n", ret);
drivers/iio/common/ssp_sensors/ssp_dev.c:		dev_err(&data->spi->dev,
drivers/iio/common/ssp_sensors/ssp_dev.c:		dev_err(&data->spi->dev,
drivers/iio/common/ssp_sensors/ssp_dev.c:	dev_info(&data->spi->dev, "MCU Firm Rev : New = %8u\n",
drivers/iio/common/ssp_sensors/ssp_dev.c:	dev_info(&data->spi->dev, "refreshing\n");
drivers/iio/common/ssp_sensors/ssp_dev.c:	data = ssp_parse_dt(&spi->dev);
drivers/iio/common/ssp_sensors/ssp_dev.c:		dev_err(&spi->dev, "Failed to find platform data\n");
drivers/iio/common/ssp_sensors/ssp_dev.c:	ret = mfd_add_devices(&spi->dev, -1, sensorhub_sensor_devs,
drivers/iio/common/ssp_sensors/ssp_dev.c:		dev_err(&spi->dev, "mfd add devices fail\n");
drivers/iio/common/ssp_sensors/ssp_dev.c:	spi->mode = SPI_MODE_1;
drivers/iio/common/ssp_sensors/ssp_dev.c:		dev_err(&spi->dev, "Failed to setup spi\n");
drivers/iio/common/ssp_sensors/ssp_dev.c:	ret = request_threaded_irq(data->spi->irq, NULL,
drivers/iio/common/ssp_sensors/ssp_dev.c:		dev_err(&spi->dev, "Irq request fail\n");
drivers/iio/common/ssp_sensors/ssp_dev.c:	enable_irq_wake(data->spi->irq);
drivers/iio/common/ssp_sensors/ssp_dev.c:			dev_err(&spi->dev, "Initialize_mcu failed\n");
drivers/iio/common/ssp_sensors/ssp_dev.c:		dev_err(&spi->dev, "Firmware version not supported\n");
drivers/iio/common/ssp_sensors/ssp_dev.c:	free_irq(data->spi->irq, data);
drivers/iio/common/ssp_sensors/ssp_dev.c:	dev_err(&spi->dev, "Probe failed!\n");
drivers/iio/common/ssp_sensors/ssp_dev.c:		dev_err(&data->spi->dev,
drivers/iio/common/ssp_sensors/ssp_dev.c:	free_irq(data->spi->irq, data);
drivers/iio/common/ssp_sensors/ssp_dev.c:	mfd_remove_devices(&spi->dev);
drivers/iio/common/ssp_sensors/ssp_dev.c:		dev_err(&data->spi->dev,
drivers/iio/common/ssp_sensors/ssp_dev.c:	disable_irq(data->spi->irq);
drivers/iio/common/ssp_sensors/ssp_dev.c:	enable_irq(data->spi->irq);
drivers/iio/common/ssp_sensors/ssp_dev.c:		dev_err(&data->spi->dev,
drivers/iio/accel/bma220_spi.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*data));
drivers/iio/accel/bma220_spi.c:		dev_err(&spi->dev, "iio allocation failed!\n");
drivers/iio/accel/bma220_spi.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/accel/bma220_spi.c:		dev_err(&spi->dev, "iio triggered buffer setup failed\n");
drivers/iio/accel/bma220_spi.c:		dev_err(&spi->dev, "iio_device_register failed\n");
drivers/iio/accel/adxl345_spi.c:	if (spi->max_speed_hz > ADXL345_MAX_SPI_FREQ_HZ) {
drivers/iio/accel/adxl345_spi.c:		dev_err(&spi->dev, "SPI CLK, %d Hz exceeds 5 MHz\n",
drivers/iio/accel/adxl345_spi.c:			spi->max_speed_hz);
drivers/iio/accel/adxl345_spi.c:		dev_err(&spi->dev, "Error initializing spi regmap: %ld\n",
drivers/iio/accel/adxl345_spi.c:	return adxl345_core_probe(&spi->dev, regmap, id->name);
drivers/iio/accel/adxl345_spi.c:	return adxl345_core_remove(&spi->dev);
drivers/iio/accel/mma7455_spi.c:	return mma7455_core_probe(&spi->dev, regmap, id->name);
drivers/iio/accel/mma7455_spi.c:	return mma7455_core_remove(&spi->dev);
drivers/iio/accel/st_accel_spi.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*adata));
drivers/iio/accel/st_accel_spi.c:	st_sensors_of_name_probe(&spi->dev, st_accel_of_match,
drivers/iio/accel/st_accel_spi.c:				 spi->modalias, sizeof(spi->modalias));
drivers/iio/accel/sca3000.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/iio/accel/sca3000.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/accel/sca3000.c:	if (spi->irq) {
drivers/iio/accel/sca3000.c:		ret = request_threaded_irq(spi->irq,
drivers/iio/accel/sca3000.c:	if (spi->irq)
drivers/iio/accel/sca3000.c:		free_irq(spi->irq, indio_dev);
drivers/iio/accel/sca3000.c:	if (spi->irq)
drivers/iio/accel/sca3000.c:		free_irq(spi->irq, indio_dev);
drivers/iio/accel/kxsd9-spi.c:	spi->mode = SPI_MODE_0;
drivers/iio/accel/kxsd9-spi.c:		dev_err(&spi->dev, "%s: regmap allocation failed: %ld\n",
drivers/iio/accel/kxsd9-spi.c:	return kxsd9_common_probe(&spi->dev,
drivers/iio/accel/kxsd9-spi.c:	return kxsd9_common_remove(&spi->dev);
drivers/iio/accel/bmc150-accel-spi.c:		dev_err(&spi->dev, "Failed to initialize spi regmap\n");
drivers/iio/accel/bmc150-accel-spi.c:	return bmc150_accel_core_probe(&spi->dev, regmap, spi->irq, id->name,
drivers/iio/accel/bmc150-accel-spi.c:	return bmc150_accel_core_remove(&spi->dev);
drivers/iio/temperature/maxim_thermocouple.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*data));
drivers/iio/temperature/maxim_thermocouple.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/potentiometer/max5487.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*data));
drivers/iio/potentiometer/max5487.c:	dev_set_drvdata(&spi->dev, indio_dev);
drivers/iio/potentiometer/max5487.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/potentiometer/max5487.c:	struct iio_dev *indio_dev = dev_get_drvdata(&spi->dev);
drivers/iio/potentiometer/mcp4131.c:	struct device *dev = &spi->dev;
drivers/iio/potentiometer/mcp4131.c:		dev_info(&spi->dev, "Unable to register %s\n", indio_dev->name);
drivers/iio/potentiometer/max5481.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*data));
drivers/iio/potentiometer/max5481.c:	dev_set_drvdata(&spi->dev, indio_dev);
drivers/iio/potentiometer/max5481.c:	match = of_match_device(of_match_ptr(max5481_match), &spi->dev);
drivers/iio/potentiometer/max5481.c:		data->cfg = of_device_get_match_data(&spi->dev);
drivers/iio/potentiometer/max5481.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/potentiometer/max5481.c:	struct iio_dev *indio_dev = dev_get_drvdata(&spi->dev);
drivers/iio/proximity/as3935.c:		dev_warn(&st->spi->dev, "read error\n");
drivers/iio/proximity/as3935.c:		dev_warn(&st->spi->dev, "noise level is too high\n");
drivers/iio/proximity/as3935.c:	struct device_node *np = spi->dev.of_node;
drivers/iio/proximity/as3935.c:	if (!spi->irq) {
drivers/iio/proximity/as3935.c:		dev_err(&spi->dev, "unable to get event interrupt\n");
drivers/iio/proximity/as3935.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/iio/proximity/as3935.c:		dev_warn(&spi->dev,
drivers/iio/proximity/as3935.c:		dev_err(&spi->dev,
drivers/iio/proximity/as3935.c:		dev_err(&spi->dev,
drivers/iio/proximity/as3935.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/proximity/as3935.c:	trig = devm_iio_trigger_alloc(&spi->dev, "%s-dev%d",
drivers/iio/proximity/as3935.c:		dev_err(&spi->dev, "failed to register trigger\n");
drivers/iio/proximity/as3935.c:		dev_err(&spi->dev, "cannot setup iio trigger\n");
drivers/iio/proximity/as3935.c:	ret = devm_request_irq(&spi->dev, spi->irq,
drivers/iio/proximity/as3935.c:				dev_name(&spi->dev),
drivers/iio/proximity/as3935.c:		dev_err(&spi->dev, "unable to request irq\n");
drivers/iio/proximity/as3935.c:		dev_err(&spi->dev, "unable to register device\n");
drivers/iio/gyro/bmg160_spi.c:		dev_err(&spi->dev, "Failed to register spi regmap %d\n",
drivers/iio/gyro/bmg160_spi.c:	return bmg160_core_probe(&spi->dev, regmap, spi->irq, id->name);
drivers/iio/gyro/bmg160_spi.c:	bmg160_core_remove(&spi->dev);
drivers/iio/gyro/adis16130.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/iio/gyro/adis16130.c:	indio_dev->name = spi->dev.driver->name;
drivers/iio/gyro/adis16130.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/gyro/adis16130.c:	return devm_iio_device_register(&spi->dev, indio_dev);
drivers/iio/gyro/st_gyro_spi.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*gdata));
drivers/iio/gyro/st_gyro_spi.c:	st_sensors_of_name_probe(&spi->dev, st_gyro_of_match,
drivers/iio/gyro/st_gyro_spi.c:				 spi->modalias, sizeof(spi->modalias));
drivers/iio/gyro/adxrs450.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/iio/gyro/adxrs450.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/gyro/adxrs450.c:	indio_dev->name = spi->dev.driver->name;
drivers/iio/gyro/adxrs450.c:	ret = devm_iio_device_register(&spi->dev, indio_dev);
drivers/iio/gyro/adis16080.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/iio/gyro/adis16080.c:	indio_dev->name = spi->dev.driver->name;
drivers/iio/gyro/adis16080.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/gyro/adis16136.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*adis16136));
drivers/iio/gyro/adis16136.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/gyro/adis16260.c:			adis->spi->max_speed_hz = ADIS16260_SPI_SLOW;
drivers/iio/gyro/adis16260.c:			adis->spi->max_speed_hz = ADIS16260_SPI_FAST;
drivers/iio/gyro/adis16260.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*adis16260));
drivers/iio/gyro/adis16260.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/adc/hi8435.c:	idev = devm_iio_device_alloc(&spi->dev, sizeof(*priv));
drivers/iio/adc/hi8435.c:	reset_gpio = devm_gpiod_get(&spi->dev, NULL, GPIOD_OUT_LOW);
drivers/iio/adc/hi8435.c:	idev->dev.parent	= &spi->dev;
drivers/iio/adc/hi8435.c:	idev->dev.of_node	= spi->dev.of_node;
drivers/iio/adc/hi8435.c:		dev_err(&spi->dev, "unable to register device\n");
drivers/iio/adc/max11100.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*state));
drivers/iio/adc/max11100.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/adc/max11100.c:	indio_dev->dev.of_node = spi->dev.of_node;
drivers/iio/adc/max11100.c:	state->vref_reg = devm_regulator_get(&spi->dev, "vref");
drivers/iio/adc/ad7923.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/iio/adc/ad7923.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/adc/ad7923.c:	indio_dev->dev.of_node = spi->dev.of_node;
drivers/iio/adc/ad7923.c:	st->reg = devm_regulator_get(&spi->dev, "refin");
drivers/iio/adc/stm32-dfsdm-core.c:	ret = of_property_read_u32(pdev->dev.of_node, "spi-max-frequency",
drivers/iio/adc/ad_sigma_delta.c:	spi_bus_lock(sigma_delta->spi->master);
drivers/iio/adc/ad_sigma_delta.c:	enable_irq(sigma_delta->spi->irq);
drivers/iio/adc/ad_sigma_delta.c:		disable_irq_nosync(sigma_delta->spi->irq);
drivers/iio/adc/ad_sigma_delta.c:	spi_bus_unlock(sigma_delta->spi->master);
drivers/iio/adc/ad_sigma_delta.c:	spi_bus_lock(sigma_delta->spi->master);
drivers/iio/adc/ad_sigma_delta.c:	enable_irq(sigma_delta->spi->irq);
drivers/iio/adc/ad_sigma_delta.c:	spi_bus_unlock(sigma_delta->spi->master);
drivers/iio/adc/ad_sigma_delta.c:		disable_irq_nosync(sigma_delta->spi->irq);
drivers/iio/adc/ad_sigma_delta.c:	spi_bus_lock(sigma_delta->spi->master);
drivers/iio/adc/ad_sigma_delta.c:	enable_irq(sigma_delta->spi->irq);
drivers/iio/adc/ad_sigma_delta.c:	spi_bus_unlock(sigma_delta->spi->master);
drivers/iio/adc/ad_sigma_delta.c:		disable_irq_nosync(sigma_delta->spi->irq);
drivers/iio/adc/ad_sigma_delta.c:	return spi_bus_unlock(sigma_delta->spi->master);
drivers/iio/adc/ad_sigma_delta.c:	enable_irq(sigma_delta->spi->irq);
drivers/iio/adc/ad_sigma_delta.c:	ret = request_irq(sigma_delta->spi->irq,
drivers/iio/adc/ad_sigma_delta.c:		disable_irq_nosync(sigma_delta->spi->irq);
drivers/iio/adc/ad_sigma_delta.c:	sigma_delta->trig->dev.parent = &sigma_delta->spi->dev;
drivers/iio/adc/ad_sigma_delta.c:	free_irq(sigma_delta->spi->irq, sigma_delta);
drivers/iio/adc/ad_sigma_delta.c:	free_irq(sigma_delta->spi->irq, sigma_delta);
drivers/iio/adc/ti-adc161s626.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*data));
drivers/iio/adc/ti-adc161s626.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/adc/ti-adc161s626.c:	indio_dev->dev.of_node = spi->dev.of_node;
drivers/iio/adc/ti-adc161s626.c:	data->ref = devm_regulator_get(&spi->dev, "vdda");
drivers/iio/adc/ti-adc128s052.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*adc));
drivers/iio/adc/ti-adc128s052.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/adc/ti-adc128s052.c:	indio_dev->dev.of_node = spi->dev.of_node;
drivers/iio/adc/ti-adc128s052.c:	adc->reg = devm_regulator_get(&spi->dev, "vref");
drivers/iio/adc/ti-adc084s021.c:		dev_err(&adc->spi->dev, "Failed to read data\n");
drivers/iio/adc/ti-adc084s021.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*adc));
drivers/iio/adc/ti-adc084s021.c:		dev_err(&spi->dev, "Failed to allocate IIO device\n");
drivers/iio/adc/ti-adc084s021.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/adc/ti-adc084s021.c:	indio_dev->dev.of_node = spi->dev.of_node;
drivers/iio/adc/ti-adc084s021.c:	adc->reg = devm_regulator_get(&spi->dev, "vref");
drivers/iio/adc/ti-adc084s021.c:	ret = devm_iio_triggered_buffer_setup(&spi->dev, indio_dev, NULL,
drivers/iio/adc/ti-adc084s021.c:		dev_err(&spi->dev, "Failed to setup triggered buffer\n");
drivers/iio/adc/ti-adc084s021.c:	return devm_iio_device_register(&spi->dev, indio_dev);
drivers/iio/adc/ti-adc12138.c:		dev_warn(&adc->spi->dev,
drivers/iio/adc/ti-adc12138.c:			dev_warn(&adc->spi->dev,
drivers/iio/adc/ti-adc12138.c:			dev_warn(&adc->spi->dev, "wait eoc timeout\n");
drivers/iio/adc/ti-adc12138.c:			dev_warn(&adc->spi->dev,
drivers/iio/adc/ti-adc12138.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*adc));
drivers/iio/adc/ti-adc12138.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/adc/ti-adc12138.c:	ret = of_property_read_u32(spi->dev.of_node, "ti,acquisition-time",
drivers/iio/adc/ti-adc12138.c:	adc->cclk = devm_clk_get(&spi->dev, NULL);
drivers/iio/adc/ti-adc12138.c:	adc->vref_p = devm_regulator_get(&spi->dev, "vref-p");
drivers/iio/adc/ti-adc12138.c:	adc->vref_n = devm_regulator_get_optional(&spi->dev, "vref-n");
drivers/iio/adc/ti-adc12138.c:	ret = devm_request_irq(&spi->dev, spi->irq, adc12138_eoc_handler,
drivers/iio/adc/ad7766.c:		dev_err(&ad7766->spi->dev, "Failed to enable supplies: %d\n",
drivers/iio/adc/ad7766.c:		dev_err(&ad7766->spi->dev, "Failed to enable MCLK: %d\n", ret);
drivers/iio/adc/ad7766.c:		enable_irq(ad7766->spi->irq);
drivers/iio/adc/ad7766.c:		disable_irq(ad7766->spi->irq);
drivers/iio/adc/ad7766.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*ad7766));
drivers/iio/adc/ad7766.c:	ad7766->mclk = devm_clk_get(&spi->dev, "mclk");
drivers/iio/adc/ad7766.c:	ret = devm_regulator_bulk_get(&spi->dev, ARRAY_SIZE(ad7766->reg),
drivers/iio/adc/ad7766.c:	ad7766->pd_gpio = devm_gpiod_get_optional(&spi->dev, "powerdown",
drivers/iio/adc/ad7766.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/adc/ad7766.c:	if (spi->irq > 0) {
drivers/iio/adc/ad7766.c:		ad7766->trig = devm_iio_trigger_alloc(&spi->dev, "%s-dev%d",
drivers/iio/adc/ad7766.c:		ad7766->trig->dev.parent = &spi->dev;
drivers/iio/adc/ad7766.c:		ret = devm_request_irq(&spi->dev, spi->irq, ad7766_irq,
drivers/iio/adc/ad7766.c:			IRQF_TRIGGER_FALLING, dev_name(&spi->dev),
drivers/iio/adc/ad7766.c:		disable_irq(spi->irq);
drivers/iio/adc/ad7766.c:		ret = devm_iio_trigger_register(&spi->dev, ad7766->trig);
drivers/iio/adc/ad7766.c:	ret = devm_iio_triggered_buffer_setup(&spi->dev, indio_dev,
drivers/iio/adc/ad7766.c:	ret = devm_iio_device_register(&spi->dev, indio_dev);
drivers/iio/adc/ti-adc108s102.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/iio/adc/ti-adc108s102.c:	if (ACPI_COMPANION(&spi->dev)) {
drivers/iio/adc/ti-adc108s102.c:		st->reg = devm_regulator_get(&spi->dev, "vref");
drivers/iio/adc/ti-adc108s102.c:			dev_err(&spi->dev, "Cannot enable vref regulator\n");
drivers/iio/adc/ti-adc108s102.c:			dev_err(&spi->dev, "vref get voltage failed\n");
drivers/iio/adc/ti-adc108s102.c:	indio_dev->name = spi->modalias;
drivers/iio/adc/ti-adc108s102.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/adc/ti-adc108s102.c:		dev_err(&spi->dev, "Failed to register IIO device\n");
drivers/iio/adc/ti-adc0832.c:			dev_warn(&adc->spi->dev,
drivers/iio/adc/ti-adc0832.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*adc));
drivers/iio/adc/ti-adc0832.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/adc/ti-adc0832.c:	indio_dev->dev.of_node = spi->dev.of_node;
drivers/iio/adc/ti-adc0832.c:	adc->reg = devm_regulator_get(&spi->dev, "vref");
drivers/iio/adc/ad7793.c:		dev_err(&st->sd.spi->dev, "device ID query failed\n");
drivers/iio/adc/ad7793.c:	dev_err(&st->sd.spi->dev, "setup failed\n");
drivers/iio/adc/ad7793.c:	const struct ad7793_platform_data *pdata = spi->dev.platform_data;
drivers/iio/adc/ad7793.c:		dev_err(&spi->dev, "no platform data?\n");
drivers/iio/adc/ad7793.c:	if (!spi->irq) {
drivers/iio/adc/ad7793.c:		dev_err(&spi->dev, "no IRQ?\n");
drivers/iio/adc/ad7793.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/iio/adc/ad7793.c:		st->reg = devm_regulator_get(&spi->dev, "refin");
drivers/iio/adc/ad7793.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/adc/ad7793.c:	indio_dev->dev.of_node = spi->dev.of_node;
drivers/iio/adc/ad7793.c:	const struct ad7793_platform_data *pdata = spi->dev.platform_data;
drivers/iio/adc/ad7298.c:	struct ad7298_platform_data *pdata = spi->dev.platform_data;
drivers/iio/adc/ad7298.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/iio/adc/ad7298.c:		st->reg = devm_regulator_get(&spi->dev, "vref");
drivers/iio/adc/ad7298.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/adc/ad7298.c:	indio_dev->dev.of_node = spi->dev.of_node;
drivers/iio/adc/ad7791.c:	struct ad7791_platform_data *pdata = spi->dev.platform_data;
drivers/iio/adc/ad7791.c:	if (!spi->irq) {
drivers/iio/adc/ad7791.c:		dev_err(&spi->dev, "Missing IRQ.\n");
drivers/iio/adc/ad7791.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/iio/adc/ad7791.c:	st->reg = devm_regulator_get(&spi->dev, "refin");
drivers/iio/adc/ad7791.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/adc/ad7791.c:	indio_dev->dev.of_node = spi->dev.of_node;
drivers/iio/adc/ti-ads7950.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/iio/adc/ti-ads7950.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/adc/ti-ads7950.c:	if (ACPI_COMPANION(&spi->dev))
drivers/iio/adc/ti-ads7950.c:	st->reg = devm_regulator_get(&spi->dev, "vref");
drivers/iio/adc/ti-ads7950.c:		dev_err(&spi->dev, "Failed get get regulator \"vref\"\n");
drivers/iio/adc/ti-ads7950.c:		dev_err(&spi->dev, "Failed to enable regulator \"vref\"\n");
drivers/iio/adc/ti-ads7950.c:		dev_err(&spi->dev, "Failed to setup triggered buffer\n");
drivers/iio/adc/ti-ads7950.c:		dev_err(&spi->dev, "Failed to register iio device\n");
drivers/iio/adc/max1027.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/iio/adc/max1027.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/adc/max1027.c:	indio_dev->dev.of_node = spi->dev.of_node;
drivers/iio/adc/max1027.c:	st->trig = devm_iio_trigger_alloc(&spi->dev, "%s-trigger",
drivers/iio/adc/max1027.c:	st->trig->dev.parent = &spi->dev;
drivers/iio/adc/max1027.c:	ret = devm_request_threaded_irq(&spi->dev, spi->irq,
drivers/iio/adc/max1027.c:					spi->dev.driver->name, st->trig);
drivers/iio/adc/max1118.c:			dev_warn(&adc->spi->dev,
drivers/iio/adc/max1118.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*adc));
drivers/iio/adc/max1118.c:		adc->reg = devm_regulator_get(&spi->dev, "vref");
drivers/iio/adc/max1118.c:			dev_err(&spi->dev, "failed to get vref regulator\n");
drivers/iio/adc/max1118.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/adc/ad7887.c:	struct ad7887_platform_data *pdata = spi->dev.platform_data;
drivers/iio/adc/ad7887.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/iio/adc/ad7887.c:		st->reg = devm_regulator_get(&spi->dev, "vref");
drivers/iio/adc/ad7887.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/adc/ad7887.c:	indio_dev->dev.of_node = spi->dev.of_node;
drivers/iio/adc/ti-ads8688.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/iio/adc/ti-ads8688.c:	st->reg = devm_regulator_get_optional(&spi->dev, "vref");
drivers/iio/adc/ti-ads8688.c:	spi->mode = SPI_MODE_1;
drivers/iio/adc/ti-ads8688.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/adc/ti-ads8688.c:	indio_dev->dev.of_node = spi->dev.of_node;
drivers/iio/adc/mcp320x.c:		if (!(adc->spi->mode & SPI_CPOL))
drivers/iio/adc/mcp320x.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*adc));
drivers/iio/adc/mcp320x.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/adc/mcp320x.c:	indio_dev->dev.of_node = spi->dev.of_node;
drivers/iio/adc/mcp320x.c:		if (!(spi->mode & SPI_CPOL))
drivers/iio/adc/mcp320x.c:	adc->reg = devm_regulator_get(&spi->dev, "vref");
drivers/iio/adc/ad7266.c:	struct ad7266_platform_data *pdata = spi->dev.platform_data;
drivers/iio/adc/ad7266.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/iio/adc/ad7266.c:	st->reg = devm_regulator_get_optional(&spi->dev, "vref");
drivers/iio/adc/ad7266.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/adc/ad7266.c:	indio_dev->dev.of_node = spi->dev.of_node;
drivers/iio/adc/ad7476.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/iio/adc/ad7476.c:	st->reg = devm_regulator_get(&spi->dev, "vcc");
drivers/iio/adc/ad7476.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/adc/ad7476.c:	indio_dev->dev.of_node = spi->dev.of_node;
drivers/iio/adc/ti-tlc4541.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/iio/adc/ti-tlc4541.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/adc/ti-tlc4541.c:	st->reg = devm_regulator_get(&spi->dev, "vref");
drivers/iio/humidity/hts221_spi.c:	return hts221_probe(&spi->dev, spi->irq,
drivers/iio/humidity/hts221_spi.c:			    spi->modalias, &hts221_transfer_fn);
drivers/iio/dac/ad5624r_spi.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/iio/dac/ad5624r_spi.c:	st->reg = devm_regulator_get(&spi->dev, "vcc");
drivers/iio/dac/ad5624r_spi.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/dac/ad8801.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*state));
drivers/iio/dac/ad8801.c:	state->vrefh_reg = devm_regulator_get(&spi->dev, "vrefh");
drivers/iio/dac/ad8801.c:		dev_err(&spi->dev, "Vrefh regulator not specified\n");
drivers/iio/dac/ad8801.c:		dev_err(&spi->dev, "Failed to enable vrefh regulator: %d\n",
drivers/iio/dac/ad8801.c:		dev_err(&spi->dev, "Failed to read vrefh regulator: %d\n",
drivers/iio/dac/ad8801.c:		state->vrefl_reg = devm_regulator_get(&spi->dev, "vrefl");
drivers/iio/dac/ad8801.c:			dev_err(&spi->dev, "Vrefl regulator not specified\n");
drivers/iio/dac/ad8801.c:			dev_err(&spi->dev, "Failed to enable vrefl regulator: %d\n",
drivers/iio/dac/ad8801.c:			dev_err(&spi->dev, "Failed to read vrefl regulator: %d\n",
drivers/iio/dac/ad8801.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/dac/ad8801.c:		dev_err(&spi->dev, "Failed to register iio device: %d\n",
drivers/iio/dac/ad5592r.c:	return ad5592r_probe(&spi->dev, id->name, &ad5592r_rw_ops);
drivers/iio/dac/ad5592r.c:	return ad5592r_remove(&spi->dev);
drivers/iio/dac/ad5446.c:	return ad5446_probe(&spi->dev, id->name,
drivers/iio/dac/ad5446.c:	return ad5446_remove(&spi->dev);
drivers/iio/dac/ad5360.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/iio/dac/ad5360.c:		dev_err(&spi->dev, "Failed to allocate iio device\n");
drivers/iio/dac/ad5360.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/dac/ad5360.c:		dev_err(&spi->dev, "Failed to allocate channel spec: %d\n", ret);
drivers/iio/dac/ad5360.c:	ret = devm_regulator_bulk_get(&st->spi->dev, st->chip_info->num_vrefs,
drivers/iio/dac/ad5360.c:		dev_err(&spi->dev, "Failed to request vref regulators: %d\n", ret);
drivers/iio/dac/ad5360.c:		dev_err(&spi->dev, "Failed to enable vref regulators: %d\n", ret);
drivers/iio/dac/ad5360.c:		dev_err(&spi->dev, "Failed to register iio device: %d\n", ret);
drivers/iio/dac/ad5504.c:	struct ad5504_platform_data *pdata = spi->dev.platform_data;
drivers/iio/dac/ad5504.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/iio/dac/ad5504.c:	reg = devm_regulator_get(&spi->dev, "vcc");
drivers/iio/dac/ad5504.c:		dev_warn(&spi->dev, "reference voltage unspecified\n");
drivers/iio/dac/ad5504.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/dac/ad5504.c:	if (spi->irq) {
drivers/iio/dac/ad5504.c:		ret = devm_request_threaded_irq(&spi->dev, spi->irq,
drivers/iio/dac/ti-dac082s085.c:	struct device *dev = &spi->dev;
drivers/iio/dac/ti-dac082s085.c:	indio_dev->name = spi->modalias;
drivers/iio/dac/mcp4922.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*state));
drivers/iio/dac/mcp4922.c:	state->vref_reg = devm_regulator_get(&spi->dev, "vref");
drivers/iio/dac/mcp4922.c:		dev_err(&spi->dev, "Vref regulator not specified\n");
drivers/iio/dac/mcp4922.c:		dev_err(&spi->dev, "Failed to enable vref regulator: %d\n",
drivers/iio/dac/mcp4922.c:		dev_err(&spi->dev, "Failed to read vref regulator: %d\n",
drivers/iio/dac/mcp4922.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/dac/mcp4922.c:		dev_err(&spi->dev, "Failed to register iio device: %d\n",
drivers/iio/dac/ad5755.c:	const struct ad5755_platform_data *pdata = dev_get_platdata(&spi->dev);
drivers/iio/dac/ad5755.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/iio/dac/ad5755.c:		dev_err(&spi->dev, "Failed to allocate iio device\n");
drivers/iio/dac/ad5755.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/dac/ad5755.c:	if (spi->dev.of_node)
drivers/iio/dac/ad5755.c:		pdata = ad5755_parse_dt(&spi->dev);
drivers/iio/dac/ad5755.c:		pdata = spi->dev.platform_data;
drivers/iio/dac/ad5755.c:		dev_warn(&spi->dev, "no platform data? using default\n");
drivers/iio/dac/ad5755.c:	return devm_iio_device_register(&spi->dev, indio_dev);
drivers/iio/dac/ad5686.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/iio/dac/ad5686.c:	st->reg = devm_regulator_get_optional(&spi->dev, "vcc");
drivers/iio/dac/ad5686.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/dac/ad5380.c:	return ad5380_probe(&spi->dev, regmap, id->driver_data, id->name);
drivers/iio/dac/ad5380.c:	return ad5380_remove(&spi->dev);
drivers/iio/dac/ltc2632.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/iio/dac/ltc2632.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/dac/ltc2632.c:	indio_dev->name = dev_of_node(&spi->dev) ? dev_of_node(&spi->dev)->name
drivers/iio/dac/ltc2632.c:		dev_err(&spi->dev,
drivers/iio/dac/ltc2632.c:	return devm_iio_device_register(&spi->dev, indio_dev);
drivers/iio/dac/ad5064.c:	return ad5064_probe(&spi->dev, id->driver_data, id->name,
drivers/iio/dac/ad5064.c:	return ad5064_remove(&spi->dev);
drivers/iio/dac/ad5791.c:	struct ad5791_platform_data *pdata = spi->dev.platform_data;
drivers/iio/dac/ad5791.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/iio/dac/ad5791.c:	st->reg_vdd = devm_regulator_get(&spi->dev, "vdd");
drivers/iio/dac/ad5791.c:	st->reg_vss = devm_regulator_get(&spi->dev, "vss");
drivers/iio/dac/ad5791.c:		dev_warn(&spi->dev, "reference voltage unspecified\n");
drivers/iio/dac/ad5791.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/dac/ad5764.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/iio/dac/ad5764.c:		dev_err(&spi->dev, "Failed to allocate iio device\n");
drivers/iio/dac/ad5764.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/dac/ad5764.c:		ret = devm_regulator_bulk_get(&st->spi->dev,
drivers/iio/dac/ad5764.c:			dev_err(&spi->dev, "Failed to request vref regulators: %d\n",
drivers/iio/dac/ad5764.c:			dev_err(&spi->dev, "Failed to enable vref regulators: %d\n",
drivers/iio/dac/ad5764.c:		dev_err(&spi->dev, "Failed to register iio device: %d\n", ret);
drivers/iio/dac/ad7303.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/iio/dac/ad7303.c:	st->vdd_reg = devm_regulator_get(&spi->dev, "Vdd");
drivers/iio/dac/ad7303.c:	if (spi->dev.of_node) {
drivers/iio/dac/ad7303.c:		ext_ref = of_property_read_bool(spi->dev.of_node,
drivers/iio/dac/ad7303.c:		struct ad7303_platform_data *pdata = spi->dev.platform_data;
drivers/iio/dac/ad7303.c:		st->vref_reg = devm_regulator_get(&spi->dev, "REF");
drivers/iio/dac/ad7303.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/dac/ad5421.c:	struct ad5421_platform_data *pdata = dev_get_platdata(&spi->dev);
drivers/iio/dac/ad5421.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/iio/dac/ad5421.c:		dev_err(&spi->dev, "Failed to allocate iio device\n");
drivers/iio/dac/ad5421.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/dac/ad5421.c:	if (spi->irq) {
drivers/iio/dac/ad5421.c:		ret = devm_request_threaded_irq(&spi->dev, spi->irq,
drivers/iio/dac/ad5421.c:	return devm_iio_device_register(&spi->dev, indio_dev);
drivers/iio/dac/ad5761.c:	st->vref_reg = devm_regulator_get_optional(&st->spi->dev, "vref");
drivers/iio/dac/ad5761.c:			dev_err(&st->spi->dev,
drivers/iio/dac/ad5761.c:		dev_err(&st->spi->dev,
drivers/iio/dac/ad5761.c:		dev_err(&st->spi->dev,
drivers/iio/dac/ad5761.c:		dev_err(&st->spi->dev,
drivers/iio/dac/ad5761.c:		dev_warn(&st->spi->dev,
drivers/iio/dac/ad5761.c:	struct ad5761_platform_data *pdata = dev_get_platdata(&spi->dev);
drivers/iio/dac/ad5761.c:	iio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/iio/dac/ad5761.c:	iio_dev->dev.parent = &spi->dev;
drivers/iio/dac/ad5449.c:	struct ad5449_platform_data *pdata = spi->dev.platform_data;
drivers/iio/dac/ad5449.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/iio/dac/ad5449.c:	ret = devm_regulator_bulk_get(&spi->dev, st->chip_info->num_channels,
drivers/iio/dac/ad5449.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/amplifiers/ad8366.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/iio/amplifiers/ad8366.c:	st->reg = devm_regulator_get(&spi->dev, "vcc");
drivers/iio/amplifiers/ad8366.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/health/afe4403.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*afe));
drivers/iio/health/afe4403.c:	afe->dev = &spi->dev;
drivers/iio/health/afe4403.c:	afe->irq = spi->irq;
drivers/iio/frequency/adf4350.c:			dev_dbg(&st->spi->dev, "[%d] 0x%X\n",
drivers/iio/frequency/adf4350.c:	dev_dbg(&st->spi->dev, "VCO: %llu Hz, PFD %lu Hz\n"
drivers/iio/frequency/adf4350.c:				dev_dbg(&st->spi->dev, "PLL un-locked\n");
drivers/iio/frequency/adf4350.c:	if (spi->dev.of_node) {
drivers/iio/frequency/adf4350.c:		pdata = adf4350_parse_dt(&spi->dev);
drivers/iio/frequency/adf4350.c:		pdata = spi->dev.platform_data;
drivers/iio/frequency/adf4350.c:		dev_warn(&spi->dev, "no platform data? using default\n");
drivers/iio/frequency/adf4350.c:		clk = devm_clk_get(&spi->dev, "clkin");
drivers/iio/frequency/adf4350.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/iio/frequency/adf4350.c:	st->reg = devm_regulator_get(&spi->dev, "vcc");
drivers/iio/frequency/adf4350.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/frequency/adf4350.c:		ret = devm_gpio_request(&spi->dev, pdata->gpio_lock_detect,
drivers/iio/frequency/adf4350.c:			dev_err(&spi->dev, "fail to request lock detect GPIO-%d",
drivers/iio/frequency/ad9523.c:			  (st->spi->mode & SPI_3WIRE ? 0 :
drivers/iio/frequency/ad9523.c:	struct ad9523_platform_data *pdata = spi->dev.platform_data;
drivers/iio/frequency/ad9523.c:		dev_err(&spi->dev, "no platform data?\n");
drivers/iio/frequency/ad9523.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/iio/frequency/ad9523.c:	st->reg = devm_regulator_get(&spi->dev, "vcc");
drivers/iio/frequency/ad9523.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/frequency/ad9523.c:	dev_info(&spi->dev, "probed %s\n", indio_dev->name);
drivers/iio/magnetometer/st_magn_spi.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*mdata));
drivers/iio/magnetometer/st_magn_spi.c:	st_sensors_of_name_probe(&spi->dev, st_magn_of_match,
drivers/iio/magnetometer/st_magn_spi.c:				 spi->modalias, sizeof(spi->modalias));
drivers/iio/magnetometer/bmc150_magn_spi.c:		dev_err(&spi->dev, "Failed to register spi regmap %d\n",
drivers/iio/magnetometer/bmc150_magn_spi.c:	return bmc150_magn_probe(&spi->dev, regmap, spi->irq, id->name);
drivers/iio/magnetometer/bmc150_magn_spi.c:	bmc150_magn_remove(&spi->dev);
drivers/iio/magnetometer/hmc5843_spi.c:	spi->mode = SPI_MODE_3;
drivers/iio/magnetometer/hmc5843_spi.c:	spi->max_speed_hz = 8000000;
drivers/iio/magnetometer/hmc5843_spi.c:	spi->bits_per_word = 8;
drivers/iio/magnetometer/hmc5843_spi.c:	return hmc5843_common_probe(&spi->dev,
drivers/iio/magnetometer/hmc5843_spi.c:	return hmc5843_common_remove(&spi->dev);
drivers/iio/imu/adis_trigger.c:	ret = request_irq(adis->spi->irq,
drivers/iio/imu/adis_trigger.c:	adis->trig->dev.parent = &adis->spi->dev;
drivers/iio/imu/adis_trigger.c:	free_irq(adis->spi->irq, adis->trig);
drivers/iio/imu/adis_trigger.c:	free_irq(adis->spi->irq, adis->trig);
drivers/iio/imu/adis16400_buffer.c:	u32 old_speed_hz = st->adis.spi->max_speed_hz;
drivers/iio/imu/adis16400_buffer.c:		st->adis.spi->max_speed_hz > ADIS16400_SPI_BURST) {
drivers/iio/imu/adis16400_buffer.c:		st->adis.spi->max_speed_hz = ADIS16400_SPI_BURST;
drivers/iio/imu/adis16400_buffer.c:		dev_err(&adis->spi->dev, "Failed to read data: %d\n", ret);
drivers/iio/imu/adis16400_buffer.c:		st->adis.spi->max_speed_hz = old_speed_hz;
drivers/iio/imu/adis_buffer.c:		dev_err(&adis->spi->dev, "Failed to read data: %d", ret);
drivers/iio/imu/adis_buffer.c:	if (adis->spi->irq) {
drivers/iio/imu/adis_buffer.c:	if (adis->spi->irq)
drivers/iio/imu/adis16480.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/iio/imu/adis16480.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/imu/inv_mpu6050/inv_mpu_spi.c:	} else if ((acpi_id = acpi_match_device(spi->dev.driver->acpi_match_table, &spi->dev))) {
drivers/iio/imu/inv_mpu6050/inv_mpu_spi.c:		dev_err(&spi->dev, "Failed to register spi regmap %d\n",
drivers/iio/imu/inv_mpu6050/inv_mpu_spi.c:	return inv_mpu_core_probe(regmap, spi->irq, name,
drivers/iio/imu/inv_mpu6050/inv_mpu_spi.c:	return inv_mpu_core_remove(&spi->dev);
drivers/iio/imu/inv_mpu6050/Makefile:inv-mpu6050-spi-objs := inv_mpu_spi.o
drivers/iio/imu/adis16400_core.c:		st->adis.spi->max_speed_hz = ADIS16400_SPI_SLOW;
drivers/iio/imu/adis16400_core.c:		st->adis.spi->max_speed_hz = ADIS16400_SPI_FAST;
drivers/iio/imu/adis16400_core.c:		st->adis.spi->max_speed_hz = ADIS16400_SPI_SLOW;
drivers/iio/imu/adis16400_core.c:		st->adis.spi->max_speed_hz = ADIS16400_SPI_FAST;
drivers/iio/imu/adis16400_core.c:	st->adis.spi->mode = SPI_MODE_3;
drivers/iio/imu/adis16400_core.c:			st->adis.spi->chip_select, st->adis.spi->irq);
drivers/iio/imu/adis16400_core.c:			st->adis.spi->max_speed_hz = ADIS16400_SPI_FAST;
drivers/iio/imu/adis16400_core.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/iio/imu/adis16400_core.c:	indio_dev->dev.parent = &spi->dev;
drivers/iio/imu/st_lsm6dsx/st_lsm6dsx_spi.c:		dev_err(&spi->dev, "Failed to register spi regmap %d\n",
drivers/iio/imu/st_lsm6dsx/st_lsm6dsx_spi.c:	return st_lsm6dsx_probe(&spi->dev, spi->irq,
drivers/iio/imu/adis.c:		dev_err(&adis->spi->dev, "Failed to write register 0x%02X: %d\n",
drivers/iio/imu/adis.c:		dev_err(&adis->spi->dev, "Failed to read register 0x%02X: %d\n",
drivers/iio/imu/adis.c:			dev_err(&adis->spi->dev, "%s.\n",
drivers/iio/imu/adis.c:		dev_err(&adis->spi->dev, "Failed to reset device: %d\n", ret);
drivers/iio/imu/adis.c:		dev_err(&adis->spi->dev, "Failed to initiate self test: %d\n",
drivers/iio/imu/adis.c:		dev_err(&adis->spi->dev, "Self-test failed, trying reset.\n");
drivers/iio/imu/adis.c:			dev_err(&adis->spi->dev, "Second self-test failed, giving up.\n");
drivers/iio/imu/bmi160/bmi160_spi.c:		dev_err(&spi->dev, "Failed to register spi regmap %d\n",
drivers/iio/imu/bmi160/bmi160_spi.c:	return bmi160_core_probe(&spi->dev, regmap, id->name, true);
drivers/iio/imu/bmi160/bmi160_spi.c:	bmi160_core_remove(&spi->dev);
drivers/iio/light/st_uvis25_spi.c:		dev_err(&spi->dev, "Failed to register spi regmap %d\n",
drivers/iio/light/st_uvis25_spi.c:	return st_uvis25_probe(&spi->dev, spi->irq, regmap);
drivers/hwmon/max31722.c:		dev_err(&spi->dev, "failed to set sensor mode.\n");
drivers/hwmon/max31722.c:	data = devm_kzalloc(&spi->dev, sizeof(*data), GFP_KERNEL);
drivers/hwmon/max31722.c:	data->hwmon_dev = hwmon_device_register_with_groups(&spi->dev,
drivers/hwmon/max31722.c:							    spi->modalias,
drivers/hwmon/adt7310.c:	return adt7x10_probe(&spi->dev, spi_get_device_id(spi)->name, spi->irq,
drivers/hwmon/adt7310.c:	return adt7x10_remove(&spi->dev, spi->irq);
drivers/hwmon/lm70.c:	match = of_match_device(lm70_of_ids, &spi->dev);
drivers/hwmon/lm70.c:	if (spi->mode & (SPI_CPOL | SPI_CPHA))
drivers/hwmon/lm70.c:	p_lm70 = devm_kzalloc(&spi->dev, sizeof(*p_lm70), GFP_KERNEL);
drivers/hwmon/lm70.c:	hwmon_dev = devm_hwmon_device_register_with_groups(&spi->dev,
drivers/hwmon/lm70.c:							   spi->modalias,
drivers/hwmon/adcxx.c:	adc = devm_kzalloc(&spi->dev, sizeof(*adc), GFP_KERNEL);
drivers/hwmon/adcxx.c:		status = device_create_file(&spi->dev, &ad_input[i].dev_attr);
drivers/hwmon/adcxx.c:			dev_err(&spi->dev, "device_create_file failed.\n");
drivers/hwmon/adcxx.c:	adc->hwmon_dev = hwmon_device_register(&spi->dev);
drivers/hwmon/adcxx.c:		dev_err(&spi->dev, "hwmon_device_register failed.\n");
drivers/hwmon/adcxx.c:		device_remove_file(&spi->dev, &ad_input[i].dev_attr);
drivers/hwmon/adcxx.c:		device_remove_file(&spi->dev, &ad_input[i].dev_attr);
drivers/hwmon/ads7871.c:	struct device *dev = &spi->dev;
drivers/hwmon/ads7871.c:	spi->mode = (SPI_MODE_0);
drivers/hwmon/ads7871.c:	spi->bits_per_word = 8;
drivers/hwmon/ads7871.c:	hwmon_dev = devm_hwmon_device_register_with_groups(dev, spi->modalias,
drivers/hwmon/max1111.c:	return max1111_read(&the_max1111->spi->dev, channel);
drivers/hwmon/max1111.c:	spi->bits_per_word = 8;
drivers/hwmon/max1111.c:	spi->mode = SPI_MODE_0;
drivers/hwmon/max1111.c:	data = devm_kzalloc(&spi->dev, sizeof(struct max1111_data), GFP_KERNEL);
drivers/hwmon/max1111.c:	err = sysfs_create_group(&spi->dev.kobj, &max1111_attr_group);
drivers/hwmon/max1111.c:		dev_err(&spi->dev, "failed to create attribute group\n");
drivers/hwmon/max1111.c:		err = sysfs_create_group(&spi->dev.kobj, &max1110_attr_group);
drivers/hwmon/max1111.c:			dev_err(&spi->dev,
drivers/hwmon/max1111.c:	data->hwmon_dev = hwmon_device_register(&spi->dev);
drivers/hwmon/max1111.c:		dev_err(&spi->dev, "failed to create hwmon device\n");
drivers/hwmon/max1111.c:	sysfs_remove_group(&spi->dev.kobj, &max1110_attr_group);
drivers/hwmon/max1111.c:	sysfs_remove_group(&spi->dev.kobj, &max1111_attr_group);
drivers/hwmon/max1111.c:	sysfs_remove_group(&spi->dev.kobj, &max1110_attr_group);
drivers/hwmon/max1111.c:	sysfs_remove_group(&spi->dev.kobj, &max1111_attr_group);
drivers/staging/greybus/arche-apb-ctrl.c:	apb->spi_en_gpio = of_get_named_gpio(np, "spi-en-gpio", 0);
drivers/staging/greybus/arche-apb-ctrl.c:					  "spi-en-active-high"))
drivers/staging/greybus/spilib.c:	return gb_connection_get_data(spi->connection);
drivers/staging/greybus/spilib.c:	spi->first_xfer = NULL;
drivers/staging/greybus/spilib.c:	spi->last_xfer = NULL;
drivers/staging/greybus/spilib.c:	spi->rx_xfer_offset = 0;
drivers/staging/greybus/spilib.c:	spi->tx_xfer_offset = 0;
drivers/staging/greybus/spilib.c:	spi->last_xfer_size = 0;
drivers/staging/greybus/spilib.c:	spi->op_timeout = 0;
drivers/staging/greybus/spilib.c:	struct spi_transfer *last_xfer = spi->last_xfer;
drivers/staging/greybus/spilib.c:	if ((spi->tx_xfer_offset + spi->last_xfer_size == last_xfer->len) ||
drivers/staging/greybus/spilib.c:	    (spi->rx_xfer_offset + spi->last_xfer_size == last_xfer->len))
drivers/staging/greybus/spilib.c:	struct spi_transfer *last_xfer = spi->last_xfer;
drivers/staging/greybus/spilib.c:		spi->tx_xfer_offset = 0;
drivers/staging/greybus/spilib.c:		spi->rx_xfer_offset = 0;
drivers/staging/greybus/spilib.c:		spi->op_timeout = 0;
drivers/staging/greybus/spilib.c:			spi->first_xfer = list_next_entry(last_xfer,
drivers/staging/greybus/spilib.c:	spi->first_xfer = last_xfer;
drivers/staging/greybus/spilib.c:		spi->tx_xfer_offset += spi->last_xfer_size;
drivers/staging/greybus/spilib.c:		spi->rx_xfer_offset += spi->last_xfer_size;
drivers/staging/greybus/spilib.c:	xfer = spi->first_xfer;
drivers/staging/greybus/spilib.c:		spi->last_xfer = xfer;
drivers/staging/greybus/spilib.c:			dev_err(spi->parent,
drivers/staging/greybus/spilib.c:			len = xfer->len - spi->tx_xfer_offset;
drivers/staging/greybus/spilib.c:			spi->last_xfer_size = tx_xfer_size;
drivers/staging/greybus/spilib.c:			len = xfer->len - spi->rx_xfer_offset;
drivers/staging/greybus/spilib.c:			spi->last_xfer_size = rx_xfer_size;
drivers/staging/greybus/spilib.c:		total_len += spi->last_xfer_size;
drivers/staging/greybus/spilib.c:	xfer = spi->first_xfer;
drivers/staging/greybus/spilib.c:		if (xfer == spi->last_xfer)
drivers/staging/greybus/spilib.c:			xfer_len = spi->last_xfer_size;
drivers/staging/greybus/spilib.c:		if (xfer_timeout > spi->op_timeout)
drivers/staging/greybus/spilib.c:			spi->op_timeout = xfer_timeout;
drivers/staging/greybus/spilib.c:			memcpy(tx_data, xfer->tx_buf + spi->tx_xfer_offset,
drivers/staging/greybus/spilib.c:		if (xfer == spi->last_xfer) {
drivers/staging/greybus/spilib.c:	struct spi_transfer *xfer = spi->first_xfer;
drivers/staging/greybus/spilib.c:			if (xfer == spi->first_xfer)
drivers/staging/greybus/spilib.c:				xfer_len = xfer->len - spi->rx_xfer_offset;
drivers/staging/greybus/spilib.c:			else if (xfer == spi->last_xfer)
drivers/staging/greybus/spilib.c:				xfer_len = spi->last_xfer_size;
drivers/staging/greybus/spilib.c:			memcpy(xfer->rx_buf + spi->rx_xfer_offset, rx_data,
drivers/staging/greybus/spilib.c:		if (xfer == spi->last_xfer)
drivers/staging/greybus/spilib.c:	struct gb_connection *connection = spi->connection;
drivers/staging/greybus/spilib.c:	spi->first_xfer = list_first_entry_or_null(&msg->transfers,
drivers/staging/greybus/spilib.c:	if (!spi->first_xfer) {
drivers/staging/greybus/spilib.c:							     spi->op_timeout);
drivers/staging/greybus/spilib.c:			dev_err(spi->parent,
drivers/staging/greybus/spilib.c:	return spi->ops->prepare_transfer_hardware(spi->parent);
drivers/staging/greybus/spilib.c:	spi->ops->unprepare_transfer_hardware(spi->parent);
drivers/staging/greybus/spilib.c:	ret = gb_operation_sync(spi->connection, GB_SPI_TYPE_MASTER_CONFIG,
drivers/staging/greybus/spilib.c:	spi->mode = gb_spi_mode_map(mode);
drivers/staging/greybus/spilib.c:	spi->flags = gb_spi_flags_map(flags);
drivers/staging/greybus/spilib.c:	spi->bits_per_word_mask = le32_to_cpu(response.bits_per_word_mask);
drivers/staging/greybus/spilib.c:	spi->num_chipselect = response.num_chipselect;
drivers/staging/greybus/spilib.c:	spi->min_speed_hz = le32_to_cpu(response.min_speed_hz);
drivers/staging/greybus/spilib.c:	spi->max_speed_hz = le32_to_cpu(response.max_speed_hz);
drivers/staging/greybus/spilib.c:	ret = gb_operation_sync(spi->connection, GB_SPI_TYPE_DEVICE_CONFIG,
drivers/staging/greybus/spilib.c:		strlcpy(spi_board.modalias, "spi-nor",
drivers/staging/greybus/spilib.c:	spi->connection = connection;
drivers/staging/greybus/spilib.c:	spi->parent = dev;
drivers/staging/greybus/spilib.c:	spi->ops = ops;
drivers/staging/greybus/spilib.c:	master->bus_num = -1; /* Allow spi-core to allocate it dynamically */
drivers/staging/greybus/spilib.c:	master->num_chipselect = spi->num_chipselect;
drivers/staging/greybus/spilib.c:	master->mode_bits = spi->mode;
drivers/staging/greybus/spilib.c:	master->flags = spi->flags;
drivers/staging/greybus/spilib.c:	master->bits_per_word_mask = spi->bits_per_word_mask;
drivers/staging/greybus/spilib.c:	for (i = 0; i < spi->num_chipselect; i++) {
drivers/staging/greybus/Makefile:gb-spi-y := spi.o
drivers/staging/mt29f_spinand/mt29f_spinand.c:			dev_err(&info->spi->dev, "WAIT timedout!!!\n");
drivers/staging/mt29f_spinand/mt29f_spinand.c:	mtd_device_unregister(dev_get_drvdata(&spi->dev));
drivers/staging/pi433/rf69.c:		dev_dbg(&spi->dev, "read 0x%x FAILED\n", addr);
drivers/staging/pi433/rf69.c:		dev_dbg(&spi->dev, "read 0x%x from reg 0x%x\n", retval, addr);
drivers/staging/pi433/rf69.c:		dev_dbg(&spi->dev, "write 0x%x to 0x%x FAILED\n", value, addr);
drivers/staging/pi433/rf69.c:		dev_dbg(&spi->dev, "wrote 0x%x to reg 0x%x\n", value, addr);
drivers/staging/pi433/rf69.c:		dev_dbg(&spi->dev, "set: illegal input param");
drivers/staging/pi433/rf69.c:		dev_dbg(&spi->dev, "set: illegal input param");
drivers/staging/pi433/rf69.c:			dev_dbg(&spi->dev, "set: illegal input param");
drivers/staging/pi433/rf69.c:			dev_dbg(&spi->dev, "set: illegal input param");
drivers/staging/pi433/rf69.c:		dev_dbg(&spi->dev, "set: modulation undefined");
drivers/staging/pi433/rf69.c:		dev_dbg(&spi->dev, "setBitRate: illegal input param");
drivers/staging/pi433/rf69.c:		dev_dbg(&spi->dev, "set_deviation: illegal input param");
drivers/staging/pi433/rf69.c:		dev_dbg(&spi->dev, "set_deviation: err in calc of msb");
drivers/staging/pi433/rf69.c:		dev_dbg(&spi->dev, "setFrequency: illegal input param");
drivers/staging/pi433/rf69.c:		dev_dbg(&spi->dev, "set: illegal input param");
drivers/staging/pi433/rf69.c:		dev_dbg(&spi->dev, "set: illegal input param");
drivers/staging/pi433/rf69.c:		dev_dbg(&spi->dev, "set: illegal input param");
drivers/staging/pi433/rf69.c:		dev_dbg(&spi->dev, "set: illegal input param");
drivers/staging/pi433/rf69.c:		dev_dbg(&spi->dev, "set: illegal input param");
drivers/staging/pi433/rf69.c:		dev_dbg(&spi->dev, "set: illegal input param");
drivers/staging/pi433/rf69.c:		dev_dbg(&spi->dev, "set: illegal input param");
drivers/staging/pi433/rf69.c:	dev_dbg(&spi->dev, "set: illegal input param");
drivers/staging/pi433/rf69.c:		dev_dbg(&spi->dev, "set: illegal input param");
drivers/staging/pi433/rf69.c:		dev_dbg(&spi->dev, "set: illegal input param");
drivers/staging/pi433/rf69.c:		dev_dbg(&spi->dev, "set: illegal input param");
drivers/staging/pi433/rf69.c:		dev_dbg(&spi->dev, "set: illegal input param");
drivers/staging/pi433/rf69.c:		dev_dbg(&spi->dev, "set: illegal input param");
drivers/staging/pi433/rf69.c:		dev_dbg(&spi->dev, "set: illegal input param");
drivers/staging/pi433/rf69.c:		dev_dbg(&spi->dev, "set: illegal input param");
drivers/staging/pi433/rf69.c:		dev_dbg(&spi->dev, "read fifo: passed in buffer bigger then internal buffer\n");
drivers/staging/pi433/rf69.c:		dev_dbg(&spi->dev, "%d - 0x%x\n", i, local_buffer[i + 1]);
drivers/staging/pi433/rf69.c:		dev_dbg(&spi->dev, "read fifo: passed in buffer bigger then internal buffer\n");
drivers/staging/pi433/rf69.c:		dev_dbg(&spi->dev, "0x%x\n", buffer[i]);
drivers/staging/pi433/Documentation/devicetree/pi433.txt:		spi-max-frequency = <10000000>;
drivers/staging/pi433/Documentation/devicetree/pi433-overlay.dts:				spi-max-frequency = <10000000>;
drivers/staging/pi433/pi433_if.c:		device->gpiod[i] = gpiod_get(&device->spi->dev, name, 0 /*GPIOD_IN*/);
drivers/staging/pi433/pi433_if.c:			dev_dbg(&device->spi->dev, "Could not find entry for %s. Ignoring.", name);
drivers/staging/pi433/pi433_if.c:			dev_dbg(&device->spi->dev, "%s is busy.", name);
drivers/staging/pi433/pi433_if.c:		dev_dbg(&device->spi->dev, "%s successfully configured", name);
drivers/staging/pi433/pi433_if.c:		dev_err(&device->spi->dev, "too many pi433 devices\n");
drivers/staging/pi433/pi433_if.c:	spi->mode = 0x00;
drivers/staging/pi433/pi433_if.c:	spi->bits_per_word = 8;
drivers/staging/pi433/pi433_if.c:	/* spi->max_speed_hz = 10000000;  1MHz already set by device tree overlay */
drivers/staging/pi433/pi433_if.c:		dev_dbg(&spi->dev, "configuration of SPI interface failed!\n");
drivers/staging/pi433/pi433_if.c:	dev_dbg(&spi->dev,
drivers/staging/pi433/pi433_if.c:		spi->mode, spi->bits_per_word, spi->max_speed_hz);
drivers/staging/pi433/pi433_if.c:		dev_dbg(&spi->dev, "found pi433 (ver. 0x%x)", retval);
drivers/staging/pi433/pi433_if.c:		dev_dbg(&spi->dev, "unknown chip version: 0x%x", retval);
drivers/staging/pi433/pi433_if.c:		dev_dbg(&spi->dev, "setup of GPIOs failed");
drivers/staging/pi433/pi433_if.c:		dev_dbg(&spi->dev, "get of minor number failed");
drivers/staging/pi433/pi433_if.c:				    &spi->dev,
drivers/staging/iio/accel/adis16240.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/staging/iio/accel/adis16240.c:	indio_dev->name = spi->dev.driver->name;
drivers/staging/iio/accel/adis16240.c:	indio_dev->dev.parent = &spi->dev;
drivers/staging/iio/accel/adis16201.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/staging/iio/accel/adis16201.c:	indio_dev->name = spi->dev.driver->name;
drivers/staging/iio/accel/adis16201.c:	indio_dev->dev.parent = &spi->dev;
drivers/staging/iio/accel/adis16209.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/staging/iio/accel/adis16209.c:	indio_dev->name = spi->dev.driver->name;
drivers/staging/iio/accel/adis16209.c:	indio_dev->dev.parent = &spi->dev;
drivers/staging/iio/accel/adis16203.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/staging/iio/accel/adis16203.c:	indio_dev->name = spi->dev.driver->name;
drivers/staging/iio/accel/adis16203.c:	indio_dev->dev.parent = &spi->dev;
drivers/staging/iio/gyro/adis16060_core.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/staging/iio/gyro/adis16060_core.c:	indio_dev->name = spi->dev.driver->name;
drivers/staging/iio/gyro/adis16060_core.c:	indio_dev->dev.parent = &spi->dev;
drivers/staging/iio/gyro/adis16060_core.c:	ret = devm_iio_device_register(&spi->dev, indio_dev);
drivers/staging/iio/adc/ad7780.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/staging/iio/adc/ad7780.c:	st->reg = devm_regulator_get(&spi->dev, "avdd");
drivers/staging/iio/adc/ad7780.c:		dev_err(&spi->dev, "Failed to enable specified AVdd supply\n");
drivers/staging/iio/adc/ad7780.c:		dev_warn(&spi->dev, "Reference voltage unspecified\n");
drivers/staging/iio/adc/ad7780.c:	indio_dev->dev.parent = &spi->dev;
drivers/staging/iio/adc/ad7780.c:	st->powerdown_gpio = devm_gpiod_get_optional(&spi->dev,
drivers/staging/iio/adc/ad7780.c:		dev_err(&spi->dev, "Failed to request powerdown GPIO: %d\n",
drivers/staging/iio/adc/ad7606_spi.c:		dev_err(&spi->dev, "SPI read error\n");
drivers/staging/iio/adc/ad7606_spi.c:	return ad7606_probe(&spi->dev, spi->irq, NULL,
drivers/staging/iio/adc/ad7606_spi.c:	return ad7606_remove(&spi->dev, spi->irq);
drivers/staging/iio/adc/ad7280a.c:	const struct ad7280_platform_data *pdata = dev_get_platdata(&spi->dev);
drivers/staging/iio/adc/ad7280a.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/staging/iio/adc/ad7280a.c:	st->spi->max_speed_hz = AD7280A_MAX_SPI_CLK_HZ;
drivers/staging/iio/adc/ad7280a.c:	st->spi->mode = SPI_MODE_1;
drivers/staging/iio/adc/ad7280a.c:	indio_dev->dev.parent = &spi->dev;
drivers/staging/iio/adc/ad7280a.c:	if (spi->irq > 0) {
drivers/staging/iio/adc/ad7280a.c:		ret = request_threaded_irq(spi->irq,
drivers/staging/iio/adc/ad7280a.c:	if (spi->irq > 0)
drivers/staging/iio/adc/ad7280a.c:		free_irq(spi->irq, indio_dev);
drivers/staging/iio/adc/ad7192.c:		dev_warn(&st->sd.spi->dev, "device ID query failed (0x%X)\n",
drivers/staging/iio/adc/ad7192.c:	dev_err(&st->sd.spi->dev, "setup failed\n");
drivers/staging/iio/adc/ad7192.c:	const struct ad7192_platform_data *pdata = dev_get_platdata(&spi->dev);
drivers/staging/iio/adc/ad7192.c:		dev_err(&spi->dev, "no platform data?\n");
drivers/staging/iio/adc/ad7192.c:	if (!spi->irq) {
drivers/staging/iio/adc/ad7192.c:		dev_err(&spi->dev, "no IRQ?\n");
drivers/staging/iio/adc/ad7192.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/staging/iio/adc/ad7192.c:	st->avdd = devm_regulator_get(&spi->dev, "avdd");
drivers/staging/iio/adc/ad7192.c:		dev_err(&spi->dev, "Failed to enable specified AVdd supply\n");
drivers/staging/iio/adc/ad7192.c:	st->dvdd = devm_regulator_get(&spi->dev, "dvdd");
drivers/staging/iio/adc/ad7192.c:		dev_err(&spi->dev, "Failed to enable specified DVdd supply\n");
drivers/staging/iio/adc/ad7192.c:		dev_warn(&spi->dev, "reference voltage undefined\n");
drivers/staging/iio/adc/ad7192.c:	indio_dev->dev.parent = &spi->dev;
drivers/staging/iio/meter/ade7759.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/staging/iio/meter/ade7759.c:	indio_dev->name = spi->dev.driver->name;
drivers/staging/iio/meter/ade7759.c:	indio_dev->dev.parent = &spi->dev;
drivers/staging/iio/meter/ade7758_core.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/staging/iio/meter/ade7758_core.c:	indio_dev->name = spi->dev.driver->name;
drivers/staging/iio/meter/ade7758_core.c:	indio_dev->dev.parent = &spi->dev;
drivers/staging/iio/meter/ade7758_core.c:	if (spi->irq) {
drivers/staging/iio/meter/ade7758_core.c:	if (spi->irq)
drivers/staging/iio/meter/ade7854-spi.c:		dev_err(&st->spi->dev, "problem when reading 8 bit register 0x%02X",
drivers/staging/iio/meter/ade7854-spi.c:		dev_err(&st->spi->dev, "problem when reading 16 bit register 0x%02X",
drivers/staging/iio/meter/ade7854-spi.c:		dev_err(&st->spi->dev, "problem when reading 24 bit register 0x%02X",
drivers/staging/iio/meter/ade7854-spi.c:		dev_err(&st->spi->dev, "problem when reading 32 bit register 0x%02X",
drivers/staging/iio/meter/ade7854-spi.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/staging/iio/meter/ade7854-spi.c:	st->irq = spi->irq;
drivers/staging/iio/meter/ade7854-spi.c:	return ade7854_probe(indio_dev, &spi->dev);
drivers/staging/iio/meter/ade7754.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/staging/iio/meter/ade7754.c:	indio_dev->name = spi->dev.driver->name;
drivers/staging/iio/meter/ade7754.c:	indio_dev->dev.parent = &spi->dev;
drivers/staging/iio/meter/ade7753.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/staging/iio/meter/ade7753.c:	indio_dev->name = spi->dev.driver->name;
drivers/staging/iio/meter/ade7753.c:	indio_dev->dev.parent = &spi->dev;
drivers/staging/iio/frequency/ad9832.c:	struct ad9832_platform_data *pdata = dev_get_platdata(&spi->dev);
drivers/staging/iio/frequency/ad9832.c:		dev_dbg(&spi->dev, "no platform data?\n");
drivers/staging/iio/frequency/ad9832.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/staging/iio/frequency/ad9832.c:	st->avdd = devm_regulator_get(&spi->dev, "avdd");
drivers/staging/iio/frequency/ad9832.c:		dev_err(&spi->dev, "Failed to enable specified AVDD supply\n");
drivers/staging/iio/frequency/ad9832.c:	st->dvdd = devm_regulator_get(&spi->dev, "dvdd");
drivers/staging/iio/frequency/ad9832.c:		dev_err(&spi->dev, "Failed to enable specified DVDD supply\n");
drivers/staging/iio/frequency/ad9832.c:	indio_dev->dev.parent = &spi->dev;
drivers/staging/iio/frequency/ad9832.c:		dev_err(&spi->dev, "device init failed\n");
drivers/staging/iio/frequency/ad9834.c:	struct ad9834_platform_data *pdata = dev_get_platdata(&spi->dev);
drivers/staging/iio/frequency/ad9834.c:		dev_dbg(&spi->dev, "no platform data?\n");
drivers/staging/iio/frequency/ad9834.c:	reg = devm_regulator_get(&spi->dev, "avdd");
drivers/staging/iio/frequency/ad9834.c:		dev_err(&spi->dev, "Failed to enable specified AVDD supply\n");
drivers/staging/iio/frequency/ad9834.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/staging/iio/frequency/ad9834.c:	indio_dev->dev.parent = &spi->dev;
drivers/staging/iio/frequency/ad9834.c:		dev_err(&spi->dev, "device init failed\n");
drivers/staging/iio/resolver/ad2s1210.c:	if (!spi->dev.platform_data)
drivers/staging/iio/resolver/ad2s1210.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/staging/iio/resolver/ad2s1210.c:	st->pdata = spi->dev.platform_data;
drivers/staging/iio/resolver/ad2s1210.c:	indio_dev->dev.parent = &spi->dev;
drivers/staging/iio/resolver/ad2s1210.c:	st->fclkin = spi->max_speed_hz;
drivers/staging/iio/resolver/ad2s1210.c:	spi->mode = SPI_MODE_3;
drivers/staging/iio/resolver/ad2s1200.c:	unsigned short *pins = spi->dev.platform_data;
drivers/staging/iio/resolver/ad2s1200.c:		ret = devm_gpio_request_one(&spi->dev, pins[pn], GPIOF_DIR_OUT,
drivers/staging/iio/resolver/ad2s1200.c:			dev_err(&spi->dev, "request gpio pin %d failed\n",
drivers/staging/iio/resolver/ad2s1200.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/staging/iio/resolver/ad2s1200.c:	indio_dev->dev.parent = &spi->dev;
drivers/staging/iio/resolver/ad2s1200.c:	ret = devm_iio_device_register(&spi->dev, indio_dev);
drivers/staging/iio/resolver/ad2s1200.c:	spi->max_speed_hz = AD2S1200_HZ;
drivers/staging/iio/resolver/ad2s1200.c:	spi->mode = SPI_MODE_3;
drivers/staging/iio/resolver/ad2s90.c:	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
drivers/staging/iio/resolver/ad2s90.c:	indio_dev->dev.parent = &spi->dev;
drivers/staging/iio/resolver/ad2s90.c:	spi->max_speed_hz = 830000;
drivers/staging/iio/resolver/ad2s90.c:	spi->mode = SPI_MODE_3;
drivers/staging/wilc1000/Makefile:wilc1000-spi-objs += wilc_spi.o
drivers/staging/wilc1000/wilc_spi.c:	gpio = of_get_gpio(spi->dev.of_node, 0);
drivers/staging/wilc1000/wilc_spi.c:	wilc->dev = &spi->dev;
drivers/staging/wilc1000/wilc_spi.c:		dev_dbg(&spi->dev, "Request writing %d bytes\n", len);
drivers/staging/wilc1000/wilc_spi.c:			dev_err(&spi->dev, "SPI transaction failed\n");
drivers/staging/wilc1000/wilc_spi.c:		dev_err(&spi->dev,
drivers/staging/wilc1000/wilc_spi.c:			dev_err(&spi->dev, "SPI transaction failed\n");
drivers/staging/wilc1000/wilc_spi.c:		dev_err(&spi->dev,
drivers/staging/wilc1000/wilc_spi.c:			dev_err(&spi->dev, "SPI transaction failed\n");
drivers/staging/wilc1000/wilc_spi.c:		dev_err(&spi->dev,
drivers/staging/wilc1000/wilc_spi.c:		dev_err(&spi->dev, "spi buffer size too small (%d) (%zu)\n",
drivers/staging/wilc1000/wilc_spi.c:		dev_err(&spi->dev, "Failed cmd write, bus error...\n");
drivers/staging/wilc1000/wilc_spi.c:		dev_err(&spi->dev,
drivers/staging/wilc1000/wilc_spi.c:		dev_err(&spi->dev, "Failed cmd state response state (%02x)\n",
drivers/staging/wilc1000/wilc_spi.c:			dev_err(&spi->dev,
drivers/staging/wilc1000/wilc_spi.c:				dev_err(&spi->dev,
drivers/staging/wilc1000/wilc_spi.c:					dev_err(&spi->dev, "buffer overrun when reading crc.\n");
drivers/staging/wilc1000/wilc_spi.c:					dev_err(&spi->dev, "Failed data block read, bus error...\n");
drivers/staging/wilc1000/wilc_spi.c:						dev_err(&spi->dev, "Failed data block crc read, bus error...\n");
drivers/staging/wilc1000/wilc_spi.c:						dev_err(&spi->dev, "Failed data response read, bus error...\n");
drivers/staging/wilc1000/wilc_spi.c:					dev_err(&spi->dev, "Failed data block read, bus error...\n");
drivers/staging/wilc1000/wilc_spi.c:						dev_err(&spi->dev, "Failed data block crc read, bus error...\n");
drivers/staging/wilc1000/wilc_spi.c:			dev_err(&spi->dev,
drivers/staging/wilc1000/wilc_spi.c:			dev_err(&spi->dev,
drivers/staging/wilc1000/wilc_spi.c:				dev_err(&spi->dev, "Failed data block crc write, bus error...\n");
drivers/staging/wilc1000/wilc_spi.c:		dev_err(&spi->dev, "Failed internal write cmd...\n");
drivers/staging/wilc1000/wilc_spi.c:		dev_err(&spi->dev, "Failed internal read cmd...\n");
drivers/staging/wilc1000/wilc_spi.c:		dev_err(&spi->dev, "Failed cmd, write reg (%08x)...\n", addr);
drivers/staging/wilc1000/wilc_spi.c:		dev_err(&spi->dev,
drivers/staging/wilc1000/wilc_spi.c:		dev_err(&spi->dev, "Failed block data write...\n");
drivers/staging/wilc1000/wilc_spi.c:		/* dev_err(&spi->dev, "***** read addr %d\n\n", addr); */
drivers/staging/wilc1000/wilc_spi.c:		dev_err(&spi->dev, "Failed cmd, read reg (%08x)...\n", addr);
drivers/staging/wilc1000/wilc_spi.c:		dev_err(&spi->dev, "Failed cmd, read block (%08x)...\n", addr);
drivers/staging/wilc1000/wilc_spi.c:			dev_err(&spi->dev, "Fail cmd read chip id...\n");
drivers/staging/wilc1000/wilc_spi.c:		dev_err(&spi->dev, "Failed internal read protocol with CRC on, retrying with CRC off...\n");
drivers/staging/wilc1000/wilc_spi.c:			dev_err(&spi->dev,
drivers/staging/wilc1000/wilc_spi.c:			dev_err(&spi->dev, "[wilc spi %d]: Failed internal write protocol reg...\n", __LINE__);
drivers/staging/wilc1000/wilc_spi.c:		dev_err(&spi->dev, "Fail cmd read chip id...\n");
drivers/staging/wilc1000/wilc_spi.c:	/* dev_err(&spi->dev, "chipid (%08x)\n", chipid); */
drivers/staging/wilc1000/wilc_spi.c:			dev_err(&spi->dev,
drivers/staging/wilc1000/wilc_spi.c:			dev_err(&spi->dev,
drivers/staging/wilc1000/wilc_spi.c:				dev_err(&spi->dev, "Unexpected interrupt (2): j=%d, tmp=%x, mask=%x\n", j, tmp, unknown_mask);
drivers/staging/wilc1000/wilc_spi.c:				dev_err(&spi->dev,
drivers/staging/wilc1000/wilc_spi.c:					dev_err(&spi->dev,
drivers/staging/wilc1000/wilc_spi.c:				dev_err(&spi->dev,
drivers/staging/wilc1000/wilc_spi.c:					dev_err(&spi->dev, "fail write reg vmm_core_ctl...\n");
drivers/staging/wilc1000/wilc_spi.c:		dev_err(&spi->dev, "Too many interrupts (%d)...\n", nint);
drivers/staging/wilc1000/wilc_spi.c:		dev_err(&spi->dev, "Failed read reg (%08x)...\n",
drivers/staging/wilc1000/wilc_spi.c:		dev_err(&spi->dev, "Failed write reg (%08x)...\n",
drivers/staging/wilc1000/wilc_spi.c:		dev_err(&spi->dev, "Failed read reg (%08x)...\n",
drivers/staging/wilc1000/wilc_spi.c:		dev_err(&spi->dev, "Failed write reg (%08x)...\n",
drivers/staging/wilc1000/wilc_spi.c:			dev_err(&spi->dev, "Failed read reg (%08x)...\n",
drivers/staging/wilc1000/wilc_spi.c:			dev_err(&spi->dev, "Failed write reg (%08x)...\n",
drivers/staging/rts5208/spi.c:	spi->err_code = err_code;
drivers/staging/rts5208/spi.c:				     (u8)(spi->clk_div >> 8));
drivers/staging/rts5208/spi.c:				     (u8)(spi->clk_div));
drivers/staging/rts5208/spi.c:	retval = switch_clock(chip, spi->spi_clock);
drivers/staging/rts5208/spi.c:	if (!spi->write_en)
drivers/staging/rts5208/spi.c:	if (!spi->write_en)
drivers/staging/rts5208/spi.c:		spi->err_code);
drivers/staging/rts5208/spi.c:	rtsx_stor_set_xfer_buf(&spi->err_code,
drivers/staging/rts5208/spi.c:		spi->spi_clock = ((u16)(srb->cmnd[8]) << 8) | srb->cmnd[9];
drivers/staging/rts5208/spi.c:		spi->spi_clock = srb->cmnd[3];
drivers/staging/rts5208/spi.c:	spi->clk_div = ((u16)(srb->cmnd[4]) << 8) | srb->cmnd[5];
drivers/staging/rts5208/spi.c:	spi->write_en = srb->cmnd[6];
drivers/staging/rts5208/spi.c:	dev_dbg(rtsx_dev(chip), "spi_clock = %d, ", spi->spi_clock);
drivers/staging/rts5208/spi.c:	dev_dbg(rtsx_dev(chip), "clk_div = %d, ", spi->clk_div);
drivers/staging/rts5208/spi.c:	dev_dbg(rtsx_dev(chip), "write_en = %d\n", spi->write_en);
drivers/staging/fbtft/fbtft.h:	return fbtft_remove_common(&spi->dev, info);                       \
drivers/staging/fbtft/flexfb.c:			if (par->spi->master->bits_per_word_mask
drivers/staging/fbtft/flexfb.c:				par->spi->bits_per_word = 9;
drivers/staging/fbtft/flexfb.c:	return flexfb_remove_common(&spi->dev, info);
drivers/staging/fbtft/fb_uc1611.c:	par->spi->mode |= SPI_CS_HIGH;
drivers/staging/fbtft/fb_ra8875.c:	/* slow down spi-speed for writing registers */
drivers/staging/fbtft/fb_ra8875.c:	/* restore user spi-speed */
drivers/staging/fbtft/fbtft_device.c:	dev_info(dev, "%s %s %dkHz %d bits mode=0x%02X\n", spi->modalias,
drivers/staging/fbtft/fbtft_device.c:		 dev_name(dev), spi->max_speed_hz / 1000, spi->bits_per_word,
drivers/staging/fbtft/fbtft_device.c:		 spi->mode);
drivers/staging/fbtft/fbtft_device.c:	master = spi_busnum_to_master(spi->bus_num);
drivers/staging/fbtft/fbtft_device.c:		       spi->bus_num);
drivers/staging/fbtft/fbtft_device.c:	fbtft_device_spi_delete(master, spi->chip_select);
drivers/staging/fbtft/fbtft_device.c:			len = strlcpy(displays[i].spi->modalias, name,
drivers/staging/fbtft/fbtft_device.c:					displays[i].spi->modalias);
drivers/staging/fbtft/fbtft_device.c:				spi->chip_select = cs;
drivers/staging/fbtft/fbtft_device.c:				spi->bus_num = busnum;
drivers/staging/fbtft/fbtft_device.c:					spi->max_speed_hz = speed;
drivers/staging/fbtft/fbtft_device.c:					spi->mode = mode;
drivers/staging/fbtft/fbtft_device.c:				pdata = (void *)spi->platform_data;
drivers/staging/fbtft/fbtft-core.c:		sprintf(text2, ", spi%d.%d at %d MHz", spi->master->bus_num,
drivers/staging/fbtft/fbtft-core.c:			spi->chip_select, spi->max_speed_hz / 1000000);
drivers/staging/fbtft/fbtft-core.c:		if (par->spi->master->bits_per_word_mask & SPI_BPW_MASK(9)) {
drivers/staging/fbtft/fbtft-core.c:			par->spi->bits_per_word = 9;
drivers/staging/fbtft/fbtft-core.c:			dev_warn(&par->spi->dev,
drivers/staging/fbtft/fbtft-bus.c:	if (par->spi && (par->spi->bits_per_word == 8)) {
drivers/staging/fbtft/fb_watterott.c:	save_mode = par->spi->mode;
drivers/staging/fbtft/fb_watterott.c:	par->spi->mode |= SPI_CS_HIGH;
drivers/staging/fbtft/fb_watterott.c:	par->spi->mode = save_mode;
drivers/staging/esp8089/testmode.c:                    spi_bus_lock(spi->master);
drivers/staging/esp8089/testmode.c:                    spi_bus_unlock(spi->master);
drivers/staging/esp8089/testmode.c:                    spi_bus_lock(spi->master);
drivers/staging/esp8089/testmode.c:                    spi_bus_unlock(spi->master);
drivers/staging/esp8089/testmode.c:                    spi_bus_lock(spi->master);
drivers/staging/esp8089/testmode.c:                    spi_bus_unlock(spi->master);
drivers/staging/esp8089/testmode.c:                    spi_bus_lock(spi->master);
drivers/staging/esp8089/testmode.c:                    spi_bus_unlock(spi->master);
drivers/staging/esp8089/spi_sif_esp.c:	spi_bus_lock(spi->master);
drivers/staging/esp8089/spi_sif_esp.c:	spi_bus_unlock(spi->master);
drivers/staging/esp8089/spi_sif_esp.c:	spi_bus_lock(spi->master);
drivers/staging/esp8089/spi_sif_esp.c:	spi_bus_unlock(spi->master);
drivers/staging/esp8089/spi_sif_esp.c:		epub = esp_pub_alloc_mac80211(&spi->dev);
drivers/staging/esp8089/spi_sif_esp.c:		SET_IEEE80211_DEV(epub->hw, &spi->dev);
drivers/staging/esp8089/spi_sif_esp.c:		epub->dev = &spi->dev;
Binary file drivers/gpio/gpiolib-of.o matches
drivers/gpio/gpio-74x164.c:	spi->bits_per_word = 8;
drivers/gpio/gpio-74x164.c:	if (of_property_read_u32(spi->dev.of_node, "registers-number",
drivers/gpio/gpio-74x164.c:		dev_err(&spi->dev,
drivers/gpio/gpio-74x164.c:	chip = devm_kzalloc(&spi->dev, sizeof(*chip) + nregs, GFP_KERNEL);
drivers/gpio/gpio-74x164.c:	chip->gpiod_oe = devm_gpiod_get_optional(&spi->dev, "enable",
drivers/gpio/gpio-74x164.c:	chip->gpio_chip.label = spi->modalias;
drivers/gpio/gpio-74x164.c:	chip->gpio_chip.parent = &spi->dev;
drivers/gpio/gpio-74x164.c:		dev_err(&spi->dev, "Failed writing: %d\n", ret);
drivers/gpio/gpio-pisosr.c:	struct device *dev = &spi->dev;
drivers/gpio/gpio-max3191x.c:	struct device *dev = &spi->dev;
drivers/gpio/gpio-max3191x.c:	max3191x->gpio.label = spi->modalias;
drivers/gpio/gpio-xra1403.c:	xra = devm_kzalloc(&spi->dev, sizeof(*xra), GFP_KERNEL);
drivers/gpio/gpio-xra1403.c:	reset_gpio = devm_gpiod_get_optional(&spi->dev, "reset", GPIOD_OUT_LOW);
drivers/gpio/gpio-xra1403.c:		dev_warn(&spi->dev, "Could not get reset-gpios\n");
drivers/gpio/gpio-xra1403.c:	xra->chip.parent = &spi->dev;
drivers/gpio/gpio-xra1403.c:		dev_err(&spi->dev, "Failed to allocate regmap: %d\n", ret);
drivers/gpio/gpio-xra1403.c:	ret = devm_gpiochip_add_data(&spi->dev, &xra->chip, xra);
drivers/gpio/gpio-xra1403.c:		dev_err(&spi->dev, "Unable to register gpiochip\n");
drivers/gpio/gpiolib-of.c:	/* Allow this specifically for "spi-gpio" devices */
drivers/gpio/gpiolib-of.c:	if (!of_device_is_compatible(np, "spi-gpio") || !con_id)
drivers/gpio/gpio-mc33880.c:	pdata = dev_get_platdata(&spi->dev);
drivers/gpio/gpio-mc33880.c:		dev_dbg(&spi->dev, "incorrect or missing platform data\n");
drivers/gpio/gpio-mc33880.c:	spi->bits_per_word = 8;
drivers/gpio/gpio-mc33880.c:	mc = devm_kzalloc(&spi->dev, sizeof(struct mc33880), GFP_KERNEL);
drivers/gpio/gpio-mc33880.c:	mc->chip.parent = &spi->dev;
drivers/gpio/gpio-mc33880.c:		dev_err(&spi->dev, "Failed writing to " DRIVER_NAME ": %d\n",
drivers/gpio/gpio-max7301.c:	spi->bits_per_word = 16;
drivers/gpio/gpio-max7301.c:	ts = devm_kzalloc(&spi->dev, sizeof(struct max7301), GFP_KERNEL);
drivers/gpio/gpio-max7301.c:	ts->dev = &spi->dev;
drivers/gpio/gpio-max7301.c:	return __max730x_remove(&spi->dev);
drivers/scsi/bfa/bfa_svc.c:	send_req->rsp_timeout = rspi->rsp_timeout;
drivers/scsi/bfa/bfa_svc.c:	send_req->rsp_maxlen = cpu_to_be32(rspi->rsp_maxlen);
drivers/scsi/bfa/bfa_svc.c:		WARN_ON(rspi->rsp_maxlen > BFA_FCXP_MAX_LBUF_SZ);
drivers/scsi/bfa/bfa_svc.c:		bfa_alen_set(&send_req->rsp_alen, rspi->rsp_maxlen,
drivers/scsi/bfa/bfa_svc.c:			bfa_alen_set(&send_req->rsp_alen, rspi->rsp_maxlen,
drivers/scsi/bfa/bfa_svc.c:			WARN_ON(rspi->rsp_maxlen != 0);
drivers/scsi/bfa/bfa_svc.c:	rspi->rsp_timeout = rsp_timeout;
drivers/scsi/bfa/bfa_svc.c:	rspi->rsp_maxlen = rsp_maxlen;
drivers/video/fbdev/mmp/panel/tpo_tj032md01bw.c:	mi = spi->dev.platform_data;
drivers/video/fbdev/mmp/panel/tpo_tj032md01bw.c:		dev_err(&spi->dev, "%s: no platform data defined\n", __func__);
drivers/video/fbdev/mmp/panel/tpo_tj032md01bw.c:	spi->bits_per_word = 16;
drivers/video/fbdev/mmp/panel/tpo_tj032md01bw.c:		dev_err(&spi->dev, "spi setup failed %d", ret);
drivers/video/fbdev/mmp/panel/tpo_tj032md01bw.c:	panel_tpohvga.dev = &spi->dev;
drivers/video/fbdev/mmp/hw/mmp_spi.c:		*(void **)spi_master_get_devdata(spi->master);
drivers/video/fbdev/mmp/hw/mmp_spi.c:	switch (spi->bits_per_word) {
drivers/video/fbdev/mmp/hw/mmp_spi.c:		dev_err(&spi->dev, "Wrong spi bit length\n");
drivers/video/fbdev/mmp/hw/mmp_spi.c:			dev_err(&spi->dev, "spi cmd send time out\n");
drivers/video/fbdev/mmp/hw/mmp_spi.c:		*(void **)spi_master_get_devdata(spi->master);
drivers/video/fbdev/mmp/hw/mmp_spi.c:		CFG_TXBITS(spi->bits_per_word) |
drivers/video/fbdev/mmp/hw/mmp_spi.c:		switch (spi->bits_per_word) {
drivers/video/fbdev/mmp/hw/mmp_spi.c:			dev_err(&spi->dev, "Wrong spi bit length\n");
drivers/video/fbdev/omap/lcd_mipid.c:		dev_dbg(&md->spi->dev, "spi_sync %d\n", r);
drivers/video/fbdev/omap/lcd_mipid.c:	struct mipid_platform_data *pd = md->spi->dev.platform_data;
drivers/video/fbdev/omap/lcd_mipid.c:	struct mipid_platform_data *pd = md->spi->dev.platform_data;
drivers/video/fbdev/omap/lcd_mipid.c:	struct mipid_platform_data *pd = md->spi->dev.platform_data;
drivers/video/fbdev/omap/lcd_mipid.c:				dev_err(&md->spi->dev,
drivers/video/fbdev/omap/lcd_mipid.c:	dev_err(&md->spi->dev, "performing LCD ESD recovery\n");
drivers/video/fbdev/omap/lcd_mipid.c:	dev_dbg(&md->spi->dev, "ESD mode 1 state1 %02x state2 %02x\n",
drivers/video/fbdev/omap/lcd_mipid.c:	dev_dbg(&md->spi->dev, "ESD mode 2 state %02x\n", rbuf[1]);
drivers/video/fbdev/omap/lcd_mipid.c:	dev_dbg(&md->spi->dev,
drivers/video/fbdev/omap/lcd_mipid.c:	pdata = md->spi->dev.platform_data;
drivers/video/fbdev/omap/lcd_mipid.c:		dev_err(&md->spi->dev, "missing platform data\n");
drivers/video/fbdev/omap/lcd_mipid.c:	dev_dbg(&md->spi->dev, "MIPI display ID: %02x%02x%02x\n",
drivers/video/fbdev/omap/lcd_mipid.c:		dev_err(&md->spi->dev, "invalid display ID\n");
drivers/video/fbdev/omap/lcd_mipid.c:		dev_err(&spi->dev, "out of memory\n");
drivers/video/fbdev/omap/lcd_mipid.c:	spi->mode = SPI_MODE_0;
drivers/video/fbdev/omap/lcd_mipid.c:	dev_set_drvdata(&spi->dev, md);
drivers/video/fbdev/omap/lcd_mipid.c:	struct mipid_device *md = dev_get_drvdata(&spi->dev);
drivers/video/fbdev/bfin-lq035q1-fb.c:	struct bfin_lq035q1fb_info *info = container_of(spi->dev.driver,
drivers/video/fbdev/omap2/omapfb/displays/panel-sony-acx565akm.c:		dev_dbg(&ddata->spi->dev, "spi_sync %d\n", r);
drivers/video/fbdev/omap2/omapfb/displays/panel-sony-acx565akm.c:	dev_dbg(&ddata->spi->dev,
drivers/video/fbdev/omap2/omapfb/displays/panel-sony-acx565akm.c:	dev_dbg(&ddata->spi->dev, "MIPI display ID: %02x%02x%02x\n",
drivers/video/fbdev/omap2/omapfb/displays/panel-sony-acx565akm.c:		dev_err(&ddata->spi->dev, "invalid display ID\n");
drivers/video/fbdev/omap2/omapfb/displays/panel-sony-acx565akm.c:	dev_info(&ddata->spi->dev, "omapfb: %s rev %02x LCD detected\n",
drivers/video/fbdev/omap2/omapfb/displays/panel-sony-acx565akm.c:	dev_dbg(&ddata->spi->dev, "%s\n", __func__);
drivers/video/fbdev/omap2/omapfb/displays/panel-sony-acx565akm.c:	dev_dbg(&ddata->spi->dev, "%s\n", __func__);
drivers/video/fbdev/omap2/omapfb/displays/panel-sony-acx565akm.c:		dev_dbg(&ddata->spi->dev, "panel already enabled\n");
drivers/video/fbdev/omap2/omapfb/displays/panel-sony-acx565akm.c:	struct panel_drv_data *ddata = dev_get_drvdata(&spi->dev);
drivers/video/fbdev/omap2/omapfb/displays/panel-sony-acx565akm.c:	pdata = dev_get_platdata(&spi->dev);
drivers/video/fbdev/omap2/omapfb/displays/panel-sony-acx565akm.c:		dev_err(&spi->dev, "failed to find video source '%s'\n",
drivers/video/fbdev/omap2/omapfb/displays/panel-sony-acx565akm.c:	struct panel_drv_data *ddata = dev_get_drvdata(&spi->dev);
drivers/video/fbdev/omap2/omapfb/displays/panel-sony-acx565akm.c:	struct device_node *np = spi->dev.of_node;
drivers/video/fbdev/omap2/omapfb/displays/panel-sony-acx565akm.c:		dev_err(&spi->dev, "failed to find video source\n");
drivers/video/fbdev/omap2/omapfb/displays/panel-sony-acx565akm.c:	dev_dbg(&spi->dev, "%s\n", __func__);
drivers/video/fbdev/omap2/omapfb/displays/panel-sony-acx565akm.c:	spi->mode = SPI_MODE_3;
drivers/video/fbdev/omap2/omapfb/displays/panel-sony-acx565akm.c:	ddata = devm_kzalloc(&spi->dev, sizeof(*ddata), GFP_KERNEL);
drivers/video/fbdev/omap2/omapfb/displays/panel-sony-acx565akm.c:	dev_set_drvdata(&spi->dev, ddata);
drivers/video/fbdev/omap2/omapfb/displays/panel-sony-acx565akm.c:	if (dev_get_platdata(&spi->dev)) {
drivers/video/fbdev/omap2/omapfb/displays/panel-sony-acx565akm.c:	} else if (spi->dev.of_node) {
drivers/video/fbdev/omap2/omapfb/displays/panel-sony-acx565akm.c:		dev_err(&spi->dev, "platform data missing!\n");
drivers/video/fbdev/omap2/omapfb/displays/panel-sony-acx565akm.c:		r = devm_gpio_request_one(&spi->dev, ddata->reset_gpio,
drivers/video/fbdev/omap2/omapfb/displays/panel-sony-acx565akm.c:		dev_err(&spi->dev, "%s panel detect error\n", __func__);
drivers/video/fbdev/omap2/omapfb/displays/panel-sony-acx565akm.c:	bldev = backlight_device_register("acx565akm", &ddata->spi->dev,
drivers/video/fbdev/omap2/omapfb/displays/panel-sony-acx565akm.c:	dssdev->dev = &spi->dev;
drivers/video/fbdev/omap2/omapfb/displays/panel-sony-acx565akm.c:		dev_err(&spi->dev, "Failed to register panel\n");
drivers/video/fbdev/omap2/omapfb/displays/panel-sony-acx565akm.c:	struct panel_drv_data *ddata = dev_get_drvdata(&spi->dev);
drivers/video/fbdev/omap2/omapfb/displays/panel-sony-acx565akm.c:	dev_dbg(&ddata->spi->dev, "%s\n", __func__);
drivers/video/fbdev/omap2/omapfb/displays/panel-lgphilips-lb035q02.c:	struct device_node *node = spi->dev.of_node;
drivers/video/fbdev/omap2/omapfb/displays/panel-lgphilips-lb035q02.c:	struct panel_drv_data *ddata = dev_get_drvdata(&spi->dev);
drivers/video/fbdev/omap2/omapfb/displays/panel-lgphilips-lb035q02.c:	gpio = devm_gpiod_get(&spi->dev, "enable", GPIOD_OUT_LOW);
drivers/video/fbdev/omap2/omapfb/displays/panel-lgphilips-lb035q02.c:		dev_err(&spi->dev, "failed to parse enable gpio\n");
drivers/video/fbdev/omap2/omapfb/displays/panel-lgphilips-lb035q02.c:		dev_err(&spi->dev, "failed to find video source\n");
drivers/video/fbdev/omap2/omapfb/displays/panel-lgphilips-lb035q02.c:	if (!spi->dev.of_node)
drivers/video/fbdev/omap2/omapfb/displays/panel-lgphilips-lb035q02.c:	ddata = devm_kzalloc(&spi->dev, sizeof(*ddata), GFP_KERNEL);
drivers/video/fbdev/omap2/omapfb/displays/panel-lgphilips-lb035q02.c:	dev_set_drvdata(&spi->dev, ddata);
drivers/video/fbdev/omap2/omapfb/displays/panel-lgphilips-lb035q02.c:		r = devm_gpio_request_one(&spi->dev, ddata->backlight_gpio,
drivers/video/fbdev/omap2/omapfb/displays/panel-lgphilips-lb035q02.c:	dssdev->dev = &spi->dev;
drivers/video/fbdev/omap2/omapfb/displays/panel-lgphilips-lb035q02.c:		dev_err(&spi->dev, "Failed to register panel\n");
drivers/video/fbdev/omap2/omapfb/displays/panel-lgphilips-lb035q02.c:	struct panel_drv_data *ddata = dev_get_drvdata(&spi->dev);
drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td028ttec1.c:	struct device_node *node = spi->dev.of_node;
drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td028ttec1.c:	struct panel_drv_data *ddata = dev_get_drvdata(&spi->dev);
drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td028ttec1.c:		dev_err(&spi->dev, "failed to find video source\n");
drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td028ttec1.c:	dev_dbg(&spi->dev, "%s\n", __func__);
drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td028ttec1.c:	if (!spi->dev.of_node)
drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td028ttec1.c:	spi->bits_per_word = 9;
drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td028ttec1.c:	spi->mode = SPI_MODE_3;
drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td028ttec1.c:		dev_err(&spi->dev, "spi_setup failed: %d\n", r);
drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td028ttec1.c:	ddata = devm_kzalloc(&spi->dev, sizeof(*ddata), GFP_KERNEL);
drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td028ttec1.c:	dev_set_drvdata(&spi->dev, ddata);
drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td028ttec1.c:	dssdev->dev = &spi->dev;
drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td028ttec1.c:		dev_err(&spi->dev, "Failed to register panel\n");
drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td028ttec1.c:	struct panel_drv_data *ddata = dev_get_drvdata(&spi->dev);
drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td043mtea1.c:		dev_warn(&spi->dev, "failed to write to LCD reg (%d)\n", r);
drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td043mtea1.c:	struct device_node *node = spi->dev.of_node;
drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td043mtea1.c:	struct panel_drv_data *ddata = dev_get_drvdata(&spi->dev);
drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td043mtea1.c:		dev_err(&spi->dev, "failed to parse enable gpio\n");
drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td043mtea1.c:		dev_err(&spi->dev, "failed to find video source\n");
drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td043mtea1.c:	dev_dbg(&spi->dev, "%s\n", __func__);
drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td043mtea1.c:	if (!spi->dev.of_node)
drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td043mtea1.c:	spi->bits_per_word = 16;
drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td043mtea1.c:	spi->mode = SPI_MODE_0;
drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td043mtea1.c:		dev_err(&spi->dev, "spi_setup failed: %d\n", r);
drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td043mtea1.c:	ddata = devm_kzalloc(&spi->dev, sizeof(*ddata), GFP_KERNEL);
drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td043mtea1.c:	dev_set_drvdata(&spi->dev, ddata);
drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td043mtea1.c:	ddata->vcc_reg = devm_regulator_get(&spi->dev, "vcc");
drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td043mtea1.c:		dev_err(&spi->dev, "failed to get LCD VCC regulator\n");
drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td043mtea1.c:		r = devm_gpio_request_one(&spi->dev,
drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td043mtea1.c:			dev_err(&spi->dev, "couldn't request reset GPIO\n");
drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td043mtea1.c:	r = sysfs_create_group(&spi->dev.kobj, &tpo_td043_attr_group);
drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td043mtea1.c:		dev_err(&spi->dev, "failed to create sysfs files\n");
drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td043mtea1.c:	dssdev->dev = &spi->dev;
drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td043mtea1.c:		dev_err(&spi->dev, "Failed to register panel\n");
drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td043mtea1.c:	sysfs_remove_group(&spi->dev.kobj, &tpo_td043_attr_group);
drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td043mtea1.c:	struct panel_drv_data *ddata = dev_get_drvdata(&spi->dev);
drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td043mtea1.c:	dev_dbg(&ddata->spi->dev, "%s\n", __func__);
drivers/video/fbdev/omap2/omapfb/displays/panel-tpo-td043mtea1.c:	sysfs_remove_group(&spi->dev.kobj, &tpo_td043_attr_group);
drivers/video/fbdev/omap2/omapfb/displays/panel-nec-nl8048hl11.c:	struct device_node *node = spi->dev.of_node;
drivers/video/fbdev/omap2/omapfb/displays/panel-nec-nl8048hl11.c:	struct panel_drv_data *ddata = dev_get_drvdata(&spi->dev);
drivers/video/fbdev/omap2/omapfb/displays/panel-nec-nl8048hl11.c:		dev_err(&spi->dev, "failed to parse enable gpio\n");
drivers/video/fbdev/omap2/omapfb/displays/panel-nec-nl8048hl11.c:		dev_err(&spi->dev, "failed to find video source\n");
drivers/video/fbdev/omap2/omapfb/displays/panel-nec-nl8048hl11.c:	dev_dbg(&spi->dev, "%s\n", __func__);
drivers/video/fbdev/omap2/omapfb/displays/panel-nec-nl8048hl11.c:	if (!spi->dev.of_node)
drivers/video/fbdev/omap2/omapfb/displays/panel-nec-nl8048hl11.c:	spi->mode = SPI_MODE_0;
drivers/video/fbdev/omap2/omapfb/displays/panel-nec-nl8048hl11.c:	spi->bits_per_word = 32;
drivers/video/fbdev/omap2/omapfb/displays/panel-nec-nl8048hl11.c:		dev_err(&spi->dev, "spi_setup failed: %d\n", r);
drivers/video/fbdev/omap2/omapfb/displays/panel-nec-nl8048hl11.c:	ddata = devm_kzalloc(&spi->dev, sizeof(*ddata), GFP_KERNEL);
drivers/video/fbdev/omap2/omapfb/displays/panel-nec-nl8048hl11.c:	dev_set_drvdata(&spi->dev, ddata);
drivers/video/fbdev/omap2/omapfb/displays/panel-nec-nl8048hl11.c:		r = devm_gpio_request_one(&spi->dev, ddata->qvga_gpio,
drivers/video/fbdev/omap2/omapfb/displays/panel-nec-nl8048hl11.c:		r = devm_gpio_request_one(&spi->dev, ddata->res_gpio,
drivers/video/fbdev/omap2/omapfb/displays/panel-nec-nl8048hl11.c:	dssdev->dev = &spi->dev;
drivers/video/fbdev/omap2/omapfb/displays/panel-nec-nl8048hl11.c:		dev_err(&spi->dev, "Failed to register panel\n");
drivers/video/fbdev/omap2/omapfb/displays/panel-nec-nl8048hl11.c:	struct panel_drv_data *ddata = dev_get_drvdata(&spi->dev);
drivers/video/fbdev/omap2/omapfb/displays/panel-nec-nl8048hl11.c:	dev_dbg(&ddata->spi->dev, "%s\n", __func__);
drivers/video/backlight/ams369fg06.c:	lcd = devm_kzalloc(&spi->dev, sizeof(struct ams369fg06), GFP_KERNEL);
drivers/video/backlight/ams369fg06.c:	spi->bits_per_word = 16;
drivers/video/backlight/ams369fg06.c:		dev_err(&spi->dev, "spi setup failed.\n");
drivers/video/backlight/ams369fg06.c:	lcd->dev = &spi->dev;
drivers/video/backlight/ams369fg06.c:	lcd->lcd_pd = dev_get_platdata(&spi->dev);
drivers/video/backlight/ams369fg06.c:		dev_err(&spi->dev, "platform data is NULL\n");
drivers/video/backlight/ams369fg06.c:	ld = devm_lcd_device_register(&spi->dev, "ams369fg06", &spi->dev, lcd,
drivers/video/backlight/ams369fg06.c:	bd = devm_backlight_device_register(&spi->dev, "ams369fg06-bl",
drivers/video/backlight/ams369fg06.c:					&spi->dev, lcd,
drivers/video/backlight/ams369fg06.c:	dev_info(&spi->dev, "ams369fg06 panel driver has been probed.\n");
drivers/video/backlight/ili922x.c:		dev_dbg(&spi->dev, "Error sending SPI message 0x%x", ret);
drivers/video/backlight/ili922x.c:		dev_dbg(&spi->dev, "Error sending SPI message 0x%x", ret);
drivers/video/backlight/ili922x.c:		dev_err(&spi->dev, "Error sending SPI message 0x%x", ret);
drivers/video/backlight/ili922x.c:	dev_dbg(&spi->dev, "ILI922x configuration registers:\n");
drivers/video/backlight/ili922x.c:		dev_dbg(&spi->dev, "reg @ 0x%02X: 0x%04X\n", reg, rx);
drivers/video/backlight/ili922x.c:	ili = devm_kzalloc(&spi->dev, sizeof(*ili), GFP_KERNEL);
drivers/video/backlight/ili922x.c:		dev_err(&spi->dev,
drivers/video/backlight/ili922x.c:	dev_info(&spi->dev, "ILI%x found, SPI freq %d, mode %d\n",
drivers/video/backlight/ili922x.c:		 reg, spi->max_speed_hz, spi->mode);
drivers/video/backlight/ili922x.c:		dev_err(&spi->dev, "reading RS failed...\n");
drivers/video/backlight/ili922x.c:	dev_dbg(&spi->dev, "status: 0x%x\n", reg);
drivers/video/backlight/ili922x.c:	lcd = devm_lcd_device_register(&spi->dev, "ili922xlcd", &spi->dev, ili,
drivers/video/backlight/ili922x.c:		dev_err(&spi->dev, "cannot register LCD\n");
drivers/video/backlight/lms501kf03.c:	lcd = devm_kzalloc(&spi->dev, sizeof(struct lms501kf03), GFP_KERNEL);
drivers/video/backlight/lms501kf03.c:	spi->bits_per_word = 9;
drivers/video/backlight/lms501kf03.c:		dev_err(&spi->dev, "spi setup failed.\n");
drivers/video/backlight/lms501kf03.c:	lcd->dev = &spi->dev;
drivers/video/backlight/lms501kf03.c:	lcd->lcd_pd = dev_get_platdata(&spi->dev);
drivers/video/backlight/lms501kf03.c:		dev_err(&spi->dev, "platform data is NULL\n");
drivers/video/backlight/lms501kf03.c:	ld = devm_lcd_device_register(&spi->dev, "lms501kf03", &spi->dev, lcd,
drivers/video/backlight/lms501kf03.c:	dev_info(&spi->dev, "lms501kf03 panel driver has been probed.\n");
drivers/video/backlight/s6e63m0.c:	lcd = devm_kzalloc(&spi->dev, sizeof(struct s6e63m0), GFP_KERNEL);
drivers/video/backlight/s6e63m0.c:	spi->bits_per_word = 9;
drivers/video/backlight/s6e63m0.c:		dev_err(&spi->dev, "spi setup failed.\n");
drivers/video/backlight/s6e63m0.c:	lcd->dev = &spi->dev;
drivers/video/backlight/s6e63m0.c:	lcd->lcd_pd = dev_get_platdata(&spi->dev);
drivers/video/backlight/s6e63m0.c:		dev_err(&spi->dev, "platform data is NULL.\n");
drivers/video/backlight/s6e63m0.c:	ld = devm_lcd_device_register(&spi->dev, "s6e63m0", &spi->dev, lcd,
drivers/video/backlight/s6e63m0.c:	bd = devm_backlight_device_register(&spi->dev, "s6e63m0bl-bl",
drivers/video/backlight/s6e63m0.c:					&spi->dev, lcd, &s6e63m0_backlight_ops,
drivers/video/backlight/s6e63m0.c:	ret = device_create_file(&(spi->dev), &dev_attr_gamma_mode);
drivers/video/backlight/s6e63m0.c:		dev_err(&(spi->dev), "failed to add sysfs entries\n");
drivers/video/backlight/s6e63m0.c:	ret = device_create_file(&(spi->dev), &dev_attr_gamma_table);
drivers/video/backlight/s6e63m0.c:		dev_err(&(spi->dev), "failed to add sysfs entries\n");
drivers/video/backlight/s6e63m0.c:	dev_info(&spi->dev, "s6e63m0 panel driver has been probed.\n");
drivers/video/backlight/s6e63m0.c:	device_remove_file(&spi->dev, &dev_attr_gamma_table);
drivers/video/backlight/s6e63m0.c:	device_remove_file(&spi->dev, &dev_attr_gamma_mode);
drivers/video/backlight/ld9040.c:	lcd = devm_kzalloc(&spi->dev, sizeof(struct ld9040), GFP_KERNEL);
drivers/video/backlight/ld9040.c:	spi->bits_per_word = 9;
drivers/video/backlight/ld9040.c:		dev_err(&spi->dev, "spi setup failed.\n");
drivers/video/backlight/ld9040.c:	lcd->dev = &spi->dev;
drivers/video/backlight/ld9040.c:	lcd->lcd_pd = dev_get_platdata(&spi->dev);
drivers/video/backlight/ld9040.c:		dev_err(&spi->dev, "platform data is NULL.\n");
drivers/video/backlight/ld9040.c:	ld = devm_lcd_device_register(&spi->dev, "ld9040", &spi->dev, lcd,
drivers/video/backlight/ld9040.c:	bd = devm_backlight_device_register(&spi->dev, "ld9040-bl", &spi->dev,
drivers/video/backlight/ld9040.c:	dev_info(&spi->dev, "ld9040 panel driver has been probed.\n");
drivers/video/backlight/lms283gf05.c:	struct lms283gf05_pdata *pdata = dev_get_platdata(&spi->dev);
drivers/video/backlight/lms283gf05.c:	struct lms283gf05_pdata *pdata = dev_get_platdata(&spi->dev);
drivers/video/backlight/lms283gf05.c:		ret = devm_gpio_request_one(&spi->dev, pdata->reset_gpio,
drivers/video/backlight/lms283gf05.c:	st = devm_kzalloc(&spi->dev, sizeof(struct lms283gf05_state),
drivers/video/backlight/lms283gf05.c:	ld = devm_lcd_device_register(&spi->dev, "lms283gf05", &spi->dev, st,
drivers/video/backlight/vgg2432a4.c:		dev_err(&spi->dev, "failed to initialise ili9320\n");
drivers/video/backlight/ili9320.c:	unsigned char *addr = spi->buffer_addr;
drivers/video/backlight/ili9320.c:	unsigned char *data = spi->buffer_data;
drivers/video/backlight/ili9320.c:	addr[0] = spi->id | ILI9320_SPI_INDEX | ILI9320_SPI_WRITE;
drivers/video/backlight/ili9320.c:	data[0] = spi->id | ILI9320_SPI_DATA  | ILI9320_SPI_WRITE;
drivers/video/backlight/ili9320.c:	return spi_sync(spi->dev, &spi->message);
drivers/video/backlight/ili9320.c:	spi->dev = dev;
drivers/video/backlight/ili9320.c:	spi->xfer[0].tx_buf = spi->buffer_addr;
drivers/video/backlight/ili9320.c:	spi->xfer[1].tx_buf = spi->buffer_data;
drivers/video/backlight/ili9320.c:	spi->xfer[0].len = 3;
drivers/video/backlight/ili9320.c:	spi->xfer[1].len = 3;
drivers/video/backlight/ili9320.c:	spi->xfer[0].bits_per_word = 8;
drivers/video/backlight/ili9320.c:	spi->xfer[1].bits_per_word = 8;
drivers/video/backlight/ili9320.c:	spi->xfer[0].cs_change = 1;
drivers/video/backlight/ili9320.c:	spi_message_init(&spi->message);
drivers/video/backlight/ili9320.c:	spi_message_add_tail(&spi->xfer[0], &spi->message);
drivers/video/backlight/ili9320.c:	spi_message_add_tail(&spi->xfer[1], &spi->message);
drivers/video/backlight/ili9320.c:	struct ili9320_platdata *cfg = dev_get_platdata(&spi->dev);
drivers/video/backlight/ili9320.c:	struct device *dev = &spi->dev;
drivers/video/backlight/ili9320.c:	ili = devm_kzalloc(&spi->dev, sizeof(struct ili9320), GFP_KERNEL);
drivers/video/backlight/ili9320.c:	lcd = devm_lcd_device_register(&spi->dev, "ili9320", dev, ili,
drivers/video/backlight/tdo24m.c:	pdata = dev_get_platdata(&spi->dev);
drivers/video/backlight/tdo24m.c:	spi->bits_per_word = 8;
drivers/video/backlight/tdo24m.c:	spi->mode = SPI_MODE_3;
drivers/video/backlight/tdo24m.c:	lcd = devm_kzalloc(&spi->dev, sizeof(struct tdo24m), GFP_KERNEL);
drivers/video/backlight/tdo24m.c:	lcd->buf = devm_kzalloc(&spi->dev, TDO24M_SPI_BUFF_SIZE, GFP_KERNEL);
drivers/video/backlight/tdo24m.c:		dev_err(&spi->dev, "Unsupported model");
drivers/video/backlight/tdo24m.c:	lcd->lcd_dev = devm_lcd_device_register(&spi->dev, "tdo24m", &spi->dev,
drivers/video/backlight/corgi_lcd.c:		err = devm_gpio_request(&spi->dev, pdata->gpio_backlight_on,
drivers/video/backlight/corgi_lcd.c:			dev_err(&spi->dev,
drivers/video/backlight/corgi_lcd.c:		err = devm_gpio_request(&spi->dev, pdata->gpio_backlight_cont,
drivers/video/backlight/corgi_lcd.c:			dev_err(&spi->dev,
drivers/video/backlight/corgi_lcd.c:	struct corgi_lcd_platform_data *pdata = dev_get_platdata(&spi->dev);
drivers/video/backlight/corgi_lcd.c:		dev_err(&spi->dev, "platform data not available\n");
drivers/video/backlight/corgi_lcd.c:	lcd = devm_kzalloc(&spi->dev, sizeof(struct corgi_lcd), GFP_KERNEL);
drivers/video/backlight/corgi_lcd.c:	lcd->lcd_dev = devm_lcd_device_register(&spi->dev, "corgi_lcd",
drivers/video/backlight/corgi_lcd.c:						&spi->dev, lcd, &corgi_lcd_ops);
drivers/video/backlight/corgi_lcd.c:	lcd->bl_dev = devm_backlight_device_register(&spi->dev, "corgi_bl",
drivers/video/backlight/corgi_lcd.c:						&spi->dev, lcd, &corgi_bl_ops,
drivers/video/backlight/hx8357.c:	lcd = devm_kzalloc(&spi->dev, sizeof(*lcd), GFP_KERNEL);
drivers/video/backlight/hx8357.c:		dev_err(&spi->dev, "SPI setup failed.\n");
drivers/video/backlight/hx8357.c:	match = of_match_device(hx8357_dt_ids, &spi->dev);
drivers/video/backlight/hx8357.c:	lcd->reset = of_get_named_gpio(spi->dev.of_node, "gpios-reset", 0);
drivers/video/backlight/hx8357.c:		dev_err(&spi->dev, "Missing dt property: gpios-reset\n");
drivers/video/backlight/hx8357.c:	ret = devm_gpio_request_one(&spi->dev, lcd->reset,
drivers/video/backlight/hx8357.c:		dev_err(&spi->dev,
drivers/video/backlight/hx8357.c:	if (of_find_property(spi->dev.of_node, "im-gpios", NULL)) {
drivers/video/backlight/hx8357.c:			lcd->im_pins[i] = of_get_named_gpio(spi->dev.of_node,
drivers/video/backlight/hx8357.c:				dev_info(&spi->dev, "GPIO requested is not here yet, deferring the probe\n");
drivers/video/backlight/hx8357.c:				dev_err(&spi->dev, "Missing dt property: im-gpios\n");
drivers/video/backlight/hx8357.c:			ret = devm_gpio_request_one(&spi->dev, lcd->im_pins[i],
drivers/video/backlight/hx8357.c:				dev_err(&spi->dev, "failed to request gpio %d: %d\n",
drivers/video/backlight/hx8357.c:	lcdev = devm_lcd_device_register(&spi->dev, "mxsfb", &spi->dev, lcd,
drivers/video/backlight/hx8357.c:		dev_err(&spi->dev, "Couldn't initialize panel\n");
drivers/video/backlight/hx8357.c:	dev_info(&spi->dev, "Panel probed\n");
drivers/video/backlight/l4f00242t03.c:	struct l4f00242t03_pdata *pdata = dev_get_platdata(&spi->dev);
drivers/video/backlight/l4f00242t03.c:	dev_dbg(&spi->dev, "initializing LCD\n");
drivers/video/backlight/l4f00242t03.c:		dev_err(&spi->dev, "failed to set the IO regulator voltage.\n");
drivers/video/backlight/l4f00242t03.c:		dev_err(&spi->dev, "failed to enable the IO regulator.\n");
drivers/video/backlight/l4f00242t03.c:		dev_err(&spi->dev, "failed to set the core regulator voltage.\n");
drivers/video/backlight/l4f00242t03.c:		dev_err(&spi->dev, "failed to enable the core regulator.\n");
drivers/video/backlight/l4f00242t03.c:	struct l4f00242t03_pdata *pdata = dev_get_platdata(&spi->dev);
drivers/video/backlight/l4f00242t03.c:	dev_dbg(&spi->dev, "Powering down LCD\n");
drivers/video/backlight/l4f00242t03.c:			dev_dbg(&spi->dev, "Resuming LCD\n");
drivers/video/backlight/l4f00242t03.c:			dev_dbg(&spi->dev, "Standby the LCD\n");
drivers/video/backlight/l4f00242t03.c:	struct l4f00242t03_pdata *pdata = dev_get_platdata(&spi->dev);
drivers/video/backlight/l4f00242t03.c:		dev_err(&spi->dev, "Uninitialized platform data.\n");
drivers/video/backlight/l4f00242t03.c:	priv = devm_kzalloc(&spi->dev, sizeof(struct l4f00242t03_priv),
drivers/video/backlight/l4f00242t03.c:	spi->bits_per_word = 9;
drivers/video/backlight/l4f00242t03.c:	ret = devm_gpio_request_one(&spi->dev, pdata->reset_gpio,
drivers/video/backlight/l4f00242t03.c:		dev_err(&spi->dev,
drivers/video/backlight/l4f00242t03.c:	ret = devm_gpio_request_one(&spi->dev, pdata->data_enable_gpio,
drivers/video/backlight/l4f00242t03.c:		dev_err(&spi->dev,
drivers/video/backlight/l4f00242t03.c:	priv->io_reg = devm_regulator_get(&spi->dev, "vdd");
drivers/video/backlight/l4f00242t03.c:		dev_err(&spi->dev, "%s: Unable to get the IO regulator\n",
drivers/video/backlight/l4f00242t03.c:	priv->core_reg = devm_regulator_get(&spi->dev, "vcore");
drivers/video/backlight/l4f00242t03.c:		dev_err(&spi->dev, "%s: Unable to get the core regulator\n",
drivers/video/backlight/l4f00242t03.c:	priv->ld = devm_lcd_device_register(&spi->dev, "l4f00242t03", &spi->dev,
drivers/video/backlight/l4f00242t03.c:	dev_info(&spi->dev, "Epson l4f00242t03 lcd probed.\n");
drivers/video/backlight/ltv350qv.c:	lcd = devm_kzalloc(&spi->dev, sizeof(struct ltv350qv), GFP_KERNEL);
drivers/video/backlight/ltv350qv.c:	lcd->buffer = devm_kzalloc(&spi->dev, 8, GFP_KERNEL);
drivers/video/backlight/ltv350qv.c:	ld = devm_lcd_device_register(&spi->dev, "ltv350qv", &spi->dev, lcd,
drivers/video/backlight/tosa_lcd.c:	data = devm_kzalloc(&spi->dev, sizeof(struct tosa_lcd_data),
drivers/video/backlight/tosa_lcd.c:	spi->bits_per_word = 8;
drivers/video/backlight/tosa_lcd.c:	ret = devm_gpio_request_one(&spi->dev, TOSA_GPIO_TG_ON,
drivers/video/backlight/tosa_lcd.c:	data->lcd = devm_lcd_device_register(&spi->dev, "tosa-lcd", &spi->dev,
drivers/tty/serial/sc16is7xx.c:	spi->bits_per_word	= 8;
drivers/tty/serial/sc16is7xx.c:	spi->mode		= spi->mode ? : SPI_MODE_0;
drivers/tty/serial/sc16is7xx.c:	spi->max_speed_hz	= spi->max_speed_hz ? : 15000000;
drivers/tty/serial/sc16is7xx.c:	if (spi->dev.of_node) {
drivers/tty/serial/sc16is7xx.c:			of_match_device(sc16is7xx_dt_ids, &spi->dev);
drivers/tty/serial/sc16is7xx.c:	return sc16is7xx_probe(&spi->dev, devtype, regmap, spi->irq, flags);
drivers/tty/serial/sc16is7xx.c:	return sc16is7xx_remove(&spi->dev);
drivers/tty/serial/max310x.c:	spi->bits_per_word	= 8;
drivers/tty/serial/max310x.c:	spi->mode		= spi->mode ? : SPI_MODE_0;
drivers/tty/serial/max310x.c:	spi->max_speed_hz	= spi->max_speed_hz ? : 26000000;
drivers/tty/serial/max310x.c:	if (spi->dev.of_node) {
drivers/tty/serial/max310x.c:			of_match_device(max310x_dt_ids, &spi->dev);
drivers/tty/serial/max310x.c:	return max310x_probe(&spi->dev, devtype, regmap, spi->irq);
drivers/tty/serial/max310x.c:	return max310x_remove(&spi->dev);
drivers/tty/serial/ifx6x60.c:		dev_dbg(&spi->dev, "ignoring subsequent detection");
drivers/tty/serial/ifx6x60.c:	pl_data = dev_get_platdata(&spi->dev);
drivers/tty/serial/ifx6x60.c:		dev_err(&spi->dev, "missing platform data!");
drivers/tty/serial/ifx6x60.c:		dev_err(&spi->dev, "spi device allocation failed");
drivers/tty/serial/ifx6x60.c:	spi->max_speed_hz = ifx_dev->max_hz;
drivers/tty/serial/ifx6x60.c:	spi->mode = IFX_SPI_MODE | (SPI_LOOP & spi->mode);
drivers/tty/serial/ifx6x60.c:	spi->bits_per_word = spi_bpw;
drivers/tty/serial/ifx6x60.c:		dev_err(&spi->dev, "SPI setup wasn't successful %d", ret);
drivers/tty/serial/ifx6x60.c:	if (spi->bits_per_word == 32)
drivers/tty/serial/ifx6x60.c:	else if (spi->bits_per_word == 16)
drivers/tty/serial/ifx6x60.c:		dev_err(&spi->dev, "DMA-TX buffer allocation failed");
drivers/tty/serial/ifx6x60.c:		dev_err(&spi->dev, "DMA-RX buffer allocation failed");
drivers/tty/serial/ifx6x60.c:		dev_err(&spi->dev, "create default tty port failed");
drivers/tty/serial/ifx6x60.c:	dev_info(&spi->dev, "gpios %d, %d, %d, %d, %d",
drivers/tty/serial/ifx6x60.c:		dev_err(&spi->dev, "Unable to allocate GPIO%d (RESET)",
drivers/tty/serial/ifx6x60.c:		dev_err(&spi->dev, "Unable to configure GPIO%d (RESET)",
drivers/tty/serial/ifx6x60.c:		dev_err(&spi->dev, "Unable to configure GPIO%d (ON)",
drivers/tty/serial/ifx6x60.c:		dev_err(&spi->dev, "Unable to allocate GPIO%d (MRDY)",
drivers/tty/serial/ifx6x60.c:		dev_err(&spi->dev, "Unable to configure GPIO%d (MRDY)",
drivers/tty/serial/ifx6x60.c:		dev_err(&spi->dev, "Unable to allocate GPIO%d (SRDY)",
drivers/tty/serial/ifx6x60.c:		dev_err(&spi->dev, "Unable to configure GPIO%d (SRDY)",
drivers/tty/serial/ifx6x60.c:		dev_err(&spi->dev, "Unable to allocate GPIO%d (RESET_OUT)",
drivers/tty/serial/ifx6x60.c:		dev_err(&spi->dev, "Unable to configure GPIO%d (RESET_OUT)",
drivers/tty/serial/ifx6x60.c:		dev_err(&spi->dev, "Unable to get irq %x\n",
drivers/tty/serial/ifx6x60.c:		dev_err(&spi->dev, "Unable to get irq %x",
drivers/tty/serial/ifx6x60.c:	pm_runtime_set_active(&spi->dev);
drivers/tty/serial/ifx6x60.c:	pm_runtime_enable(&spi->dev);
drivers/tty/serial/max3100.c:		dev_warn(&s->spi->dev, "error while calling spi_sync\n");
drivers/tty/serial/max3100.c:	dev_dbg(&s->spi->dev, "%04x - %04x\n", tx, *rx);
drivers/tty/serial/max3100.c:		dev_dbg(&s->spi->dev, "%s\n", __func__);
drivers/tty/serial/max3100.c:	dev_dbg(&s->spi->dev, "%s\n", __func__);
drivers/tty/serial/max3100.c:	dev_dbg(&s->spi->dev, "%s\n", __func__);
drivers/tty/serial/max3100.c:	dev_dbg(&s->spi->dev, "%s\n", __func__);
drivers/tty/serial/max3100.c:	dev_dbg(&s->spi->dev, "%s\n", __func__);
drivers/tty/serial/max3100.c:	dev_dbg(&s->spi->dev, "%s\n", __func__);
drivers/tty/serial/max3100.c:	dev_dbg(&s->spi->dev, "%s\n", __func__);
drivers/tty/serial/max3100.c:	dev_dbg(&s->spi->dev, "%s\n", __func__);
drivers/tty/serial/max3100.c:	dev_dbg(&s->spi->dev, "%s\n", __func__);
drivers/tty/serial/max3100.c:	dev_dbg(&s->spi->dev, "%s\n", __func__);
drivers/tty/serial/max3100.c:	dev_dbg(&s->spi->dev, "%s\n", __func__);
drivers/tty/serial/max3100.c:	dev_dbg(&s->spi->dev, "%s\n", __func__);
drivers/tty/serial/max3100.c:		dev_warn(&s->spi->dev, "cannot create workqueue\n");
drivers/tty/serial/max3100.c:		dev_warn(&s->spi->dev, "cannot allocate irq %d\n", s->irq);
drivers/tty/serial/max3100.c:	dev_dbg(&s->spi->dev, "%s\n", __func__);
drivers/tty/serial/max3100.c:	dev_dbg(&s->spi->dev, "%s\n", __func__);
drivers/tty/serial/max3100.c:	dev_dbg(&s->spi->dev, "%s\n", __func__);
drivers/tty/serial/max3100.c:	dev_dbg(&s->spi->dev, "%s\n", __func__);
drivers/tty/serial/max3100.c:	dev_dbg(&s->spi->dev, "%s\n", __func__);
drivers/tty/serial/max3100.c:	dev_dbg(&s->spi->dev, "%s\n", __func__);
drivers/tty/serial/max3100.c:	dev_dbg(&s->spi->dev, "%s\n", __func__);
drivers/tty/serial/max3100.c:		dev_warn(&spi->dev, "too many MAX3100 chips\n");
drivers/tty/serial/max3100.c:		dev_warn(&spi->dev,
drivers/tty/serial/max3100.c:	max3100s[i]->irq = spi->irq;
drivers/tty/serial/max3100.c:	pdata = dev_get_platdata(&spi->dev);
drivers/tty/serial/max3100.c:	dev_dbg(&spi->dev, "%s: adding port %d\n", __func__, i);
drivers/tty/serial/max3100.c:	max3100s[i]->port.dev = &spi->dev;
drivers/tty/serial/max3100.c:		dev_warn(&spi->dev,
drivers/tty/serial/max3100.c:			dev_dbg(&spi->dev, "%s: removing port %d\n", __func__, i);
drivers/tty/serial/max3100.c:	dev_dbg(&s->spi->dev, "%s\n", __func__);
drivers/tty/serial/max3100.c:	dev_dbg(&s->spi->dev, "%s\n", __func__);
drivers/crypto/atmel-authenc.h: * This driver is based on drivers/mtd/spi-nor/fsl-quadspi.c from Freescale.
drivers/nfc/st-nci/Makefile:st-nci_spi-objs = spi.o
drivers/nfc/trf7970a.c:	struct device_node *np = spi->dev.of_node;
drivers/nfc/trf7970a.c:		dev_err(&spi->dev, "No Device Tree entry\n");
drivers/nfc/trf7970a.c:	trf = devm_kzalloc(&spi->dev, sizeof(*trf), GFP_KERNEL);
drivers/nfc/trf7970a.c:	trf->dev = &spi->dev;
drivers/nfc/trf7970a.c:	spi->mode = SPI_MODE_1;
drivers/nfc/trf7970a.c:	spi->bits_per_word = 8;
drivers/nfc/trf7970a.c:	ret = devm_request_threaded_irq(trf->dev, spi->irq, NULL,
drivers/nfc/trf7970a.c:		dev_err(trf->dev, "Can't request IRQ#%d: %d\n", spi->irq, ret);
drivers/nfc/trf7970a.c:	trf->regulator = devm_regulator_get(&spi->dev, "vin");
drivers/nfc/trf7970a.c:	trf->regulator = devm_regulator_get(&spi->dev, "vdd-io");
drivers/nfc/nfcmrvl/spi.c:		nfc_err(&drv_data->spi->dev, "failed to read spi packet");
drivers/nfc/nfcmrvl/spi.c:		nfc_err(&drv_data->spi->dev, "corrupted RX packet");
drivers/nfc/nfcmrvl/spi.c:	drv_data->nci_spi->xfer_speed_hz = config->clk;
drivers/nfc/nfcmrvl/spi.c:	drv_data = devm_kzalloc(&spi->dev, sizeof(*drv_data), GFP_KERNEL);
drivers/nfc/nfcmrvl/spi.c:	pdata = spi->dev.platform_data;
drivers/nfc/nfcmrvl/spi.c:	if (!pdata && spi->dev.of_node)
drivers/nfc/nfcmrvl/spi.c:		if (nfcmrvl_spi_parse_dt(spi->dev.of_node, &config) == 0)
drivers/nfc/nfcmrvl/spi.c:	ret = devm_request_threaded_irq(&drv_data->spi->dev, pdata->irq,
drivers/nfc/nfcmrvl/spi.c:		nfc_err(&drv_data->spi->dev, "Unable to register IRQ handler");
drivers/nfc/nfcmrvl/spi.c:						  &drv_data->spi->dev,
drivers/nfc/nfcmrvl/Makefile:nfcmrvl_spi-y += spi.o
drivers/clk/sprd/sc9860-clk.c:static SPRD_SC_GATE_CLK(mspi_eb,		"mspi-eb",	"aon-apb", 0x0,
drivers/gpu/drm/tinydrm/st7586.c:	struct device *dev = &spi->dev;
drivers/gpu/drm/tinydrm/st7586.c:	ret = st7586_init(&spi->dev, mipi, &st7586_pipe_funcs, &st7586_driver,
drivers/gpu/drm/tinydrm/mi0283qt.c:	struct device *dev = &spi->dev;
drivers/gpu/drm/tinydrm/mi0283qt.c:	ret = mipi_dbi_init(&spi->dev, mipi, &mi0283qt_pipe_funcs,
drivers/gpu/drm/tinydrm/core/tinydrm-helpers.c:	ret = min(spi_max_transfer_size(spi), spi->master->max_dma_len);
drivers/gpu/drm/tinydrm/core/tinydrm-helpers.c:	u32 bpw_mask = spi->master->bits_per_word_mask;
drivers/gpu/drm/tinydrm/core/tinydrm-helpers.c:		dev_warn_once(&spi->dev,
drivers/gpu/drm/tinydrm/core/tinydrm-helpers.c:	u32 speed_hz = tr->speed_hz ? tr->speed_hz : spi->max_speed_hz;
drivers/gpu/drm/tinydrm/mipi-dbi.c:	return min_t(u32, 10000000, spi->max_speed_hz);
drivers/gpu/drm/tinydrm/mipi-dbi.c:			     spi->max_speed_hz / 2);
drivers/gpu/drm/tinydrm/mipi-dbi.c:	struct device *dev = &spi->dev;
drivers/gpu/drm/tinydrm/mipi-dbi.c:	DRM_DEBUG_DRIVER("SPI speed: %uMHz\n", spi->max_speed_hz / 1000000);
drivers/gpu/drm/tinydrm/repaper.c:		DRM_DEV_ERROR(&epd->spi->dev, "Failed to get temperature (%d)\n", ret);
drivers/gpu/drm/tinydrm/repaper.c:	struct device *dev = &spi->dev;
drivers/gpu/drm/tinydrm/repaper.c:	struct device *dev = &spi->dev;
drivers/gpu/drm/tinydrm/repaper.c:	DRM_DEBUG_DRIVER("SPI speed: %uMHz\n", spi->max_speed_hz / 1000000);
drivers/gpu/drm/tinydrm/st7735r.c:	struct device *dev = &spi->dev;
drivers/gpu/drm/tinydrm/st7735r.c:	ret = mipi_dbi_init(&spi->dev, mipi, &jd_t18003_t01_pipe_funcs,
drivers/gpu/drm/tinydrm/ili9225.c:	struct device *dev = &spi->dev;
drivers/gpu/drm/tinydrm/ili9225.c:	ret = ili9225_init(&spi->dev, mipi, &ili9225_pipe_funcs,
drivers/gpu/drm/panel/panel-samsung-ld9040.c:	struct device *dev = &spi->dev;
drivers/gpu/drm/panel/panel-samsung-ld9040.c:	spi->bits_per_word = 9;
drivers/gpu/drm/panel/panel-ilitek-ili9322.c:	struct device *dev = &spi->dev;
drivers/gpu/drm/panel/panel-ilitek-ili9322.c:	spi->bits_per_word = 8;
drivers/gpu/drm/panel/panel-sitronix-st7789v.c:	ctx = devm_kzalloc(&spi->dev, sizeof(*ctx), GFP_KERNEL);
drivers/gpu/drm/panel/panel-sitronix-st7789v.c:	ctx->panel.dev = &spi->dev;
drivers/gpu/drm/panel/panel-sitronix-st7789v.c:	ctx->power = devm_regulator_get(&spi->dev, "power");
drivers/gpu/drm/panel/panel-sitronix-st7789v.c:	ctx->reset = devm_gpiod_get(&spi->dev, "reset", GPIOD_OUT_LOW);
drivers/gpu/drm/panel/panel-sitronix-st7789v.c:		dev_err(&spi->dev, "Couldn't get our reset line\n");
drivers/gpu/drm/panel/panel-sitronix-st7789v.c:	backlight = of_parse_phandle(spi->dev.of_node, "backlight", 0);
drivers/gpu/drm/panel/panel-lg-lg4573.c:	ctx = devm_kzalloc(&spi->dev, sizeof(*ctx), GFP_KERNEL);
drivers/gpu/drm/panel/panel-lg-lg4573.c:	spi->bits_per_word = 8;
drivers/gpu/drm/panel/panel-lg-lg4573.c:		dev_err(&spi->dev, "SPI setup failed: %d\n", ret);
drivers/gpu/drm/panel/panel-lg-lg4573.c:	ctx->panel.dev = &spi->dev;
drivers/gpu/drm/omapdrm/displays/panel-sony-acx565akm.c:		dev_dbg(&ddata->spi->dev, "spi_sync %d\n", r);
drivers/gpu/drm/omapdrm/displays/panel-sony-acx565akm.c:	dev_dbg(&ddata->spi->dev,
drivers/gpu/drm/omapdrm/displays/panel-sony-acx565akm.c:	dev_dbg(&ddata->spi->dev, "MIPI display ID: %02x%02x%02x\n",
drivers/gpu/drm/omapdrm/displays/panel-sony-acx565akm.c:		dev_err(&ddata->spi->dev, "invalid display ID\n");
drivers/gpu/drm/omapdrm/displays/panel-sony-acx565akm.c:	dev_info(&ddata->spi->dev, "omapfb: %s rev %02x LCD detected\n",
drivers/gpu/drm/omapdrm/displays/panel-sony-acx565akm.c:	dev_dbg(&ddata->spi->dev, "%s\n", __func__);
drivers/gpu/drm/omapdrm/displays/panel-sony-acx565akm.c:	dev_dbg(&ddata->spi->dev, "%s\n", __func__);
drivers/gpu/drm/omapdrm/displays/panel-sony-acx565akm.c:		dev_dbg(&ddata->spi->dev, "panel already enabled\n");
drivers/gpu/drm/omapdrm/displays/panel-sony-acx565akm.c:	struct panel_drv_data *ddata = dev_get_drvdata(&spi->dev);
drivers/gpu/drm/omapdrm/displays/panel-sony-acx565akm.c:	struct device_node *np = spi->dev.of_node;
drivers/gpu/drm/omapdrm/displays/panel-sony-acx565akm.c:		dev_err(&spi->dev, "failed to find video source\n");
drivers/gpu/drm/omapdrm/displays/panel-sony-acx565akm.c:	dev_dbg(&spi->dev, "%s\n", __func__);
drivers/gpu/drm/omapdrm/displays/panel-sony-acx565akm.c:	if (!spi->dev.of_node)
drivers/gpu/drm/omapdrm/displays/panel-sony-acx565akm.c:	spi->mode = SPI_MODE_3;
drivers/gpu/drm/omapdrm/displays/panel-sony-acx565akm.c:	ddata = devm_kzalloc(&spi->dev, sizeof(*ddata), GFP_KERNEL);
drivers/gpu/drm/omapdrm/displays/panel-sony-acx565akm.c:	dev_set_drvdata(&spi->dev, ddata);
drivers/gpu/drm/omapdrm/displays/panel-sony-acx565akm.c:		r = devm_gpio_request_one(&spi->dev, ddata->reset_gpio,
drivers/gpu/drm/omapdrm/displays/panel-sony-acx565akm.c:		dev_err(&spi->dev, "%s panel detect error\n", __func__);
drivers/gpu/drm/omapdrm/displays/panel-sony-acx565akm.c:	bldev = backlight_device_register("acx565akm", &ddata->spi->dev,
drivers/gpu/drm/omapdrm/displays/panel-sony-acx565akm.c:	dssdev->dev = &spi->dev;
drivers/gpu/drm/omapdrm/displays/panel-sony-acx565akm.c:		dev_err(&spi->dev, "Failed to register panel\n");
drivers/gpu/drm/omapdrm/displays/panel-sony-acx565akm.c:	struct panel_drv_data *ddata = dev_get_drvdata(&spi->dev);
drivers/gpu/drm/omapdrm/displays/panel-sony-acx565akm.c:	dev_dbg(&ddata->spi->dev, "%s\n", __func__);
drivers/gpu/drm/omapdrm/displays/panel-lgphilips-lb035q02.c:	struct device_node *node = spi->dev.of_node;
drivers/gpu/drm/omapdrm/displays/panel-lgphilips-lb035q02.c:	struct panel_drv_data *ddata = dev_get_drvdata(&spi->dev);
drivers/gpu/drm/omapdrm/displays/panel-lgphilips-lb035q02.c:	gpio = devm_gpiod_get(&spi->dev, "enable", GPIOD_OUT_LOW);
drivers/gpu/drm/omapdrm/displays/panel-lgphilips-lb035q02.c:		dev_err(&spi->dev, "failed to parse enable gpio\n");
drivers/gpu/drm/omapdrm/displays/panel-lgphilips-lb035q02.c:		dev_err(&spi->dev, "failed to find video source\n");
drivers/gpu/drm/omapdrm/displays/panel-lgphilips-lb035q02.c:	ddata = devm_kzalloc(&spi->dev, sizeof(*ddata), GFP_KERNEL);
drivers/gpu/drm/omapdrm/displays/panel-lgphilips-lb035q02.c:	dev_set_drvdata(&spi->dev, ddata);
drivers/gpu/drm/omapdrm/displays/panel-lgphilips-lb035q02.c:	if (!spi->dev.of_node)
drivers/gpu/drm/omapdrm/displays/panel-lgphilips-lb035q02.c:	dssdev->dev = &spi->dev;
drivers/gpu/drm/omapdrm/displays/panel-lgphilips-lb035q02.c:		dev_err(&spi->dev, "Failed to register panel\n");
drivers/gpu/drm/omapdrm/displays/panel-lgphilips-lb035q02.c:	struct panel_drv_data *ddata = dev_get_drvdata(&spi->dev);
drivers/gpu/drm/omapdrm/displays/panel-tpo-td028ttec1.c:	struct device_node *node = spi->dev.of_node;
drivers/gpu/drm/omapdrm/displays/panel-tpo-td028ttec1.c:	struct panel_drv_data *ddata = dev_get_drvdata(&spi->dev);
drivers/gpu/drm/omapdrm/displays/panel-tpo-td028ttec1.c:		dev_err(&spi->dev, "failed to find video source\n");
drivers/gpu/drm/omapdrm/displays/panel-tpo-td028ttec1.c:	dev_dbg(&spi->dev, "%s\n", __func__);
drivers/gpu/drm/omapdrm/displays/panel-tpo-td028ttec1.c:	spi->bits_per_word = 9;
drivers/gpu/drm/omapdrm/displays/panel-tpo-td028ttec1.c:	spi->mode = SPI_MODE_3;
drivers/gpu/drm/omapdrm/displays/panel-tpo-td028ttec1.c:		dev_err(&spi->dev, "spi_setup failed: %d\n", r);
drivers/gpu/drm/omapdrm/displays/panel-tpo-td028ttec1.c:	ddata = devm_kzalloc(&spi->dev, sizeof(*ddata), GFP_KERNEL);
drivers/gpu/drm/omapdrm/displays/panel-tpo-td028ttec1.c:	dev_set_drvdata(&spi->dev, ddata);
drivers/gpu/drm/omapdrm/displays/panel-tpo-td028ttec1.c:	if (!spi->dev.of_node)
drivers/gpu/drm/omapdrm/displays/panel-tpo-td028ttec1.c:	dssdev->dev = &spi->dev;
drivers/gpu/drm/omapdrm/displays/panel-tpo-td028ttec1.c:		dev_err(&spi->dev, "Failed to register panel\n");
drivers/gpu/drm/omapdrm/displays/panel-tpo-td028ttec1.c:	struct panel_drv_data *ddata = dev_get_drvdata(&spi->dev);
drivers/gpu/drm/omapdrm/displays/panel-tpo-td043mtea1.c:		dev_warn(&spi->dev, "failed to write to LCD reg (%d)\n", r);
drivers/gpu/drm/omapdrm/displays/panel-tpo-td043mtea1.c:	struct device_node *node = spi->dev.of_node;
drivers/gpu/drm/omapdrm/displays/panel-tpo-td043mtea1.c:	struct panel_drv_data *ddata = dev_get_drvdata(&spi->dev);
drivers/gpu/drm/omapdrm/displays/panel-tpo-td043mtea1.c:		dev_err(&spi->dev, "failed to parse enable gpio\n");
drivers/gpu/drm/omapdrm/displays/panel-tpo-td043mtea1.c:		dev_err(&spi->dev, "failed to find video source\n");
drivers/gpu/drm/omapdrm/displays/panel-tpo-td043mtea1.c:	dev_dbg(&spi->dev, "%s\n", __func__);
drivers/gpu/drm/omapdrm/displays/panel-tpo-td043mtea1.c:	spi->bits_per_word = 16;
drivers/gpu/drm/omapdrm/displays/panel-tpo-td043mtea1.c:	spi->mode = SPI_MODE_0;
drivers/gpu/drm/omapdrm/displays/panel-tpo-td043mtea1.c:		dev_err(&spi->dev, "spi_setup failed: %d\n", r);
drivers/gpu/drm/omapdrm/displays/panel-tpo-td043mtea1.c:	ddata = devm_kzalloc(&spi->dev, sizeof(*ddata), GFP_KERNEL);
drivers/gpu/drm/omapdrm/displays/panel-tpo-td043mtea1.c:	dev_set_drvdata(&spi->dev, ddata);
drivers/gpu/drm/omapdrm/displays/panel-tpo-td043mtea1.c:	if (!spi->dev.of_node)
drivers/gpu/drm/omapdrm/displays/panel-tpo-td043mtea1.c:	ddata->vcc_reg = devm_regulator_get(&spi->dev, "vcc");
drivers/gpu/drm/omapdrm/displays/panel-tpo-td043mtea1.c:		dev_err(&spi->dev, "failed to get LCD VCC regulator\n");
drivers/gpu/drm/omapdrm/displays/panel-tpo-td043mtea1.c:		r = devm_gpio_request_one(&spi->dev,
drivers/gpu/drm/omapdrm/displays/panel-tpo-td043mtea1.c:			dev_err(&spi->dev, "couldn't request reset GPIO\n");
drivers/gpu/drm/omapdrm/displays/panel-tpo-td043mtea1.c:	r = sysfs_create_group(&spi->dev.kobj, &tpo_td043_attr_group);
drivers/gpu/drm/omapdrm/displays/panel-tpo-td043mtea1.c:		dev_err(&spi->dev, "failed to create sysfs files\n");
drivers/gpu/drm/omapdrm/displays/panel-tpo-td043mtea1.c:	dssdev->dev = &spi->dev;
drivers/gpu/drm/omapdrm/displays/panel-tpo-td043mtea1.c:		dev_err(&spi->dev, "Failed to register panel\n");
drivers/gpu/drm/omapdrm/displays/panel-tpo-td043mtea1.c:	sysfs_remove_group(&spi->dev.kobj, &tpo_td043_attr_group);
drivers/gpu/drm/omapdrm/displays/panel-tpo-td043mtea1.c:	struct panel_drv_data *ddata = dev_get_drvdata(&spi->dev);
drivers/gpu/drm/omapdrm/displays/panel-tpo-td043mtea1.c:	dev_dbg(&ddata->spi->dev, "%s\n", __func__);
drivers/gpu/drm/omapdrm/displays/panel-tpo-td043mtea1.c:	sysfs_remove_group(&spi->dev.kobj, &tpo_td043_attr_group);
drivers/gpu/drm/omapdrm/displays/panel-nec-nl8048hl11.c:	struct device_node *node = spi->dev.of_node;
drivers/gpu/drm/omapdrm/displays/panel-nec-nl8048hl11.c:	struct panel_drv_data *ddata = dev_get_drvdata(&spi->dev);
drivers/gpu/drm/omapdrm/displays/panel-nec-nl8048hl11.c:		dev_err(&spi->dev, "failed to parse enable gpio\n");
drivers/gpu/drm/omapdrm/displays/panel-nec-nl8048hl11.c:		dev_err(&spi->dev, "failed to find video source\n");
drivers/gpu/drm/omapdrm/displays/panel-nec-nl8048hl11.c:	dev_dbg(&spi->dev, "%s\n", __func__);
drivers/gpu/drm/omapdrm/displays/panel-nec-nl8048hl11.c:	spi->mode = SPI_MODE_0;
drivers/gpu/drm/omapdrm/displays/panel-nec-nl8048hl11.c:	spi->bits_per_word = 32;
drivers/gpu/drm/omapdrm/displays/panel-nec-nl8048hl11.c:		dev_err(&spi->dev, "spi_setup failed: %d\n", r);
drivers/gpu/drm/omapdrm/displays/panel-nec-nl8048hl11.c:	ddata = devm_kzalloc(&spi->dev, sizeof(*ddata), GFP_KERNEL);
drivers/gpu/drm/omapdrm/displays/panel-nec-nl8048hl11.c:	dev_set_drvdata(&spi->dev, ddata);
drivers/gpu/drm/omapdrm/displays/panel-nec-nl8048hl11.c:	if (!spi->dev.of_node)
drivers/gpu/drm/omapdrm/displays/panel-nec-nl8048hl11.c:		r = devm_gpio_request_one(&spi->dev, ddata->qvga_gpio,
drivers/gpu/drm/omapdrm/displays/panel-nec-nl8048hl11.c:		r = devm_gpio_request_one(&spi->dev, ddata->res_gpio,
drivers/gpu/drm/omapdrm/displays/panel-nec-nl8048hl11.c:	dssdev->dev = &spi->dev;
drivers/gpu/drm/omapdrm/displays/panel-nec-nl8048hl11.c:		dev_err(&spi->dev, "Failed to register panel\n");
drivers/gpu/drm/omapdrm/displays/panel-nec-nl8048hl11.c:	struct panel_drv_data *ddata = dev_get_drvdata(&spi->dev);
drivers/gpu/drm/omapdrm/displays/panel-nec-nl8048hl11.c:	dev_dbg(&ddata->spi->dev, "%s\n", __func__);
drivers/mmc/host/mmc_spi.c:		dev_dbg(&host->spi->dev, "bad response type %04x\n",
drivers/mmc/host/mmc_spi.c:		dev_dbg(&host->spi->dev, "%s: resp %04x %08x\n",
drivers/mmc/host/mmc_spi.c:	dev_dbg(&host->spi->dev, "  mmc_spi: CMD%d, resp %s\n",
drivers/mmc/host/mmc_spi.c:		dev_dbg(&host->spi->dev, "  ... write returned %d\n", status);
drivers/mmc/host/mmc_spi.c:		dev_dbg(&spi->dev, "write error (%d)\n", status);
drivers/mmc/host/mmc_spi.c:		dev_dbg(&spi->dev, "write error %02x (%d)\n",
drivers/mmc/host/mmc_spi.c:		dev_dbg(&spi->dev, "read error %02x (%d)\n", status, status);
drivers/mmc/host/mmc_spi.c:			dev_dbg(&spi->dev, "read - crc error: crc_val=0x%04x, "
drivers/mmc/host/mmc_spi.c:		clock_rate = spi->max_speed_hz;
drivers/mmc/host/mmc_spi.c:			dev_dbg(&host->spi->dev,
drivers/mmc/host/mmc_spi.c:			dev_dbg(&spi->dev, "%s status %d\n",
drivers/mmc/host/mmc_spi.c:		dev_dbg(&spi->dev, "    mmc_spi: STOP_TRAN\n");
drivers/mmc/host/mmc_spi.c:			dev_dbg(&host->spi->dev, "bogus command\n");
drivers/mmc/host/mmc_spi.c:			dev_dbg(&host->spi->dev, "bogus STOP command\n");
drivers/mmc/host/mmc_spi.c:	spi_bus_lock(host->spi->master);
drivers/mmc/host/mmc_spi.c:	spi_bus_unlock(host->spi->master);
drivers/mmc/host/mmc_spi.c:	host->spi->mode |= SPI_CS_HIGH;
drivers/mmc/host/mmc_spi.c:		dev_warn(&host->spi->dev,
drivers/mmc/host/mmc_spi.c:		host->spi->mode &= ~SPI_CS_HIGH;
drivers/mmc/host/mmc_spi.c:		host->spi->mode &= ~SPI_CS_HIGH;
drivers/mmc/host/mmc_spi.c:			dev_err(&host->spi->dev,
drivers/mmc/host/mmc_spi.c:		dev_dbg(&host->spi->dev, "mmc_spi: power %s (%d)%s\n",
drivers/mmc/host/mmc_spi.c:				host->pdata->setpower(&host->spi->dev,
drivers/mmc/host/mmc_spi.c:			host->spi->mode &= ~(SPI_CPOL|SPI_CPHA);
drivers/mmc/host/mmc_spi.c:				dev_dbg(&host->spi->dev,
drivers/mmc/host/mmc_spi.c:				dev_dbg(&host->spi->dev,
drivers/mmc/host/mmc_spi.c:				host->spi->mode |= (SPI_CPOL|SPI_CPHA);
drivers/mmc/host/mmc_spi.c:					dev_dbg(&host->spi->dev,
drivers/mmc/host/mmc_spi.c:	if (host->spi->max_speed_hz != ios->clock && ios->clock != 0) {
drivers/mmc/host/mmc_spi.c:		host->spi->max_speed_hz = ios->clock;
drivers/mmc/host/mmc_spi.c:		dev_dbg(&host->spi->dev,
drivers/mmc/host/mmc_spi.c:			host->spi->max_speed_hz, status);
drivers/mmc/host/mmc_spi.c:	if (spi->master->flags & SPI_MASTER_HALF_DUPLEX)
drivers/mmc/host/mmc_spi.c:	if (spi->mode != SPI_MODE_3)
drivers/mmc/host/mmc_spi.c:		spi->mode = SPI_MODE_0;
drivers/mmc/host/mmc_spi.c:	spi->bits_per_word = 8;
drivers/mmc/host/mmc_spi.c:		dev_dbg(&spi->dev, "needs SPI mode %02x, %d KHz; %d\n",
drivers/mmc/host/mmc_spi.c:				spi->mode, spi->max_speed_hz / 1000,
drivers/mmc/host/mmc_spi.c:	mmc = mmc_alloc_host(sizeof(*host), &spi->dev);
drivers/mmc/host/mmc_spi.c:	mmc->f_max = spi->max_speed_hz;
drivers/mmc/host/mmc_spi.c:		dev_warn(&spi->dev, "ASSUMING 3.2-3.4 V slot power\n");
drivers/mmc/host/mmc_spi.c:	dev_set_drvdata(&spi->dev, mmc);
drivers/mmc/host/mmc_spi.c:	if (spi->master->dev.parent->dma_mask) {
drivers/mmc/host/mmc_spi.c:		struct device	*dev = spi->master->dev.parent;
drivers/mmc/host/mmc_spi.c:		status = host->pdata->init(&spi->dev, mmc_spi_detect_irq, mmc);
drivers/mmc/host/mmc_spi.c:	dev_info(&spi->dev, "SD/MMC host %s%s%s%s%s\n",
drivers/mmc/host/mmc_spi.c:	dev_set_drvdata(&spi->dev, NULL);
drivers/mmc/host/mmc_spi.c:	struct mmc_host		*mmc = dev_get_drvdata(&spi->dev);
drivers/mmc/host/mmc_spi.c:			host->pdata->exit(&spi->dev, mmc);
drivers/mmc/host/mmc_spi.c:		spi->max_speed_hz = mmc->f_max;
drivers/mmc/host/mmc_spi.c:		dev_set_drvdata(&spi->dev, NULL);
drivers/mmc/host/mmc_spi.c:	{ .compatible = "mmc-spi-slot", },
drivers/mmc/host/cavium.c:		of_property_read_u32(node, "spi-max-frequency", &mmc->f_max);
drivers/mmc/host/of_mmc_spi.c:	struct device *dev = &spi->dev;
drivers/mmc/host/of_mmc_spi.c:	struct device *dev = &spi->dev;
drivers/usb/host/max3421-hcd.c:		dev_err(&spi->dev,
drivers/usb/host/max3421-hcd.c:				dev_dbg(&spi->dev, "%s: URB %p unlinked=%d",
drivers/usb/host/max3421-hcd.c:				dev_dbg(&spi->dev, "%s: URB %p unlinked=%d",
drivers/usb/host/max3421-hcd.c:		dev_dbg(&spi->dev, "%s: unexpected error HRSL=0x%02x",
drivers/usb/host/max3421-hcd.c:			dev_dbg(&spi->dev, "%s: unexpected error HRSL=0x%02x",
drivers/usb/host/max3421-hcd.c:		dev_dbg(&spi->dev, "%s: unexpected error HRSL=0x%02x",
drivers/usb/host/max3421-hcd.c:		dev_err(&spi->dev,
drivers/usb/host/max3421-hcd.c:		disable_irq_nosync(spi->irq);
drivers/usb/host/max3421-hcd.c:			dev_err(&spi->dev,
drivers/usb/host/max3421-hcd.c:		dev_err(&spi->dev, "bad rev 0x%02x", max3421_hcd->rev);
drivers/usb/host/max3421-hcd.c:	dev_info(&spi->dev, "rev 0x%x, SPI clk %dHz, bpw %u, irq %d\n",
drivers/usb/host/max3421-hcd.c:		 max3421_hcd->rev, spi->max_speed_hz, spi->bits_per_word,
drivers/usb/host/max3421-hcd.c:		 spi->irq);
drivers/usb/host/max3421-hcd.c:				enable_irq(spi->irq);
drivers/usb/host/max3421-hcd.c:	dev_info(&spi->dev, "SPI thread exiting");
drivers/usb/host/max3421-hcd.c:			dev_err(&spi->dev,
drivers/usb/host/max3421-hcd.c:	pdata = spi->dev.platform_data;
drivers/usb/host/max3421-hcd.c:	struct device *dev = &spi->dev;
drivers/usb/host/max3421-hcd.c:		dev_err(&spi->dev, "Unable to setup SPI bus");
drivers/usb/host/max3421-hcd.c:	if (!spi->irq) {
drivers/usb/host/max3421-hcd.c:		pdata = devm_kzalloc(&spi->dev, sizeof(*pdata), GFP_KERNEL);
drivers/usb/host/max3421-hcd.c:		spi->dev.platform_data = pdata;
drivers/usb/host/max3421-hcd.c:	pdata = spi->dev.platform_data;
drivers/usb/host/max3421-hcd.c:		dev_err(&spi->dev, "driver configuration data is not provided\n");
drivers/usb/host/max3421-hcd.c:		dev_err(&spi->dev, "vbus active level value %d is out of range (0/1)\n", pdata->vbus_active_level);
drivers/usb/host/max3421-hcd.c:		dev_err(&spi->dev, "vbus gpout value %d is out of range (1..8)\n", pdata->vbus_gpout);
drivers/usb/host/max3421-hcd.c:	hcd = usb_create_hcd(&max3421_hcd_desc, &spi->dev,
drivers/usb/host/max3421-hcd.c:			     dev_name(&spi->dev));
drivers/usb/host/max3421-hcd.c:		dev_err(&spi->dev, "failed to create HCD structure\n");
drivers/usb/host/max3421-hcd.c:		dev_err(&spi->dev,
drivers/usb/host/max3421-hcd.c:		dev_err(&spi->dev, "failed to add HCD\n");
drivers/usb/host/max3421-hcd.c:	retval = request_irq(spi->irq, max3421_irq_handler,
drivers/usb/host/max3421-hcd.c:		dev_err(&spi->dev, "failed to request irq %d\n", spi->irq);
drivers/usb/host/max3421-hcd.c:		devm_kfree(&spi->dev, pdata);
drivers/usb/host/max3421-hcd.c:		spi->dev.platform_data = NULL;
drivers/usb/host/max3421-hcd.c:		if (hcd->self.controller == &spi->dev)
drivers/usb/host/max3421-hcd.c:		dev_err(&spi->dev, "no MAX3421 HCD found for SPI device %p\n",
drivers/usb/host/max3421-hcd.c:	free_irq(spi->irq, hcd);
drivers/pinctrl/pinctrl-rockchip.c:		/* spi-0 */
drivers/pinctrl/pinctrl-rockchip.c:		/* spi-1 */
drivers/pinctrl/pinctrl-rockchip.c:		/* spi-2 */
drivers/pinctrl/pinctrl-rockchip.c:		/* spi-0_rx */
drivers/pinctrl/pinctrl-rockchip.c:		/* spi-1_rx */
drivers/pinctrl/pinctrl-mcp23s08.c:	match = of_match_device(of_match_ptr(mcp23s08_spi_of_match), &spi->dev);
drivers/pinctrl/pinctrl-mcp23s08.c:	pdata = dev_get_platdata(&spi->dev);
drivers/pinctrl/pinctrl-mcp23s08.c:		status = device_property_read_u32(&spi->dev,
drivers/pinctrl/pinctrl-mcp23s08.c:			"microchip,spi-present-mask", &pdata->spi_present_mask);
drivers/pinctrl/pinctrl-mcp23s08.c:			status = device_property_read_u32(&spi->dev,
drivers/pinctrl/pinctrl-mcp23s08.c:				"mcp,spi-present-mask",
drivers/pinctrl/pinctrl-mcp23s08.c:				dev_err(&spi->dev, "missing spi-present-mask");
drivers/pinctrl/pinctrl-mcp23s08.c:		dev_err(&spi->dev, "invalid spi-present-mask");
drivers/pinctrl/pinctrl-mcp23s08.c:	data = devm_kzalloc(&spi->dev,
drivers/pinctrl/pinctrl-mcp23s08.c:		data->mcp[addr]->irq = spi->irq;
drivers/pinctrl/pinctrl-mcp23s08.c:		status = mcp23s08_probe_one(data->mcp[addr], &spi->dev, spi,
drivers/pinctrl/mvebu/pinctrl-kirkwood.c:		MPP_VAR_FUNCTION(0x2, "tdm", "spi-cs0",  V(0, 0, 1, 1, 1, 0)),
drivers/pinctrl/mvebu/pinctrl-kirkwood.c:		MPP_VAR_FUNCTION(0x2, "tdm", "spi-sck",  V(0, 0, 1, 1, 1, 0)),
drivers/pinctrl/mvebu/pinctrl-kirkwood.c:		MPP_VAR_FUNCTION(0x2, "tdm", "spi-miso", V(0, 0, 1, 1, 1, 0)),
drivers/pinctrl/mvebu/pinctrl-kirkwood.c:		MPP_VAR_FUNCTION(0x2, "tdm", "spi-mosi", V(0, 0, 1, 1, 1, 0)),
drivers/pinctrl/mvebu/pinctrl-kirkwood.c:		MPP_VAR_FUNCTION(0x2, "tdm", "spi-cs1",  V(0, 0, 1, 1, 1, 0)),
drivers/pinctrl/mvebu/pinctrl-kirkwood.c:		MPP_VAR_FUNCTION(0x2, "tdm", "spi-cs1",  V(0, 0, 0, 1, 1, 0)),
drivers/pinctrl/mvebu/pinctrl-kirkwood.c:		MPP_VAR_FUNCTION(0x2, "tdm", "spi-cs0",  V(0, 0, 0, 1, 1, 0)),
drivers/pinctrl/mvebu/pinctrl-kirkwood.c:		MPP_VAR_FUNCTION(0x2, "tdm", "spi-sck",  V(0, 0, 0, 1, 1, 0)),
drivers/pinctrl/mvebu/pinctrl-kirkwood.c:		MPP_VAR_FUNCTION(0x2, "tdm", "spi-miso", V(0, 0, 0, 1, 1, 0)),
drivers/pinctrl/mvebu/pinctrl-kirkwood.c:		MPP_VAR_FUNCTION(0x2, "tdm", "spi-mosi", V(0, 0, 0, 1, 1, 0)),
drivers/rtc/rtc-m41t94.c:	spi->bits_per_word = 8;
drivers/rtc/rtc-m41t94.c:		dev_err(&spi->dev, "not found.\n");
drivers/rtc/rtc-m41t94.c:	rtc = devm_rtc_device_register(&spi->dev, m41t94_driver.driver.name,
drivers/rtc/rtc-ds1347.c:	spi->mode = SPI_MODE_3;
drivers/rtc/rtc-ds1347.c:	spi->bits_per_word = 8;
drivers/rtc/rtc-ds1347.c:		dev_err(&spi->dev, "ds1347 regmap init spi failed\n");
drivers/rtc/rtc-ds1347.c:	dev_info(&spi->dev, "DS1347 RTC CTRL Reg = 0x%02x\n", data);
drivers/rtc/rtc-ds1347.c:	dev_info(&spi->dev, "DS1347 RTC Status Reg = 0x%02x\n", data);
drivers/rtc/rtc-ds1347.c:	rtc = devm_rtc_device_register(&spi->dev, "ds1347",
drivers/rtc/rtc-max6916.c:		dev_err(&spi->dev, "Year must be between 2000 and 2099. It's %d.\n",
drivers/rtc/rtc-max6916.c:	spi->mode = SPI_MODE_3;
drivers/rtc/rtc-max6916.c:	spi->bits_per_word = 8;
drivers/rtc/rtc-max6916.c:	res = max6916_read_reg(&spi->dev, MAX6916_SECONDS_REG, &data);
drivers/rtc/rtc-max6916.c:	max6916_read_reg(&spi->dev, MAX6916_CONTROL_REG, &data);
drivers/rtc/rtc-max6916.c:	max6916_write_reg(&spi->dev, MAX6916_CONTROL_REG, data);
drivers/rtc/rtc-max6916.c:	max6916_read_reg(&spi->dev, MAX6916_STATUS_REG, &data);
drivers/rtc/rtc-max6916.c:	max6916_write_reg(&spi->dev, MAX6916_STATUS_REG, data);
drivers/rtc/rtc-max6916.c:	max6916_read_reg(&spi->dev, MAX6916_CONTROL_REG, &data);
drivers/rtc/rtc-max6916.c:	dev_info(&spi->dev, "MAX6916 RTC CTRL Reg = 0x%02x\n", data);
drivers/rtc/rtc-max6916.c:	max6916_read_reg(&spi->dev, MAX6916_STATUS_REG, &data);
drivers/rtc/rtc-max6916.c:	dev_info(&spi->dev, "MAX6916 RTC Status Reg = 0x%02x\n", data);
drivers/rtc/rtc-max6916.c:	rtc = devm_rtc_device_register(&spi->dev, "max6916",
drivers/rtc/rtc-rv3029c2.c:		dev_err(&spi->dev, "%s: regmap allocation failed: %ld\n",
drivers/rtc/rtc-rv3029c2.c:	return rv3029_probe(&spi->dev, regmap, spi->irq, "rv3049");
drivers/rtc/rtc-mcp795.c:	ret = mcp795_update_alarm(&spi->dev, false);
drivers/rtc/rtc-mcp795.c:		dev_err(&spi->dev,
drivers/rtc/rtc-mcp795.c:	spi->mode = SPI_MODE_0;
drivers/rtc/rtc-mcp795.c:	spi->bits_per_word = 8;
drivers/rtc/rtc-mcp795.c:		dev_err(&spi->dev, "Unable to setup SPI\n");
drivers/rtc/rtc-mcp795.c:	mcp795_start_oscillator(&spi->dev, NULL);
drivers/rtc/rtc-mcp795.c:	mcp795_rtcc_set_bits(&spi->dev, 0x03, MCP795_24_BIT, 0);
drivers/rtc/rtc-mcp795.c:	rtc = devm_rtc_device_register(&spi->dev, "rtc-mcp795",
drivers/rtc/rtc-mcp795.c:	if (spi->irq > 0) {
drivers/rtc/rtc-mcp795.c:		dev_dbg(&spi->dev, "Alarm support enabled\n");
drivers/rtc/rtc-mcp795.c:		mcp795_rtcc_set_bits(&spi->dev, MCP795_REG_ALM0_DAY,
drivers/rtc/rtc-mcp795.c:		ret = devm_request_threaded_irq(&spi->dev, spi->irq, NULL,
drivers/rtc/rtc-mcp795.c:			dev_err(&spi->dev, "Failed to request IRQ: %d: %d\n",
drivers/rtc/rtc-mcp795.c:						spi->irq, ret);
drivers/rtc/rtc-mcp795.c:			device_init_wakeup(&spi->dev, true);
drivers/rtc/rtc-rx6110.c:	if ((spi->bits_per_word && spi->bits_per_word != 8) ||
drivers/rtc/rtc-rx6110.c:	    (spi->max_speed_hz > 2000000) ||
drivers/rtc/rtc-rx6110.c:	    (spi->mode != (SPI_CS_HIGH | SPI_CPOL | SPI_CPHA))) {
drivers/rtc/rtc-rx6110.c:		dev_warn(&spi->dev, "SPI settings: bits_per_word: %d, max_speed_hz: %d, mode: %xh\n",
drivers/rtc/rtc-rx6110.c:			 spi->bits_per_word, spi->max_speed_hz, spi->mode);
drivers/rtc/rtc-rx6110.c:		dev_warn(&spi->dev, "driving device in an unsupported mode");
drivers/rtc/rtc-rx6110.c:	rx6110 = devm_kzalloc(&spi->dev, sizeof(*rx6110), GFP_KERNEL);
drivers/rtc/rtc-rx6110.c:		dev_err(&spi->dev, "regmap init failed for rtc rx6110\n");
drivers/rtc/rtc-rx6110.c:	rx6110->rtc = devm_rtc_device_register(&spi->dev,
drivers/rtc/rtc-ds1343.c:		dev_err(&priv->spi->dev, "Error in nvram write %d", ret);
drivers/rtc/rtc-ds1343.c:		dev_err(&priv->spi->dev, "Error in nvram read %d\n", ret);
drivers/rtc/rtc-ds1343.c:	priv = devm_kzalloc(&spi->dev, sizeof(struct ds1343_priv), GFP_KERNEL);
drivers/rtc/rtc-ds1343.c:	spi->mode = SPI_MODE_3 | SPI_CS_HIGH;
drivers/rtc/rtc-ds1343.c:	spi->bits_per_word = 8;
drivers/rtc/rtc-ds1343.c:		dev_err(&spi->dev, "spi regmap init failed for rtc ds1343\n");
drivers/rtc/rtc-ds1343.c:	priv->rtc = devm_rtc_device_register(&spi->dev, "ds1343",
drivers/rtc/rtc-ds1343.c:		dev_err(&spi->dev, "unable to register rtc ds1343\n");
drivers/rtc/rtc-ds1343.c:	priv->irq = spi->irq;
drivers/rtc/rtc-ds1343.c:		res = devm_request_threaded_irq(&spi->dev, spi->irq, NULL,
drivers/rtc/rtc-ds1343.c:			dev_err(&spi->dev,
drivers/rtc/rtc-ds1343.c:			device_init_wakeup(&spi->dev, true);
drivers/rtc/rtc-ds1343.c:			dev_pm_set_wake_irq(&spi->dev, spi->irq);
drivers/rtc/rtc-ds1343.c:	res = ds1343_sysfs_register(&spi->dev);
drivers/rtc/rtc-ds1343.c:		dev_err(&spi->dev,
drivers/rtc/rtc-ds1343.c:	if (spi->irq) {
drivers/rtc/rtc-ds1343.c:		dev_pm_clear_wake_irq(&spi->dev);
drivers/rtc/rtc-ds1343.c:		device_init_wakeup(&spi->dev, false);
drivers/rtc/rtc-ds1343.c:		devm_free_irq(&spi->dev, spi->irq, priv);
drivers/rtc/rtc-ds1343.c:	ds1343_sysfs_unregister(&spi->dev);
drivers/rtc/rtc-ds1343.c:	if (spi->irq >= 0 && device_may_wakeup(dev))
drivers/rtc/rtc-ds1343.c:		enable_irq_wake(spi->irq);
drivers/rtc/rtc-ds1343.c:	if (spi->irq >= 0 && device_may_wakeup(dev))
drivers/rtc/rtc-ds1343.c:		disable_irq_wake(spi->irq);
drivers/rtc/rtc-ds1302.c:	if (spi->bits_per_word && (spi->bits_per_word != 8)) {
drivers/rtc/rtc-ds1302.c:		dev_err(&spi->dev, "bad word length\n");
drivers/rtc/rtc-ds1302.c:	} else if (spi->max_speed_hz > 2000000) {
drivers/rtc/rtc-ds1302.c:		dev_err(&spi->dev, "speed is too high\n");
drivers/rtc/rtc-ds1302.c:	} else if (spi->mode & SPI_CPHA) {
drivers/rtc/rtc-ds1302.c:		dev_err(&spi->dev, "bad mode\n");
drivers/rtc/rtc-ds1302.c:		dev_err(&spi->dev, "control register read error %d\n",
drivers/rtc/rtc-ds1302.c:			dev_err(&spi->dev, "control register read error %d\n",
drivers/rtc/rtc-ds1302.c:			dev_err(&spi->dev, "junk in control register\n");
drivers/rtc/rtc-ds1302.c:			dev_err(&spi->dev, "control register write error %d\n",
drivers/rtc/rtc-ds1302.c:			dev_err(&spi->dev,
drivers/rtc/rtc-ds1302.c:			dev_err(&spi->dev, "failed to detect chip\n");
drivers/rtc/rtc-ds1302.c:	rtc = devm_rtc_device_register(&spi->dev, "ds1302",
drivers/rtc/rtc-ds1302.c:		dev_err(&spi->dev, "error %d registering rtc\n", status);
drivers/rtc/rtc-ds1390.c:	if (of_property_read_u32(spi->dev.of_node, "trickle-resistor-ohms",
drivers/rtc/rtc-ds1390.c:	if (of_property_read_bool(spi->dev.of_node, "trickle-diode-disable"))
drivers/rtc/rtc-ds1390.c:		dev_warn(&spi->dev,
drivers/rtc/rtc-ds1390.c:	ds1390_set_reg(&spi->dev, DS1390_REG_TRICKLE, value);
drivers/rtc/rtc-ds1390.c:	spi->mode = SPI_MODE_3;
drivers/rtc/rtc-ds1390.c:	spi->bits_per_word = 8;
drivers/rtc/rtc-ds1390.c:	chip = devm_kzalloc(&spi->dev, sizeof(*chip), GFP_KERNEL);
drivers/rtc/rtc-ds1390.c:	res = ds1390_get_reg(&spi->dev, DS1390_REG_SECONDS, &tmp);
drivers/rtc/rtc-ds1390.c:		dev_err(&spi->dev, "unable to read device\n");
drivers/rtc/rtc-ds1390.c:	if (spi->dev.of_node)
drivers/rtc/rtc-ds1390.c:	chip->rtc = devm_rtc_device_register(&spi->dev, "ds1390",
drivers/rtc/rtc-ds1390.c:		dev_err(&spi->dev, "unable to register device\n");
drivers/rtc/rtc-pcf2127.c:		dev_err(&spi->dev, "%s: regmap allocation failed: %ld\n",
drivers/rtc/rtc-pcf2127.c:	return pcf2127_probe(&spi->dev, regmap, pcf2127_spi_driver.driver.name);
drivers/rtc/rtc-pcf2123.c:	pdata = devm_kzalloc(&spi->dev, sizeof(struct pcf2123_plat_data),
drivers/rtc/rtc-pcf2123.c:	spi->dev.platform_data = pdata;
drivers/rtc/rtc-pcf2123.c:	ret = pcf2123_rtc_read_time(&spi->dev, &tm);
drivers/rtc/rtc-pcf2123.c:		ret = pcf2123_reset(&spi->dev);
drivers/rtc/rtc-pcf2123.c:			dev_err(&spi->dev, "chip not found\n");
drivers/rtc/rtc-pcf2123.c:	dev_info(&spi->dev, "spiclk %u KHz.\n",
drivers/rtc/rtc-pcf2123.c:			(spi->max_speed_hz + 500) / 1000);
drivers/rtc/rtc-pcf2123.c:	rtc = devm_rtc_device_register(&spi->dev, pcf2123_driver.driver.name,
drivers/rtc/rtc-pcf2123.c:		dev_err(&spi->dev, "failed to register.\n");
drivers/rtc/rtc-pcf2123.c:		ret = device_create_file(&spi->dev, &pdata->regs[i].attr);
drivers/rtc/rtc-pcf2123.c:			dev_err(&spi->dev, "Unable to create sysfs %s\n",
drivers/rtc/rtc-pcf2123.c:		device_remove_file(&spi->dev, &pdata->regs[i].attr);
drivers/rtc/rtc-pcf2123.c:	spi->dev.platform_data = NULL;
drivers/rtc/rtc-pcf2123.c:	struct pcf2123_plat_data *pdata = dev_get_platdata(&spi->dev);
drivers/rtc/rtc-pcf2123.c:				device_remove_file(&spi->dev,
drivers/rtc/rtc-ds1305.c:		dev_dbg(&spi->dev, "clear irq --> %d\n", status);
drivers/rtc/rtc-ds1305.c:		enable_irq(spi->irq);
drivers/rtc/rtc-ds1305.c:	struct ds1305_platform_data	*pdata = dev_get_platdata(&spi->dev);
drivers/rtc/rtc-ds1305.c:	if ((spi->bits_per_word && spi->bits_per_word != 8)
drivers/rtc/rtc-ds1305.c:			|| (spi->max_speed_hz > 2000000)
drivers/rtc/rtc-ds1305.c:			|| !(spi->mode & SPI_CPHA))
drivers/rtc/rtc-ds1305.c:	ds1305 = devm_kzalloc(&spi->dev, sizeof(*ds1305), GFP_KERNEL);
drivers/rtc/rtc-ds1305.c:		dev_dbg(&spi->dev, "can't %s, %d\n",
drivers/rtc/rtc-ds1305.c:	dev_dbg(&spi->dev, "ctrl %s: %3ph\n", "read", ds1305->ctrl);
drivers/rtc/rtc-ds1305.c:		dev_dbg(&spi->dev, "RTC chip is not present\n");
drivers/rtc/rtc-ds1305.c:		dev_dbg(&spi->dev, "chip may not be present\n");
drivers/rtc/rtc-ds1305.c:		dev_dbg(&spi->dev, "clear WP --> %d\n", status);
drivers/rtc/rtc-ds1305.c:		dev_warn(&spi->dev, "SET TIME!\n");
drivers/rtc/rtc-ds1305.c:			dev_dbg(&spi->dev, "can't %s, %d\n",
drivers/rtc/rtc-ds1305.c:		dev_dbg(&spi->dev, "ctrl %s: %3ph\n", "write", ds1305->ctrl);
drivers/rtc/rtc-ds1305.c:		dev_dbg(&spi->dev, "read HOUR --> %d\n", status);
drivers/rtc/rtc-ds1305.c:		dev_dbg(&spi->dev, "AM/PM\n");
drivers/rtc/rtc-ds1305.c:	ds1305->rtc = devm_rtc_allocate_device(&spi->dev);
drivers/rtc/rtc-ds1305.c:		dev_dbg(&spi->dev, "register rtc --> %d\n", status);
drivers/rtc/rtc-ds1305.c:	if (spi->irq) {
drivers/rtc/rtc-ds1305.c:		status = devm_request_irq(&spi->dev, spi->irq, ds1305_irq,
drivers/rtc/rtc-ds1305.c:			dev_err(&spi->dev, "request_irq %d --> %d\n",
drivers/rtc/rtc-ds1305.c:					spi->irq, status);
drivers/rtc/rtc-ds1305.c:			device_set_wakeup_capable(&spi->dev, 1);
drivers/rtc/rtc-ds1305.c:	if (spi->irq) {
drivers/rtc/rtc-ds1305.c:		devm_free_irq(&spi->dev, spi->irq, ds1305);
drivers/rtc/rtc-rs5c348.c:	struct rs5c348_plat_data *pdata = dev_get_platdata(&spi->dev);
drivers/rtc/rtc-rs5c348.c:	struct rs5c348_plat_data *pdata = dev_get_platdata(&spi->dev);
drivers/rtc/rtc-rs5c348.c:		dev_err(&spi->dev, "retrieved date/time is not valid.\n");
drivers/rtc/rtc-rs5c348.c:	pdata = devm_kzalloc(&spi->dev, sizeof(struct rs5c348_plat_data),
drivers/rtc/rtc-rs5c348.c:	spi->dev.platform_data = pdata;
drivers/rtc/rtc-rs5c348.c:		dev_err(&spi->dev, "not found.\n");
drivers/rtc/rtc-rs5c348.c:	dev_info(&spi->dev, "spiclk %u KHz.\n",
drivers/rtc/rtc-rs5c348.c:		 (spi->max_speed_hz + 500) / 1000);
drivers/rtc/rtc-rs5c348.c:			dev_warn(&spi->dev, "voltage-low detected.\n");
drivers/rtc/rtc-rs5c348.c:			dev_warn(&spi->dev, "oscillator-stop detected.\n");
drivers/rtc/rtc-rs5c348.c:		ret = rs5c348_rtc_set_time(&spi->dev, &tm);
drivers/rtc/rtc-rs5c348.c:	rtc = devm_rtc_device_register(&spi->dev, rs5c348_driver.driver.name,
drivers/rtc/rtc-m41t93.c:		dev_warn(&spi->dev, "unsupported date (before 2000-01-01).\n");
drivers/rtc/rtc-m41t93.c:		dev_warn(&spi->dev, "OF bit is set, resetting.\n");
drivers/rtc/rtc-m41t93.c:			dev_warn(&spi->dev,
drivers/rtc/rtc-m41t93.c:		dev_dbg(&spi->dev, "HT bit is set, reenable clock update.\n");
drivers/rtc/rtc-m41t93.c:		dev_warn(&spi->dev, "OF bit is set, write time to restart.\n");
drivers/rtc/rtc-m41t93.c:		dev_warn(&spi->dev, "BL bit is set, replace battery.\n");
drivers/rtc/rtc-m41t93.c:	spi->bits_per_word = 8;
drivers/rtc/rtc-m41t93.c:		dev_err(&spi->dev, "not found 0x%x.\n", res);
drivers/rtc/rtc-m41t93.c:	rtc = devm_rtc_device_register(&spi->dev, m41t93_driver.driver.name,
drivers/rtc/rtc-max6902.c:	spi->mode = SPI_MODE_3;
drivers/rtc/rtc-max6902.c:	spi->bits_per_word = 8;
drivers/rtc/rtc-max6902.c:	res = max6902_get_reg(&spi->dev, MAX6902_REG_SECONDS, &tmp);
drivers/rtc/rtc-max6902.c:	rtc = devm_rtc_device_register(&spi->dev, "max6902",
drivers/rtc/rtc-rx4581.c:	res = rx4581_get_reg(&spi->dev, RX4581_REG_SC, &tmp);
drivers/rtc/rtc-rx4581.c:	rtc = devm_rtc_device_register(&spi->dev, "rx4581",
drivers/rtc/rtc-r9701.c:	res = read_regs(&spi->dev, &tmp, 1);
drivers/rtc/rtc-r9701.c:		dev_err(&spi->dev, "cannot read RTC register\n");
drivers/rtc/rtc-r9701.c:	if (r9701_get_datetime(&spi->dev, &dt)) {
drivers/rtc/rtc-r9701.c:		dev_info(&spi->dev, "trying to repair invalid date/time\n");
drivers/rtc/rtc-r9701.c:		if (r9701_set_datetime(&spi->dev, &dt) ||
drivers/rtc/rtc-r9701.c:				r9701_get_datetime(&spi->dev, &dt)) {
drivers/rtc/rtc-r9701.c:			dev_err(&spi->dev, "cannot repair RTC register\n");
drivers/rtc/rtc-r9701.c:	rtc = devm_rtc_device_register(&spi->dev, "r9701",
drivers/rtc/rtc-ds3232.c:		dev_err(&spi->dev, "%s: regmap allocation failed: %ld\n",
drivers/rtc/rtc-ds3232.c:	spi->mode = SPI_MODE_3;
drivers/rtc/rtc-ds3232.c:	spi->bits_per_word = 8;
drivers/rtc/rtc-ds3232.c:	dev_info(&spi->dev, "Control Reg: 0x%02x\n", tmp);
drivers/rtc/rtc-ds3232.c:	dev_info(&spi->dev, "Ctrl/Stat Reg: 0x%02x\n", tmp);
drivers/rtc/rtc-ds3232.c:	return ds3232_probe(&spi->dev, regmap, spi->irq, "ds3234");
drivers/irqchip/irq-mvebu-odmi.c:		if (of_property_read_u32_index(node, "marvell,spi-base",
drivers/irqchip/irq-sni-exiu.c:	if (of_property_read_u32(node, "socionext,spi-base", &data->spi_base)) {
drivers/irqchip/irq-sni-exiu.c:		pr_err("%pOF: failed to parse 'spi-base' property\n", node);
drivers/irqchip/irq-mvebu-gicp.c:	ret = of_property_count_u32_elems(node, "marvell,spi-ranges");
drivers/irqchip/irq-mvebu-gicp.c:		of_property_read_u32_index(node, "marvell,spi-ranges",
drivers/irqchip/irq-mvebu-gicp.c:		of_property_read_u32_index(node, "marvell,spi-ranges",
drivers/spi/.spi-gpio.o.cmd:cmd_drivers/spi/spi-gpio.o := arm-linux-gnueabi-gcc -Wp,-MD,drivers/spi/.spi-gpio.o.d  -nostdinc -isystem /usr/lib/gcc-cross/arm-linux-gnueabi/7/include -I./arch/arm/include -I./arch/arm/include/generated  -I./include -I./arch/arm/include/uapi -I./arch/arm/include/generated/uapi -I./include/uapi -I./include/generated/uapi -include ./include/linux/kconfig.h -D__KERNEL__ -mlittle-endian -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -fshort-wchar -Werror-implicit-function-declaration -Wno-format-security -std=gnu89 -fno-PIE -fno-dwarf2-cfi-asm -fno-ipa-sra -mabi=aapcs-linux -mno-thumb-interwork -mfpu=vfp -funwind-tables -marm -Wa,-mno-warn-deprecated -D__LINUX_ARM_ARCH__=5 -march=armv5te -mtune=arm9tdmi -msoft-float -Uarm -fno-delete-null-pointer-checks -Wno-frame-address -Wno-format-truncation -Wno-format-overflow -Wno-int-in-bool-context -O2 --param=allow-store-data-races=0 -DCC_HAVE_ASM_GOTO -Wframe-larger-than=1024 -fno-stack-protector -Wno-unused-but-set-variable -Wno-unused-const-variable -fomit-frame-pointer -fno-var-tracking-assignments -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fno-stack-check -fconserve-stack -Werror=implicit-int -Werror=strict-prototypes -Werror=date-time -Werror=incompatible-pointer-types -Werror=designated-init    -DKBUILD_BASENAME='"spi_gpio"'  -DKBUILD_MODNAME='"spi_gpio"' -c -o drivers/spi/spi-gpio.o drivers/spi/spi-gpio.c
drivers/spi/.spi-gpio.o.cmd:source_drivers/spi/spi-gpio.o := drivers/spi/spi-gpio.c
drivers/spi/.spi-gpio.o.cmd:deps_drivers/spi/spi-gpio.o := \
drivers/spi/.spi-gpio.o.cmd:  drivers/spi/spi-bitbang-txrx.h \
drivers/spi/.spi-gpio.o.cmd:drivers/spi/spi-gpio.o: $(deps_drivers/spi/spi-gpio.o)
drivers/spi/.spi-gpio.o.cmd:$(deps_drivers/spi/spi-gpio.o):
drivers/spi/spi-davinci.c:#include <linux/platform_data/spi-davinci.h>
drivers/spi/spi-davinci.c:	if (dspi->rx) {
drivers/spi/spi-davinci.c:		u8 *rx = dspi->rx;
drivers/spi/spi-davinci.c:		dspi->rx = rx;
drivers/spi/spi-davinci.c:	if (dspi->rx) {
drivers/spi/spi-davinci.c:		u16 *rx = dspi->rx;
drivers/spi/spi-davinci.c:		dspi->rx = rx;
drivers/spi/spi-davinci.c:	if (dspi->tx) {
drivers/spi/spi-davinci.c:		const u8 *tx = dspi->tx;
drivers/spi/spi-davinci.c:		dspi->tx = tx;
drivers/spi/spi-davinci.c:	if (dspi->tx) {
drivers/spi/spi-davinci.c:		const u16 *tx = dspi->tx;
drivers/spi/spi-davinci.c:		dspi->tx = tx;
drivers/spi/spi-davinci.c:	struct davinci_spi_config *spicfg = spi->controller_data;
drivers/spi/spi-davinci.c:	u8 chip_sel = spi->chip_select;
drivers/spi/spi-davinci.c:	dspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-davinci.c:	pdata = &dspi->pdata;
drivers/spi/spi-davinci.c:	if (spi->cs_gpio >= 0) {
drivers/spi/spi-davinci.c:			gpio_set_value(spi->cs_gpio, spi->mode & SPI_CS_HIGH);
drivers/spi/spi-davinci.c:			gpio_set_value(spi->cs_gpio,
drivers/spi/spi-davinci.c:				!(spi->mode & SPI_CS_HIGH));
drivers/spi/spi-davinci.c:	iowrite16(spidat1, dspi->base + SPIDAT1 + 2);
drivers/spi/spi-davinci.c:	ret = DIV_ROUND_UP(clk_get_rate(dspi->clk), max_speed_hz) - 1;
drivers/spi/spi-davinci.c:	if (ret < dspi->prescaler_limit || ret > 255)
drivers/spi/spi-davinci.c:	dspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-davinci.c:	spicfg = spi->controller_data;
drivers/spi/spi-davinci.c:		bits_per_word = spi->bits_per_word;
drivers/spi/spi-davinci.c:		dspi->get_rx = davinci_spi_rx_buf_u8;
drivers/spi/spi-davinci.c:		dspi->get_tx = davinci_spi_tx_buf_u8;
drivers/spi/spi-davinci.c:		dspi->bytes_per_word[spi->chip_select] = 1;
drivers/spi/spi-davinci.c:		dspi->get_rx = davinci_spi_rx_buf_u16;
drivers/spi/spi-davinci.c:		dspi->get_tx = davinci_spi_tx_buf_u16;
drivers/spi/spi-davinci.c:		dspi->bytes_per_word[spi->chip_select] = 2;
drivers/spi/spi-davinci.c:		hz = spi->max_speed_hz;
drivers/spi/spi-davinci.c:	if (spi->mode & SPI_LSB_FIRST)
drivers/spi/spi-davinci.c:	if (spi->mode & SPI_CPOL)
drivers/spi/spi-davinci.c:	if (!(spi->mode & SPI_CPHA))
drivers/spi/spi-davinci.c:	if (dspi->version == SPI_VERSION_2) {
drivers/spi/spi-davinci.c:		if (spi->mode & SPI_READY) {
drivers/spi/spi-davinci.c:		iowrite32(delay, dspi->base + SPIDELAY);
drivers/spi/spi-davinci.c:	iowrite32(spifmt, dspi->base + SPIFMT0);
drivers/spi/spi-davinci.c:	struct davinci_spi_config *spicfg = spi->controller_data;
drivers/spi/spi-davinci.c:	struct device_node *np = spi->dev.of_node;
drivers/spi/spi-davinci.c:	struct davinci_spi *dspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-davinci.c:		if (!of_property_read_u32(np, "ti,spi-wdelay", &prop))
drivers/spi/spi-davinci.c:		spi->controller_data = spicfg;
drivers/spi/spi-davinci.c:		if (dspi->dma_rx && dspi->dma_tx)
drivers/spi/spi-davinci.c:	struct spi_master *master = spi->master;
drivers/spi/spi-davinci.c:	struct device_node *np = spi->dev.of_node;
drivers/spi/spi-davinci.c:	dspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-davinci.c:	pdata = &dspi->pdata;
drivers/spi/spi-davinci.c:	if (!(spi->mode & SPI_NO_CS)) {
drivers/spi/spi-davinci.c:		if (np && (master->cs_gpios != NULL) && (spi->cs_gpio >= 0)) {
drivers/spi/spi-davinci.c:				      spi->cs_gpio, !(spi->mode & SPI_CS_HIGH));
drivers/spi/spi-davinci.c:			   spi->chip_select < pdata->num_chipselect &&
drivers/spi/spi-davinci.c:			   pdata->chip_sel[spi->chip_select] != SPI_INTERN_CS) {
drivers/spi/spi-davinci.c:			spi->cs_gpio = pdata->chip_sel[spi->chip_select];
drivers/spi/spi-davinci.c:				      spi->cs_gpio, !(spi->mode & SPI_CS_HIGH));
drivers/spi/spi-davinci.c:			dev_err(&spi->dev, "GPIO %d setup failed (%d)\n",
drivers/spi/spi-davinci.c:				spi->cs_gpio, retval);
drivers/spi/spi-davinci.c:			set_io_bits(dspi->base + SPIPC0, 1 << spi->chip_select);
drivers/spi/spi-davinci.c:	if (spi->mode & SPI_READY)
drivers/spi/spi-davinci.c:		set_io_bits(dspi->base + SPIPC0, SPIPC0_SPIENA_MASK);
drivers/spi/spi-davinci.c:	if (spi->mode & SPI_LOOP)
drivers/spi/spi-davinci.c:		set_io_bits(dspi->base + SPIGCR1, SPIGCR1_LOOPBACK_MASK);
drivers/spi/spi-davinci.c:		clear_io_bits(dspi->base + SPIGCR1, SPIGCR1_LOOPBACK_MASK);
drivers/spi/spi-davinci.c:	struct davinci_spi_config *spicfg = spi->controller_data;
drivers/spi/spi-davinci.c:	spi->controller_data = NULL;
drivers/spi/spi-davinci.c:	if (spi->dev.of_node)
drivers/spi/spi-davinci.c:	struct davinci_spi_config *spicfg = spi->controller_data;
drivers/spi/spi-davinci.c:	struct device *sdev = dspi->bitbang.master->dev.parent;
drivers/spi/spi-davinci.c:	if (dspi->version == SPI_VERSION_2) {
drivers/spi/spi-davinci.c:	buf = ioread32(dspi->base + SPIBUF);
drivers/spi/spi-davinci.c:	if (dspi->rcount > 0 && !(buf & SPIBUF_RXEMPTY_MASK)) {
drivers/spi/spi-davinci.c:		dspi->get_rx(buf & 0xFFFF, dspi);
drivers/spi/spi-davinci.c:		dspi->rcount--;
drivers/spi/spi-davinci.c:	status = ioread32(dspi->base + SPIFLG);
drivers/spi/spi-davinci.c:	if (dspi->wcount > 0 && !(buf & SPIBUF_TXFULL_MASK)) {
drivers/spi/spi-davinci.c:		spidat1 = ioread32(dspi->base + SPIDAT1);
drivers/spi/spi-davinci.c:		dspi->wcount--;
drivers/spi/spi-davinci.c:		spidat1 |= 0xFFFF & dspi->get_tx(dspi);
drivers/spi/spi-davinci.c:		iowrite32(spidat1, dspi->base + SPIDAT1);
drivers/spi/spi-davinci.c:	dspi->rcount = 0;
drivers/spi/spi-davinci.c:	if (!dspi->wcount && !dspi->rcount)
drivers/spi/spi-davinci.c:		complete(&dspi->done);
drivers/spi/spi-davinci.c:	dspi->wcount = 0;
drivers/spi/spi-davinci.c:	if (!dspi->wcount && !dspi->rcount)
drivers/spi/spi-davinci.c:		complete(&dspi->done);
drivers/spi/spi-davinci.c:	dspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-davinci.c:	pdata = &dspi->pdata;
drivers/spi/spi-davinci.c:	spicfg = (struct davinci_spi_config *)spi->controller_data;
drivers/spi/spi-davinci.c:	data_type = dspi->bytes_per_word[spi->chip_select];
drivers/spi/spi-davinci.c:	dspi->tx = t->tx_buf;
drivers/spi/spi-davinci.c:	dspi->rx = t->rx_buf;
drivers/spi/spi-davinci.c:	dspi->wcount = t->len / data_type;
drivers/spi/spi-davinci.c:	dspi->rcount = dspi->wcount;
drivers/spi/spi-davinci.c:	spidat1 = ioread32(dspi->base + SPIDAT1);
drivers/spi/spi-davinci.c:	clear_io_bits(dspi->base + SPIGCR1, SPIGCR1_POWERDOWN_MASK);
drivers/spi/spi-davinci.c:	set_io_bits(dspi->base + SPIGCR1, SPIGCR1_SPIENA_MASK);
drivers/spi/spi-davinci.c:	reinit_completion(&dspi->done);
drivers/spi/spi-davinci.c:	if (!davinci_spi_can_dma(spi->master, spi, t)) {
drivers/spi/spi-davinci.c:			set_io_bits(dspi->base + SPIINT, SPIINT_MASKINT);
drivers/spi/spi-davinci.c:		dspi->wcount--;
drivers/spi/spi-davinci.c:		tx_data = dspi->get_tx(dspi);
drivers/spi/spi-davinci.c:		iowrite32(spidat1, dspi->base + SPIDAT1);
drivers/spi/spi-davinci.c:			.src_addr = (unsigned long)dspi->pbase + SPIBUF,
drivers/spi/spi-davinci.c:			.dst_addr = (unsigned long)dspi->pbase + SPIDAT1,
drivers/spi/spi-davinci.c:		dmaengine_slave_config(dspi->dma_rx, &dma_rx_conf);
drivers/spi/spi-davinci.c:		dmaengine_slave_config(dspi->dma_tx, &dma_tx_conf);
drivers/spi/spi-davinci.c:		rxdesc = dmaengine_prep_slave_sg(dspi->dma_rx,
drivers/spi/spi-davinci.c:		txdesc = dmaengine_prep_slave_sg(dspi->dma_tx,
drivers/spi/spi-davinci.c:			iowrite16(spidat1 >> 16, dspi->base + SPIDAT1 + 2);
drivers/spi/spi-davinci.c:		dma_async_issue_pending(dspi->dma_rx);
drivers/spi/spi-davinci.c:		dma_async_issue_pending(dspi->dma_tx);
drivers/spi/spi-davinci.c:		set_io_bits(dspi->base + SPIINT, SPIINT_DMA_REQ_EN);
drivers/spi/spi-davinci.c:		if (wait_for_completion_timeout(&dspi->done, HZ) == 0)
drivers/spi/spi-davinci.c:		while (dspi->rcount > 0 || dspi->wcount > 0) {
drivers/spi/spi-davinci.c:	clear_io_bits(dspi->base + SPIINT, SPIINT_MASKALL);
drivers/spi/spi-davinci.c:	if (davinci_spi_can_dma(spi->master, spi, t))
drivers/spi/spi-davinci.c:		clear_io_bits(dspi->base + SPIINT, SPIINT_DMA_REQ_EN);
drivers/spi/spi-davinci.c:	clear_io_bits(dspi->base + SPIGCR1, SPIGCR1_SPIENA_MASK);
drivers/spi/spi-davinci.c:	set_io_bits(dspi->base + SPIGCR1, SPIGCR1_POWERDOWN_MASK);
drivers/spi/spi-davinci.c:							dev_name(&spi->dev));
drivers/spi/spi-davinci.c:	if (dspi->rcount != 0 || dspi->wcount != 0) {
drivers/spi/spi-davinci.c:		dev_err(&spi->dev, "SPI data transfer error\n");
drivers/spi/spi-davinci.c:		clear_io_bits(dspi->base + SPIINT, SPIINT_MASKINT);
drivers/spi/spi-davinci.c:	if ((!dspi->rcount && !dspi->wcount) || status)
drivers/spi/spi-davinci.c:		complete(&dspi->done);
drivers/spi/spi-davinci.c:	struct device *sdev = dspi->bitbang.master->dev.parent;
drivers/spi/spi-davinci.c:	dspi->dma_rx = dma_request_chan(sdev, "rx");
drivers/spi/spi-davinci.c:	if (IS_ERR(dspi->dma_rx))
drivers/spi/spi-davinci.c:		return PTR_ERR(dspi->dma_rx);
drivers/spi/spi-davinci.c:	dspi->dma_tx = dma_request_chan(sdev, "tx");
drivers/spi/spi-davinci.c:	if (IS_ERR(dspi->dma_tx)) {
drivers/spi/spi-davinci.c:		dma_release_channel(dspi->dma_rx);
drivers/spi/spi-davinci.c:		return PTR_ERR(dspi->dma_tx);
drivers/spi/spi-davinci.c:	pdata = &dspi->pdata;
drivers/spi/spi-davinci.c:	of_property_read_u32(node, "ti,davinci-spi-intr-line", &intr_line);
drivers/spi/spi-davinci.c:		dspi->pdata = *pdata;
drivers/spi/spi-davinci.c:	pdata = &dspi->pdata;
drivers/spi/spi-davinci.c:	dspi->bytes_per_word = devm_kzalloc(&pdev->dev,
drivers/spi/spi-davinci.c:					    sizeof(*dspi->bytes_per_word) *
drivers/spi/spi-davinci.c:	if (dspi->bytes_per_word == NULL) {
drivers/spi/spi-davinci.c:	dspi->pbase = r->start;
drivers/spi/spi-davinci.c:	dspi->base = devm_ioremap_resource(&pdev->dev, r);
drivers/spi/spi-davinci.c:	if (IS_ERR(dspi->base)) {
drivers/spi/spi-davinci.c:		ret = PTR_ERR(dspi->base);
drivers/spi/spi-davinci.c:	init_completion(&dspi->done);
drivers/spi/spi-davinci.c:	dspi->irq = ret;
drivers/spi/spi-davinci.c:	ret = devm_request_threaded_irq(&pdev->dev, dspi->irq, davinci_spi_irq,
drivers/spi/spi-davinci.c:	dspi->bitbang.master = master;
drivers/spi/spi-davinci.c:	dspi->clk = devm_clk_get(&pdev->dev, NULL);
drivers/spi/spi-davinci.c:	if (IS_ERR(dspi->clk)) {
drivers/spi/spi-davinci.c:	ret = clk_prepare_enable(dspi->clk);
drivers/spi/spi-davinci.c:	dspi->bitbang.chipselect = davinci_spi_chipselect;
drivers/spi/spi-davinci.c:	dspi->bitbang.setup_transfer = davinci_spi_setup_transfer;
drivers/spi/spi-davinci.c:	dspi->prescaler_limit = pdata->prescaler_limit;
drivers/spi/spi-davinci.c:	dspi->version = pdata->version;
drivers/spi/spi-davinci.c:	dspi->bitbang.flags = SPI_NO_CS | SPI_LSB_FIRST | SPI_LOOP;
drivers/spi/spi-davinci.c:	if (dspi->version == SPI_VERSION_2)
drivers/spi/spi-davinci.c:		dspi->bitbang.flags |= SPI_READY;
drivers/spi/spi-davinci.c:	dspi->bitbang.txrx_bufs = davinci_spi_bufs;
drivers/spi/spi-davinci.c:		dspi->dma_rx = NULL;
drivers/spi/spi-davinci.c:		dspi->dma_tx = NULL;
drivers/spi/spi-davinci.c:	dspi->get_rx = davinci_spi_rx_buf_u8;
drivers/spi/spi-davinci.c:	dspi->get_tx = davinci_spi_tx_buf_u8;
drivers/spi/spi-davinci.c:	iowrite32(0, dspi->base + SPIGCR0);
drivers/spi/spi-davinci.c:	iowrite32(1, dspi->base + SPIGCR0);
drivers/spi/spi-davinci.c:	iowrite32(spipc0, dspi->base + SPIPC0);
drivers/spi/spi-davinci.c:		iowrite32(SPI_INTLVL_1, dspi->base + SPILVL);
drivers/spi/spi-davinci.c:		iowrite32(SPI_INTLVL_0, dspi->base + SPILVL);
drivers/spi/spi-davinci.c:	iowrite32(CS_DEFAULT, dspi->base + SPIDEF);
drivers/spi/spi-davinci.c:	set_io_bits(dspi->base + SPIGCR1, SPIGCR1_CLKMOD_MASK);
drivers/spi/spi-davinci.c:	set_io_bits(dspi->base + SPIGCR1, SPIGCR1_MASTER_MASK);
drivers/spi/spi-davinci.c:	set_io_bits(dspi->base + SPIGCR1, SPIGCR1_POWERDOWN_MASK);
drivers/spi/spi-davinci.c:	ret = spi_bitbang_start(&dspi->bitbang);
drivers/spi/spi-davinci.c:	dev_info(&pdev->dev, "Controller at 0x%p\n", dspi->base);
drivers/spi/spi-davinci.c:	if (dspi->dma_rx) {
drivers/spi/spi-davinci.c:		dma_release_channel(dspi->dma_rx);
drivers/spi/spi-davinci.c:		dma_release_channel(dspi->dma_tx);
drivers/spi/spi-davinci.c:	clk_disable_unprepare(dspi->clk);
drivers/spi/spi-davinci.c:	spi_bitbang_stop(&dspi->bitbang);
drivers/spi/spi-davinci.c:	clk_disable_unprepare(dspi->clk);
drivers/spi/spi-davinci.c:	if (dspi->dma_rx) {
drivers/spi/spi-davinci.c:		dma_release_channel(dspi->dma_rx);
drivers/spi/spi-davinci.c:		dma_release_channel(dspi->dma_tx);
drivers/spi/spi-bitbang.c:	struct spi_bitbang_cs	*cs = spi->controller_state;
drivers/spi/spi-bitbang.c:		bits_per_word = spi->bits_per_word;
drivers/spi/spi-bitbang.c:		hz = spi->max_speed_hz;
drivers/spi/spi-bitbang.c:	struct spi_bitbang_cs	*cs = spi->controller_state;
drivers/spi/spi-bitbang.c:	bitbang = spi_master_get_devdata(spi->master);
drivers/spi/spi-bitbang.c:		spi->controller_state = cs;
drivers/spi/spi-bitbang.c:	cs->txrx_word = bitbang->txrx_word[spi->mode & (SPI_CPOL|SPI_CPHA)];
drivers/spi/spi-bitbang.c:	dev_dbg(&spi->dev, "%s, %u nsec/bit\n", __func__, 2 * cs->nsecs);
drivers/spi/spi-bitbang.c:	kfree(spi->controller_state);
drivers/spi/spi-bitbang.c:	struct spi_bitbang_cs	*cs = spi->controller_state;
drivers/spi/spi-bitbang.c:	struct spi_bitbang *bitbang = spi_master_get_devdata(spi->master);
drivers/spi/spi-bitbang.c:	enable = (!!(spi->mode & SPI_CS_HIGH) == enable);
drivers/spi/spi-orion.c:	return orion_spi->base + reg;
drivers/spi/spi-orion.c:	orion_spi = spi_master_get_devdata(spi->master);
drivers/spi/spi-orion.c:	devdata = orion_spi->devdata;
drivers/spi/spi-orion.c:	tclk_hz = clk_get_rate(orion_spi->clk);
drivers/spi/spi-orion.c:	orion_spi = spi_master_get_devdata(spi->master);
drivers/spi/spi-orion.c:	if (spi->mode & SPI_CPOL)
drivers/spi/spi-orion.c:	if (spi->mode & SPI_CPHA)
drivers/spi/spi-orion.c:	if (spi->mode & SPI_LSB_FIRST)
drivers/spi/spi-orion.c:	orion_spi = spi_master_get_devdata(spi->master);
drivers/spi/spi-orion.c:	if (clk_get_rate(orion_spi->clk) == 250000000 &&
drivers/spi/spi-orion.c:			speed == 50000000 && spi->mode & SPI_CPOL &&
drivers/spi/spi-orion.c:			spi->mode & SPI_CPHA)
drivers/spi/spi-orion.c:	unsigned int speed = spi->max_speed_hz;
drivers/spi/spi-orion.c:	unsigned int bits_per_word = spi->bits_per_word;
drivers/spi/spi-orion.c:	orion_spi = spi_master_get_devdata(spi->master);
drivers/spi/spi-orion.c:	if (orion_spi->devdata->is_errata_50mhz_ac)
drivers/spi/spi-orion.c:	if (gpio_is_valid(spi->cs_gpio))
drivers/spi/spi-orion.c:		cs = spi->chip_select;
drivers/spi/spi-orion.c:	orion_spi = spi_master_get_devdata(spi->master);
drivers/spi/spi-orion.c:	orion_spi = spi_master_get_devdata(spi->master);
drivers/spi/spi-orion.c:		dev_err(&spi->dev, "TXS timed out\n");
drivers/spi/spi-orion.c:	orion_spi = spi_master_get_devdata(spi->master);
drivers/spi/spi-orion.c:		dev_err(&spi->dev, "TXS timed out\n");
drivers/spi/spi-orion.c:	int cs = spi->chip_select;
drivers/spi/spi-orion.c:	word_len = spi->bits_per_word;
drivers/spi/spi-orion.c:	orion_spi = spi_master_get_devdata(spi->master);
drivers/spi/spi-orion.c:	if ((orion_spi->direct_access[cs].vaddr) && (xfer->tx_buf) &&
drivers/spi/spi-orion.c:		iowrite32_rep(orion_spi->direct_access[cs].vaddr,
drivers/spi/spi-orion.c:			iowrite8_rep(orion_spi->direct_access[cs].vaddr,
drivers/spi/spi-orion.c:	spi->master = master;
drivers/spi/spi-orion.c:	spi->devdata = devdata;
drivers/spi/spi-orion.c:	spi->clk = devm_clk_get(&pdev->dev, NULL);
drivers/spi/spi-orion.c:	if (IS_ERR(spi->clk)) {
drivers/spi/spi-orion.c:		status = PTR_ERR(spi->clk);
drivers/spi/spi-orion.c:	status = clk_prepare_enable(spi->clk);
drivers/spi/spi-orion.c:	spi->axi_clk = devm_clk_get(&pdev->dev, "axi");
drivers/spi/spi-orion.c:	if (IS_ERR(spi->axi_clk) &&
drivers/spi/spi-orion.c:	    PTR_ERR(spi->axi_clk) == -EPROBE_DEFER) {
drivers/spi/spi-orion.c:	if (!IS_ERR(spi->axi_clk))
drivers/spi/spi-orion.c:		clk_prepare_enable(spi->axi_clk);
drivers/spi/spi-orion.c:	tclk_hz = clk_get_rate(spi->clk);
drivers/spi/spi-orion.c:	spi->base = devm_ioremap_resource(&pdev->dev, r);
drivers/spi/spi-orion.c:	if (IS_ERR(spi->base)) {
drivers/spi/spi-orion.c:		status = PTR_ERR(spi->base);
drivers/spi/spi-orion.c:		spi->direct_access[cs].vaddr = devm_ioremap(&pdev->dev,
drivers/spi/spi-orion.c:		if (!spi->direct_access[cs].vaddr) {
drivers/spi/spi-orion.c:		spi->direct_access[cs].size = PAGE_SIZE;
drivers/spi/spi-orion.c:	clk_disable_unprepare(spi->axi_clk);
drivers/spi/spi-orion.c:	clk_disable_unprepare(spi->clk);
drivers/spi/spi-orion.c:	clk_disable_unprepare(spi->axi_clk);
drivers/spi/spi-orion.c:	clk_disable_unprepare(spi->clk);
drivers/spi/spi-orion.c:	clk_disable_unprepare(spi->axi_clk);
drivers/spi/spi-orion.c:	clk_disable_unprepare(spi->clk);
drivers/spi/spi-orion.c:	if (!IS_ERR(spi->axi_clk))
drivers/spi/spi-orion.c:		clk_prepare_enable(spi->axi_clk);
drivers/spi/spi-orion.c:	return clk_prepare_enable(spi->clk);
drivers/spi/spi-bfin5xx.c:	struct bfin_spi_master_data *drv_data = spi_master_get_devdata(spi->master);
drivers/spi/spi-bfin5xx.c:	dev_dbg(&spi->dev, "adding an msg in transfer() \n");
drivers/spi/spi-bfin5xx.c:	struct bfin_spi_master_data *drv_data = spi_master_get_devdata(spi->master);
drivers/spi/spi-bfin5xx.c:			dev_err(&spi->dev, "cannot allocate chip data\n");
drivers/spi/spi-bfin5xx.c:		chip_info = spi->controller_data;
drivers/spi/spi-bfin5xx.c:			dev_err(&spi->dev,
drivers/spi/spi-bfin5xx.c:	if (spi->mode & SPI_CPOL)
drivers/spi/spi-bfin5xx.c:	if (spi->mode & SPI_CPHA)
drivers/spi/spi-bfin5xx.c:	if (spi->mode & SPI_LSB_FIRST)
drivers/spi/spi-bfin5xx.c:	chip->baud = hz_to_spi_baud(spi->max_speed_hz);
drivers/spi/spi-bfin5xx.c:	chip->chip_select_num = spi->chip_select;
drivers/spi/spi-bfin5xx.c:		if (!(spi->mode & SPI_CPHA))
drivers/spi/spi-bfin5xx.c:			dev_warn(&spi->dev,
drivers/spi/spi-bfin5xx.c:				"See Documentation/blackfin/bfin-spi-notes.txt\n");
drivers/spi/spi-bfin5xx.c:		chip->flag = (1 << spi->chip_select) << 8;
drivers/spi/spi-bfin5xx.c:		dev_err(&spi->dev,
drivers/spi/spi-bfin5xx.c:			dev_err(&spi->dev,
drivers/spi/spi-bfin5xx.c:			dev_err(&spi->dev, "Unable to set dma callback\n");
drivers/spi/spi-bfin5xx.c:			dev_err(&spi->dev, "Unable to register spi IRQ\n");
drivers/spi/spi-bfin5xx.c:			ret = gpio_request(chip->cs_gpio, spi->modalias);
drivers/spi/spi-bfin5xx.c:				dev_err(&spi->dev, "gpio_request() error\n");
drivers/spi/spi-bfin5xx.c:	dev_dbg(&spi->dev, "setup spi chip %s, width is %d, dma is %d\n",
drivers/spi/spi-bfin5xx.c:			spi->modalias, spi->bits_per_word, chip->enable_dma);
drivers/spi/spi-bfin5xx.c:	dev_dbg(&spi->dev, "ctl_reg is 0x%x, flag_reg is 0x%x\n",
drivers/spi/spi-bfin5xx.c:	dev_dbg(&spi->dev, "chip select number is %d\n", chip->chip_select_num);
drivers/spi/spi-bfin5xx.c:		ret = peripheral_request(ssel[spi->master->bus_num]
drivers/spi/spi-bfin5xx.c:		                         [chip->chip_select_num-1], spi->modalias);
drivers/spi/spi-bfin5xx.c:			dev_err(&spi->dev, "peripheral_request() error\n");
drivers/spi/spi-bfin5xx.c:		peripheral_free(ssel[spi->master->bus_num]
drivers/spi/spi-bfin5xx.c:	struct bfin_spi_master_data *drv_data = spi_master_get_devdata(spi->master);
drivers/spi/spi-bfin5xx.c:		peripheral_free(ssel[spi->master->bus_num]
drivers/spi/spi-bfin5xx.c:	/* the spi->mode bits supported by this driver: */
drivers/spi/spi-img-spfi.c:	struct img_spfi *spfi = spi_master_get_devdata(spi->master);
drivers/spi/spi-img-spfi.c:	struct img_spfi *spfi = spi_master_get_devdata(spi->master);
drivers/spi/spi-img-spfi.c:	if (msg->spi->mode & SPI_CPHA)
drivers/spi/spi-img-spfi.c:		val |= SPFI_PORT_STATE_CK_PHASE(msg->spi->chip_select);
drivers/spi/spi-img-spfi.c:		val &= ~SPFI_PORT_STATE_CK_PHASE(msg->spi->chip_select);
drivers/spi/spi-img-spfi.c:	if (msg->spi->mode & SPI_CPOL)
drivers/spi/spi-img-spfi.c:		val |= SPFI_PORT_STATE_CK_POL(msg->spi->chip_select);
drivers/spi/spi-img-spfi.c:		val &= ~SPFI_PORT_STATE_CK_POL(msg->spi->chip_select);
drivers/spi/spi-img-spfi.c:		ret = gpio_request_one(spi->cs_gpio,
drivers/spi/spi-img-spfi.c:				       (spi->mode & SPI_CS_HIGH) ?
drivers/spi/spi-img-spfi.c:				       dev_name(&spi->dev));
drivers/spi/spi-img-spfi.c:			dev_err(&spi->dev, "can't request chipselect gpio %d\n",
drivers/spi/spi-img-spfi.c:				spi->cs_gpio);
drivers/spi/spi-img-spfi.c:		if (gpio_is_valid(spi->cs_gpio)) {
drivers/spi/spi-img-spfi.c:			int mode = ((spi->mode & SPI_CS_HIGH) ?
drivers/spi/spi-img-spfi.c:			ret = gpio_direction_output(spi->cs_gpio, mode);
drivers/spi/spi-img-spfi.c:				dev_err(&spi->dev, "chipselect gpio %d setup failed (%d)\n",
drivers/spi/spi-img-spfi.c:					spi->cs_gpio, ret);
drivers/spi/spi-img-spfi.c:			gpio_free(spi->cs_gpio);
drivers/spi/spi-img-spfi.c:	struct img_spfi *spfi = spi_master_get_devdata(spi->master);
drivers/spi/spi-img-spfi.c:	val = spfi_readl(spfi, SPFI_DEVICE_PARAMETER(spi->chip_select));
drivers/spi/spi-img-spfi.c:	spfi_writel(spfi, val, SPFI_DEVICE_PARAMETER(spi->chip_select));
drivers/spi/spi-img-spfi.c:	struct img_spfi *spfi = spi_master_get_devdata(spi->master);
drivers/spi/spi-sun6i.c:	return readl(sspi->base_addr + reg);
drivers/spi/spi-sun6i.c:	writel(value, sspi->base_addr + reg);
drivers/spi/spi-sun6i.c:		byte = readb(sspi->base_addr + SUN6I_RXDATA_REG);
drivers/spi/spi-sun6i.c:		if (sspi->rx_buf)
drivers/spi/spi-sun6i.c:			*sspi->rx_buf++ = byte;
drivers/spi/spi-sun6i.c:	cnt = sspi->fifo_depth - sun6i_spi_get_tx_fifo_count(sspi);
drivers/spi/spi-sun6i.c:	len = min3(len, (int)cnt, sspi->len);
drivers/spi/spi-sun6i.c:		byte = sspi->tx_buf ? *sspi->tx_buf++ : 0;
drivers/spi/spi-sun6i.c:		writeb(byte, sspi->base_addr + SUN6I_TXDATA_REG);
drivers/spi/spi-sun6i.c:		sspi->len--;
drivers/spi/spi-sun6i.c:	struct sun6i_spi *sspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-sun6i.c:	reg |= SUN6I_TFR_CTL_CS(spi->chip_select);
drivers/spi/spi-sun6i.c:	reinit_completion(&sspi->done);
drivers/spi/spi-sun6i.c:	sspi->tx_buf = tfr->tx_buf;
drivers/spi/spi-sun6i.c:	sspi->rx_buf = tfr->rx_buf;
drivers/spi/spi-sun6i.c:	sspi->len = tfr->len;
drivers/spi/spi-sun6i.c:	 * (See spi-sun4i.c)
drivers/spi/spi-sun6i.c:	trig_level = sspi->fifo_depth / 4 * 3;
drivers/spi/spi-sun6i.c:	if (spi->mode & SPI_CPOL)
drivers/spi/spi-sun6i.c:	if (spi->mode & SPI_CPHA)
drivers/spi/spi-sun6i.c:	if (spi->mode & SPI_LSB_FIRST)
drivers/spi/spi-sun6i.c:	if (sspi->rx_buf)
drivers/spi/spi-sun6i.c:	mclk_rate = clk_get_rate(sspi->mclk);
drivers/spi/spi-sun6i.c:		clk_set_rate(sspi->mclk, 2 * tfr->speed_hz);
drivers/spi/spi-sun6i.c:		mclk_rate = clk_get_rate(sspi->mclk);
drivers/spi/spi-sun6i.c:	if (sspi->tx_buf)
drivers/spi/spi-sun6i.c:	sun6i_spi_fill_fifo(sspi, sspi->fifo_depth);
drivers/spi/spi-sun6i.c:	if (tx_len > sspi->fifo_depth)
drivers/spi/spi-sun6i.c:	timeout = wait_for_completion_timeout(&sspi->done,
drivers/spi/spi-sun6i.c:			 dev_name(&spi->dev), tfr->len, tfr->speed_hz,
drivers/spi/spi-sun6i.c:		sun6i_spi_drain_fifo(sspi, sspi->fifo_depth);
drivers/spi/spi-sun6i.c:		complete(&sspi->done);
drivers/spi/spi-sun6i.c:		if (!sspi->len)
drivers/spi/spi-sun6i.c:	ret = clk_prepare_enable(sspi->hclk);
drivers/spi/spi-sun6i.c:	ret = clk_prepare_enable(sspi->mclk);
drivers/spi/spi-sun6i.c:	ret = reset_control_deassert(sspi->rstc);
drivers/spi/spi-sun6i.c:	clk_disable_unprepare(sspi->mclk);
drivers/spi/spi-sun6i.c:	clk_disable_unprepare(sspi->hclk);
drivers/spi/spi-sun6i.c:	reset_control_assert(sspi->rstc);
drivers/spi/spi-sun6i.c:	clk_disable_unprepare(sspi->mclk);
drivers/spi/spi-sun6i.c:	clk_disable_unprepare(sspi->hclk);
drivers/spi/spi-sun6i.c:	sspi->base_addr = devm_ioremap_resource(&pdev->dev, res);
drivers/spi/spi-sun6i.c:	if (IS_ERR(sspi->base_addr)) {
drivers/spi/spi-sun6i.c:		ret = PTR_ERR(sspi->base_addr);
drivers/spi/spi-sun6i.c:	sspi->master = master;
drivers/spi/spi-sun6i.c:	sspi->fifo_depth = (unsigned long)of_device_get_match_data(&pdev->dev);
drivers/spi/spi-sun6i.c:	sspi->hclk = devm_clk_get(&pdev->dev, "ahb");
drivers/spi/spi-sun6i.c:	if (IS_ERR(sspi->hclk)) {
drivers/spi/spi-sun6i.c:		ret = PTR_ERR(sspi->hclk);
drivers/spi/spi-sun6i.c:	sspi->mclk = devm_clk_get(&pdev->dev, "mod");
drivers/spi/spi-sun6i.c:	if (IS_ERR(sspi->mclk)) {
drivers/spi/spi-sun6i.c:		ret = PTR_ERR(sspi->mclk);
drivers/spi/spi-sun6i.c:	init_completion(&sspi->done);
drivers/spi/spi-sun6i.c:	sspi->rstc = devm_reset_control_get_exclusive(&pdev->dev, NULL);
drivers/spi/spi-sun6i.c:	if (IS_ERR(sspi->rstc)) {
drivers/spi/spi-sun6i.c:		ret = PTR_ERR(sspi->rstc);
drivers/spi/spi-bcm53xx.c:#include "spi-bcm53xx.h"
drivers/spi/spi-bcm53xx.c:	return bcma_read32(b53spi->core, offset);
drivers/spi/spi-bcm53xx.c:	bcma_write32(b53spi->core, offset, value);
drivers/spi/spi-bcm53xx.c:	struct device *dev = &b53spi->core->dev;
drivers/spi/spi-bcm53xx.c:	if (!b53spi->bspi)
drivers/spi/spi-bcm53xx.c:			b53spi->bspi = false;
drivers/spi/spi-bcm53xx.c:	if (b53spi->bspi)
drivers/spi/spi-bcm53xx.c:	b53spi->bspi = true;
drivers/spi/spi-bcm53xx.c:	struct bcm53xxspi *b53spi = spi_master_get_devdata(spi->master);
drivers/spi/spi-bcm53xx.c:	memcpy_fromio(msg->buf, b53spi->mmio_base + msg->from, msg->len);
drivers/spi/spi-bcm53xx.c:	b53spi->master = master;
drivers/spi/spi-bcm53xx.c:	b53spi->core = core;
drivers/spi/spi-bcm53xx.c:		b53spi->mmio_base = devm_ioremap(dev, core->addr_s[0],
drivers/spi/spi-bcm53xx.c:	b53spi->bspi = true;
drivers/spi/spi-bcm53xx.c:	if (b53spi->mmio_base)
drivers/spi/spi-omap2-mcspi.c:#include <linux/platform_data/spi-omap2-mcspi.h>
drivers/spi/spi-omap2-mcspi.c:	writel_relaxed(val, mcspi->base + idx);
drivers/spi/spi-omap2-mcspi.c:	return readl_relaxed(mcspi->base + idx);
drivers/spi/spi-omap2-mcspi.c:	struct omap2_mcspi_cs	*cs = spi->controller_state;
drivers/spi/spi-omap2-mcspi.c:	struct omap2_mcspi_cs	*cs = spi->controller_state;
drivers/spi/spi-omap2-mcspi.c:	struct omap2_mcspi_cs *cs = spi->controller_state;
drivers/spi/spi-omap2-mcspi.c:	struct omap2_mcspi_cs *cs = spi->controller_state;
drivers/spi/spi-omap2-mcspi.c:	struct omap2_mcspi_cs *cs = spi->controller_state;
drivers/spi/spi-omap2-mcspi.c:	struct omap2_mcspi *mcspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-omap2-mcspi.c:	if (spi->mode & SPI_CS_HIGH)
drivers/spi/spi-omap2-mcspi.c:	if (spi->controller_state) {
drivers/spi/spi-omap2-mcspi.c:		int err = pm_runtime_get_sync(mcspi->dev);
drivers/spi/spi-omap2-mcspi.c:			dev_err(mcspi->dev, "failed to get sync: %d\n", err);
drivers/spi/spi-omap2-mcspi.c:		pm_runtime_mark_last_busy(mcspi->dev);
drivers/spi/spi-omap2-mcspi.c:		pm_runtime_put_autosuspend(mcspi->dev);
drivers/spi/spi-omap2-mcspi.c:	struct omap2_mcspi_regs	*ctx = &mcspi->ctx;
drivers/spi/spi-omap2-mcspi.c:	struct spi_master *master = spi->master;
drivers/spi/spi-omap2-mcspi.c:	struct omap2_mcspi_cs *cs = spi->controller_state;
drivers/spi/spi-omap2-mcspi.c:		mcspi->fifo_depth = fifo_depth;
drivers/spi/spi-omap2-mcspi.c:	mcspi->fifo_depth = 0;
drivers/spi/spi-omap2-mcspi.c:	struct spi_master	*spi_cntrl = mcspi->master;
drivers/spi/spi-omap2-mcspi.c:	struct omap2_mcspi_regs	*ctx = &mcspi->ctx;
drivers/spi/spi-omap2-mcspi.c:	struct omap2_mcspi *mcspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-omap2-mcspi.c:	struct omap2_mcspi_dma *mcspi_dma = &mcspi->dma_channels[spi->chip_select];
drivers/spi/spi-omap2-mcspi.c:	struct omap2_mcspi *mcspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-omap2-mcspi.c:	struct omap2_mcspi_dma *mcspi_dma = &mcspi->dma_channels[spi->chip_select];
drivers/spi/spi-omap2-mcspi.c:	mcspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-omap2-mcspi.c:	mcspi_dma = &mcspi->dma_channels[spi->chip_select];
drivers/spi/spi-omap2-mcspi.c:	struct omap2_mcspi_cs	*cs = spi->controller_state;
drivers/spi/spi-omap2-mcspi.c:	mcspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-omap2-mcspi.c:	mcspi_dma = &mcspi->dma_channels[spi->chip_select];
drivers/spi/spi-omap2-mcspi.c:	if (mcspi->fifo_depth == 0)
drivers/spi/spi-omap2-mcspi.c:		if ((l & OMAP2_MCSPI_CHCONF_TURBO) && mcspi->fifo_depth == 0)
drivers/spi/spi-omap2-mcspi.c:			dev_err(&spi->dev, "sg_split failed\n");
drivers/spi/spi-omap2-mcspi.c:	if (mcspi->fifo_depth > 0)
drivers/spi/spi-omap2-mcspi.c:			dev_err(&spi->dev, "DMA RX penultimate word empty\n");
drivers/spi/spi-omap2-mcspi.c:		dev_err(&spi->dev, "DMA RX last word empty\n");
drivers/spi/spi-omap2-mcspi.c:	struct omap2_mcspi_cs	*cs = spi->controller_state;
drivers/spi/spi-omap2-mcspi.c:	mcspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-omap2-mcspi.c:	mcspi_dma = &mcspi->dma_channels[spi->chip_select];
drivers/spi/spi-omap2-mcspi.c:	if (mcspi->fifo_depth > 0) {
drivers/spi/spi-omap2-mcspi.c:		if (count > mcspi->fifo_depth)
drivers/spi/spi-omap2-mcspi.c:			burst = mcspi->fifo_depth / es;
drivers/spi/spi-omap2-mcspi.c:		if (mcspi->fifo_depth > 0) {
drivers/spi/spi-omap2-mcspi.c:			irqstat_reg = mcspi->base + OMAP2_MCSPI_IRQSTATUS;
drivers/spi/spi-omap2-mcspi.c:				dev_err(&spi->dev, "EOW timed out\n");
drivers/spi/spi-omap2-mcspi.c:			mcspi_write_reg(mcspi->master, OMAP2_MCSPI_IRQSTATUS,
drivers/spi/spi-omap2-mcspi.c:			if (mcspi->fifo_depth > 0) {
drivers/spi/spi-omap2-mcspi.c:					dev_err(&spi->dev, "TXFFE timed out\n");
drivers/spi/spi-omap2-mcspi.c:					dev_err(&spi->dev, "TXS timed out\n");
drivers/spi/spi-omap2-mcspi.c:				dev_err(&spi->dev, "EOT timed out\n");
drivers/spi/spi-omap2-mcspi.c:	struct omap2_mcspi_cs	*cs = spi->controller_state;
drivers/spi/spi-omap2-mcspi.c:	mcspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-omap2-mcspi.c:					dev_err(&spi->dev, "TXS timed out\n");
drivers/spi/spi-omap2-mcspi.c:				dev_vdbg(&spi->dev, "write-%d %02x\n",
drivers/spi/spi-omap2-mcspi.c:					dev_err(&spi->dev, "RXS timed out\n");
drivers/spi/spi-omap2-mcspi.c:					dev_vdbg(&spi->dev, "read-%d %02x\n",
drivers/spi/spi-omap2-mcspi.c:						dev_err(&spi->dev,
drivers/spi/spi-omap2-mcspi.c:				dev_vdbg(&spi->dev, "read-%d %02x\n",
drivers/spi/spi-omap2-mcspi.c:					dev_err(&spi->dev, "TXS timed out\n");
drivers/spi/spi-omap2-mcspi.c:				dev_vdbg(&spi->dev, "write-%d %04x\n",
drivers/spi/spi-omap2-mcspi.c:					dev_err(&spi->dev, "RXS timed out\n");
drivers/spi/spi-omap2-mcspi.c:					dev_vdbg(&spi->dev, "read-%d %04x\n",
drivers/spi/spi-omap2-mcspi.c:						dev_err(&spi->dev,
drivers/spi/spi-omap2-mcspi.c:				dev_vdbg(&spi->dev, "read-%d %04x\n",
drivers/spi/spi-omap2-mcspi.c:					dev_err(&spi->dev, "TXS timed out\n");
drivers/spi/spi-omap2-mcspi.c:				dev_vdbg(&spi->dev, "write-%d %08x\n",
drivers/spi/spi-omap2-mcspi.c:					dev_err(&spi->dev, "RXS timed out\n");
drivers/spi/spi-omap2-mcspi.c:					dev_vdbg(&spi->dev, "read-%d %08x\n",
drivers/spi/spi-omap2-mcspi.c:						dev_err(&spi->dev,
drivers/spi/spi-omap2-mcspi.c:				dev_vdbg(&spi->dev, "read-%d %08x\n",
drivers/spi/spi-omap2-mcspi.c:			dev_err(&spi->dev, "TXS timed out\n");
drivers/spi/spi-omap2-mcspi.c:			dev_err(&spi->dev, "EOT timed out\n");
drivers/spi/spi-omap2-mcspi.c:	struct omap2_mcspi_cs *cs = spi->controller_state;
drivers/spi/spi-omap2-mcspi.c:	u8 word_len = spi->bits_per_word;
drivers/spi/spi-omap2-mcspi.c:	u32 speed_hz = spi->max_speed_hz;
drivers/spi/spi-omap2-mcspi.c:	mcspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-omap2-mcspi.c:	spi_cntrl = mcspi->master;
drivers/spi/spi-omap2-mcspi.c:	if (mcspi->pin_dir == MCSPI_PINDIR_D0_IN_D1_OUT) {
drivers/spi/spi-omap2-mcspi.c:	if (!(spi->mode & SPI_CS_HIGH))
drivers/spi/spi-omap2-mcspi.c:	if (spi->mode & SPI_CPOL)
drivers/spi/spi-omap2-mcspi.c:	if (spi->mode & SPI_CPHA)
drivers/spi/spi-omap2-mcspi.c:	cs->mode = spi->mode;
drivers/spi/spi-omap2-mcspi.c:	dev_dbg(&spi->dev, "setup: speed %d, sample %s edge, clk %s\n",
drivers/spi/spi-omap2-mcspi.c:			(spi->mode & SPI_CPHA) ? "trailing" : "leading",
drivers/spi/spi-omap2-mcspi.c:			(spi->mode & SPI_CPOL) ? "inverted" : "normal");
drivers/spi/spi-omap2-mcspi.c:	struct spi_master	*master = spi->master;
drivers/spi/spi-omap2-mcspi.c:	mcspi_dma = mcspi->dma_channels + spi->chip_select;
drivers/spi/spi-omap2-mcspi.c:	struct omap2_mcspi	*mcspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-omap2-mcspi.c:	struct omap2_mcspi_regs	*ctx = &mcspi->ctx;
drivers/spi/spi-omap2-mcspi.c:	struct omap2_mcspi_cs	*cs = spi->controller_state;
drivers/spi/spi-omap2-mcspi.c:	mcspi_dma = &mcspi->dma_channels[spi->chip_select];
drivers/spi/spi-omap2-mcspi.c:		cs->base = mcspi->base + spi->chip_select * 0x14;
drivers/spi/spi-omap2-mcspi.c:		cs->phys = mcspi->phys + spi->chip_select * 0x14;
drivers/spi/spi-omap2-mcspi.c:		spi->controller_state = cs;
drivers/spi/spi-omap2-mcspi.c:		if (gpio_is_valid(spi->cs_gpio)) {
drivers/spi/spi-omap2-mcspi.c:			ret = gpio_request(spi->cs_gpio, dev_name(&spi->dev));
drivers/spi/spi-omap2-mcspi.c:				dev_err(&spi->dev, "failed to request gpio\n");
drivers/spi/spi-omap2-mcspi.c:			gpio_direction_output(spi->cs_gpio,
drivers/spi/spi-omap2-mcspi.c:					 !(spi->mode & SPI_CS_HIGH));
drivers/spi/spi-omap2-mcspi.c:			dev_warn(&spi->dev, "not using DMA for McSPI (%d)\n",
drivers/spi/spi-omap2-mcspi.c:	ret = pm_runtime_get_sync(mcspi->dev);
drivers/spi/spi-omap2-mcspi.c:	pm_runtime_mark_last_busy(mcspi->dev);
drivers/spi/spi-omap2-mcspi.c:	pm_runtime_put_autosuspend(mcspi->dev);
drivers/spi/spi-omap2-mcspi.c:	mcspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-omap2-mcspi.c:	if (spi->controller_state) {
drivers/spi/spi-omap2-mcspi.c:		cs = spi->controller_state;
drivers/spi/spi-omap2-mcspi.c:	if (spi->chip_select < spi->master->num_chipselect) {
drivers/spi/spi-omap2-mcspi.c:		mcspi_dma = &mcspi->dma_channels[spi->chip_select];
drivers/spi/spi-omap2-mcspi.c:	if (gpio_is_valid(spi->cs_gpio))
drivers/spi/spi-omap2-mcspi.c:		gpio_free(spi->cs_gpio);
drivers/spi/spi-omap2-mcspi.c:	mcspi_dma = mcspi->dma_channels + spi->chip_select;
drivers/spi/spi-omap2-mcspi.c:	cs = spi->controller_state;
drivers/spi/spi-omap2-mcspi.c:	cd = spi->controller_data;
drivers/spi/spi-omap2-mcspi.c:	 * The slave driver could have changed spi->mode in which case
drivers/spi/spi-omap2-mcspi.c:	if (spi->mode != cs->mode)
drivers/spi/spi-omap2-mcspi.c:	if (gpio_is_valid(spi->cs_gpio))
drivers/spi/spi-omap2-mcspi.c:		omap2_mcspi_set_cs(spi, spi->mode & SPI_CS_HIGH);
drivers/spi/spi-omap2-mcspi.c:	    (t->speed_hz != spi->max_speed_hz) ||
drivers/spi/spi-omap2-mcspi.c:	    (t->bits_per_word != spi->bits_per_word)) {
drivers/spi/spi-omap2-mcspi.c:		if (t->speed_hz == spi->max_speed_hz &&
drivers/spi/spi-omap2-mcspi.c:		    t->bits_per_word == spi->bits_per_word)
drivers/spi/spi-omap2-mcspi.c:		chconf = mcspi->ctx.modulctrl;
drivers/spi/spi-omap2-mcspi.c:		mcspi->ctx.modulctrl =
drivers/spi/spi-omap2-mcspi.c:	if (mcspi->fifo_depth > 0)
drivers/spi/spi-omap2-mcspi.c:		chconf = mcspi->ctx.modulctrl;
drivers/spi/spi-omap2-mcspi.c:		mcspi->ctx.modulctrl =
drivers/spi/spi-omap2-mcspi.c:	if (gpio_is_valid(spi->cs_gpio))
drivers/spi/spi-omap2-mcspi.c:		omap2_mcspi_set_cs(spi, !(spi->mode & SPI_CS_HIGH));
drivers/spi/spi-omap2-mcspi.c:	if (mcspi->fifo_depth > 0 && t)
drivers/spi/spi-omap2-mcspi.c:	struct omap2_mcspi_regs	*ctx = &mcspi->ctx;
drivers/spi/spi-omap2-mcspi.c:		if (msg->spi->controller_state == cs)
drivers/spi/spi-omap2-mcspi.c:	struct spi_master	*master = mcspi->master;
drivers/spi/spi-omap2-mcspi.c:	struct omap2_mcspi_regs	*ctx = &mcspi->ctx;
drivers/spi/spi-omap2-mcspi.c:	ret = pm_runtime_get_sync(mcspi->dev);
drivers/spi/spi-omap2-mcspi.c:	pm_runtime_mark_last_busy(mcspi->dev);
drivers/spi/spi-omap2-mcspi.c:	pm_runtime_put_autosuspend(mcspi->dev);
drivers/spi/spi-omap2-mcspi.c:	/* the spi->mode bits understood by this driver: */
drivers/spi/spi-omap2-mcspi.c:	mcspi->master = master;
drivers/spi/spi-omap2-mcspi.c:		of_property_read_u32(node, "ti,spi-num-cs", &num_cs);
drivers/spi/spi-omap2-mcspi.c:			mcspi->pin_dir = MCSPI_PINDIR_D0_OUT_D1_IN;
drivers/spi/spi-omap2-mcspi.c:		mcspi->pin_dir = pdata->pin_dir;
drivers/spi/spi-omap2-mcspi.c:	mcspi->base = devm_ioremap_resource(&pdev->dev, r);
drivers/spi/spi-omap2-mcspi.c:	if (IS_ERR(mcspi->base)) {
drivers/spi/spi-omap2-mcspi.c:		status = PTR_ERR(mcspi->base);
drivers/spi/spi-omap2-mcspi.c:	mcspi->phys = r->start + regs_offset;
drivers/spi/spi-omap2-mcspi.c:	mcspi->base += regs_offset;
drivers/spi/spi-omap2-mcspi.c:	mcspi->dev = &pdev->dev;
drivers/spi/spi-omap2-mcspi.c:	INIT_LIST_HEAD(&mcspi->ctx.cs);
drivers/spi/spi-omap2-mcspi.c:	mcspi->dma_channels = devm_kcalloc(&pdev->dev, master->num_chipselect,
drivers/spi/spi-omap2-mcspi.c:	if (mcspi->dma_channels == NULL) {
drivers/spi/spi-omap2-mcspi.c:		sprintf(mcspi->dma_channels[i].dma_rx_ch_name, "rx%d", i);
drivers/spi/spi-omap2-mcspi.c:		sprintf(mcspi->dma_channels[i].dma_tx_ch_name, "tx%d", i);
drivers/spi/spi-omap2-mcspi.c:	pm_runtime_dont_use_autosuspend(mcspi->dev);
drivers/spi/spi-omap2-mcspi.c:	pm_runtime_put_sync(mcspi->dev);
drivers/spi/spi-omap2-mcspi.c:	struct omap2_mcspi_regs	*ctx = &mcspi->ctx;
drivers/spi/spi-omap2-mcspi.c:	pm_runtime_get_sync(mcspi->dev);
drivers/spi/spi-omap2-mcspi.c:	pm_runtime_mark_last_busy(mcspi->dev);
drivers/spi/spi-omap2-mcspi.c:	pm_runtime_put_autosuspend(mcspi->dev);
drivers/spi/spi-lantiq-ssc.c:	return __raw_readl(spi->regbase + reg);
drivers/spi/spi-lantiq-ssc.c:	__raw_writel(val, spi->regbase + reg);
drivers/spi/spi-lantiq-ssc.c:	u32 val = __raw_readl(spi->regbase + reg);
drivers/spi/spi-lantiq-ssc.c:	__raw_writel(val, spi->regbase + reg);
drivers/spi/spi-lantiq-ssc.c:	return spi->tx_fifo_size - tx_fifo_level(spi);
drivers/spi/spi-lantiq-ssc.c:	u32 val = spi->rx_fifo_size << LTQ_SPI_RXFCON_RXFITL_S;
drivers/spi/spi-lantiq-ssc.c:	spi_clk = clk_get_rate(spi->fpi_clk) / 2;
drivers/spi/spi-lantiq-ssc.c:	dev_dbg(spi->dev, "spi_clk %u, max_speed_hz %u, brt %u\n",
drivers/spi/spi-lantiq-ssc.c:	const struct lantiq_ssc_hwcfg *hwcfg = spi->hwcfg;
drivers/spi/spi-lantiq-ssc.c:	hw_setup_bits_per_word(spi, spi->bits_per_word);
drivers/spi/spi-lantiq-ssc.c:	dev_dbg(spi->dev, "using internal chipselect %u\n", cs);
drivers/spi/spi-lantiq-ssc.c:	if (cs < spi->base_cs) {
drivers/spi/spi-lantiq-ssc.c:		dev_err(spi->dev,
drivers/spi/spi-lantiq-ssc.c:			"chipselect %i too small (min %i)\n", cs, spi->base_cs);
drivers/spi/spi-lantiq-ssc.c:	gpocon = 1 << ((cs - spi->base_cs) + LTQ_SPI_GPOCON_ISCSBN_S);
drivers/spi/spi-lantiq-ssc.c:		gpocon |= 1 << (cs - spi->base_cs);
drivers/spi/spi-lantiq-ssc.c:	hw_setup_clock_mode(spi, message->spi->mode);
drivers/spi/spi-lantiq-ssc.c:	if (bits_per_word != spi->bits_per_word ||
drivers/spi/spi-lantiq-ssc.c:		speed_hz != spi->speed_hz) {
drivers/spi/spi-lantiq-ssc.c:		spi->speed_hz = speed_hz;
drivers/spi/spi-lantiq-ssc.c:		spi->bits_per_word = bits_per_word;
drivers/spi/spi-lantiq-ssc.c:	flush_workqueue(spi->wq);
drivers/spi/spi-lantiq-ssc.c:	while (spi->tx_todo && tx_free) {
drivers/spi/spi-lantiq-ssc.c:		switch (spi->bits_per_word) {
drivers/spi/spi-lantiq-ssc.c:			tx8 = spi->tx;
drivers/spi/spi-lantiq-ssc.c:			spi->tx_todo--;
drivers/spi/spi-lantiq-ssc.c:			spi->tx++;
drivers/spi/spi-lantiq-ssc.c:			tx16 = (u16 *) spi->tx;
drivers/spi/spi-lantiq-ssc.c:			spi->tx_todo -= 2;
drivers/spi/spi-lantiq-ssc.c:			spi->tx += 2;
drivers/spi/spi-lantiq-ssc.c:			tx32 = (u32 *) spi->tx;
drivers/spi/spi-lantiq-ssc.c:			spi->tx_todo -= 4;
drivers/spi/spi-lantiq-ssc.c:			spi->tx += 4;
drivers/spi/spi-lantiq-ssc.c:		switch (spi->bits_per_word) {
drivers/spi/spi-lantiq-ssc.c:			rx8 = spi->rx;
drivers/spi/spi-lantiq-ssc.c:			spi->rx_todo--;
drivers/spi/spi-lantiq-ssc.c:			spi->rx++;
drivers/spi/spi-lantiq-ssc.c:			rx16 = (u16 *) spi->rx;
drivers/spi/spi-lantiq-ssc.c:			spi->rx_todo -= 2;
drivers/spi/spi-lantiq-ssc.c:			spi->rx += 2;
drivers/spi/spi-lantiq-ssc.c:			rx32 = (u32 *) spi->rx;
drivers/spi/spi-lantiq-ssc.c:			spi->rx_todo -= 4;
drivers/spi/spi-lantiq-ssc.c:			spi->rx += 4;
drivers/spi/spi-lantiq-ssc.c:		if (spi->rx_todo < 4)  {
drivers/spi/spi-lantiq-ssc.c:			rx8 = spi->rx;
drivers/spi/spi-lantiq-ssc.c:				spi->rx_todo--;
drivers/spi/spi-lantiq-ssc.c:				spi->rx++;
drivers/spi/spi-lantiq-ssc.c:			rx32 = (u32 *) spi->rx;
drivers/spi/spi-lantiq-ssc.c:			spi->rx_todo -= 4;
drivers/spi/spi-lantiq-ssc.c:			spi->rx += 4;
drivers/spi/spi-lantiq-ssc.c:	rxreq = spi->rx_todo;
drivers/spi/spi-lantiq-ssc.c:	rxreq_max = spi->rx_fifo_size * 4;
drivers/spi/spi-lantiq-ssc.c:	if (spi->tx) {
drivers/spi/spi-lantiq-ssc.c:		if (spi->rx && spi->rx_todo)
drivers/spi/spi-lantiq-ssc.c:		if (spi->tx_todo)
drivers/spi/spi-lantiq-ssc.c:	} else if (spi->rx) {
drivers/spi/spi-lantiq-ssc.c:		if (spi->rx_todo) {
drivers/spi/spi-lantiq-ssc.c:			if (spi->rx_todo)
drivers/spi/spi-lantiq-ssc.c:	queue_work(spi->wq, &spi->work);
drivers/spi/spi-lantiq-ssc.c:		dev_err(spi->dev, "receive underflow error\n");
drivers/spi/spi-lantiq-ssc.c:		dev_err(spi->dev, "transmit underflow error\n");
drivers/spi/spi-lantiq-ssc.c:		dev_err(spi->dev, "abort error\n");
drivers/spi/spi-lantiq-ssc.c:		dev_err(spi->dev, "receive overflow error\n");
drivers/spi/spi-lantiq-ssc.c:		dev_err(spi->dev, "transmit overflow error\n");
drivers/spi/spi-lantiq-ssc.c:		dev_err(spi->dev, "mode error\n");
drivers/spi/spi-lantiq-ssc.c:	if (spi->master->cur_msg)
drivers/spi/spi-lantiq-ssc.c:		spi->master->cur_msg->status = -EIO;
drivers/spi/spi-lantiq-ssc.c:	queue_work(spi->wq, &spi->work);
drivers/spi/spi-lantiq-ssc.c:	spin_lock_irqsave(&spi->lock, flags);
drivers/spi/spi-lantiq-ssc.c:	spi->tx = t->tx_buf;
drivers/spi/spi-lantiq-ssc.c:	spi->rx = t->rx_buf;
drivers/spi/spi-lantiq-ssc.c:		spi->tx_todo = t->len;
drivers/spi/spi-lantiq-ssc.c:	if (spi->rx) {
drivers/spi/spi-lantiq-ssc.c:		spi->rx_todo = t->len;
drivers/spi/spi-lantiq-ssc.c:		if (!spi->tx)
drivers/spi/spi-lantiq-ssc.c:	spin_unlock_irqrestore(&spi->lock, flags);
drivers/spi/spi-lantiq-ssc.c:	do_div(timeout, spi->speed_hz);
drivers/spi/spi-lantiq-ssc.c:			spi_finalize_current_transfer(spi->master);
drivers/spi/spi-lantiq-ssc.c:	if (spi->master->cur_msg)
drivers/spi/spi-lantiq-ssc.c:		spi->master->cur_msg->status = -EIO;
drivers/spi/spi-lantiq-ssc.c:	spi_finalize_current_transfer(spi->master);
drivers/spi/spi-lantiq-ssc.c:		fgpo = (1 << (cs - spi->base_cs));
drivers/spi/spi-lantiq-ssc.c:		fgpo = (1 << (cs - spi->base_cs + LTQ_SPI_FGPO_SETOUTN_S));
drivers/spi/spi-lantiq-ssc.c:	spi->master = master;
drivers/spi/spi-lantiq-ssc.c:	spi->dev = dev;
drivers/spi/spi-lantiq-ssc.c:	spi->hwcfg = hwcfg;
drivers/spi/spi-lantiq-ssc.c:	spi->regbase = devm_ioremap_resource(dev, res);
drivers/spi/spi-lantiq-ssc.c:	if (IS_ERR(spi->regbase)) {
drivers/spi/spi-lantiq-ssc.c:		err = PTR_ERR(spi->regbase);
drivers/spi/spi-lantiq-ssc.c:	spi->spi_clk = devm_clk_get(dev, "gate");
drivers/spi/spi-lantiq-ssc.c:	if (IS_ERR(spi->spi_clk)) {
drivers/spi/spi-lantiq-ssc.c:		err = PTR_ERR(spi->spi_clk);
drivers/spi/spi-lantiq-ssc.c:	err = clk_prepare_enable(spi->spi_clk);
drivers/spi/spi-lantiq-ssc.c:	spi->fpi_clk = clk_get_fpi();
drivers/spi/spi-lantiq-ssc.c:	spi->fpi_clk = clk_get(dev, "freq");
drivers/spi/spi-lantiq-ssc.c:	if (IS_ERR(spi->fpi_clk)) {
drivers/spi/spi-lantiq-ssc.c:		err = PTR_ERR(spi->fpi_clk);
drivers/spi/spi-lantiq-ssc.c:	spi->base_cs = 1;
drivers/spi/spi-lantiq-ssc.c:	of_property_read_u32(pdev->dev.of_node, "base-cs", &spi->base_cs);
drivers/spi/spi-lantiq-ssc.c:	spin_lock_init(&spi->lock);
drivers/spi/spi-lantiq-ssc.c:	spi->bits_per_word = 8;
drivers/spi/spi-lantiq-ssc.c:	spi->speed_hz = 0;
drivers/spi/spi-lantiq-ssc.c:	spi->wq = alloc_ordered_workqueue(dev_name(dev), 0);
drivers/spi/spi-lantiq-ssc.c:	if (!spi->wq) {
drivers/spi/spi-lantiq-ssc.c:	INIT_WORK(&spi->work, lantiq_ssc_bussy_work);
drivers/spi/spi-lantiq-ssc.c:	spi->tx_fifo_size = (id & LTQ_SPI_ID_TXFS_M) >> LTQ_SPI_ID_TXFS_S;
drivers/spi/spi-lantiq-ssc.c:	spi->rx_fifo_size = (id & LTQ_SPI_ID_RXFS_M) >> LTQ_SPI_ID_RXFS_S;
drivers/spi/spi-lantiq-ssc.c:		revision, spi->tx_fifo_size, spi->rx_fifo_size, supports_dma);
drivers/spi/spi-lantiq-ssc.c:	destroy_workqueue(spi->wq);
drivers/spi/spi-lantiq-ssc.c:	clk_put(spi->fpi_clk);
drivers/spi/spi-lantiq-ssc.c:	clk_disable_unprepare(spi->spi_clk);
drivers/spi/spi-lantiq-ssc.c:	destroy_workqueue(spi->wq);
drivers/spi/spi-lantiq-ssc.c:	clk_disable_unprepare(spi->spi_clk);
drivers/spi/spi-lantiq-ssc.c:	clk_put(spi->fpi_clk);
drivers/spi/spi-lantiq-ssc.c:		.name = "spi-lantiq-ssc",
drivers/spi/spi-lantiq-ssc.c:MODULE_ALIAS("platform:spi-lantiq-ssc");
drivers/spi/spi-stm32.c:	writel_relaxed(readl_relaxed(spi->base + offset) | bits,
drivers/spi/spi-stm32.c:		       spi->base + offset);
drivers/spi/spi-stm32.c:	writel_relaxed(readl_relaxed(spi->base + offset) & ~bits,
drivers/spi/spi-stm32.c:		       spi->base + offset);
drivers/spi/spi-stm32.c:	spin_lock_irqsave(&spi->lock, flags);
drivers/spi/spi-stm32.c:	while (readl_relaxed(spi->base + STM32_SPI_SR) & SPI_SR_TXP)
drivers/spi/spi-stm32.c:		writeb_relaxed(++count, spi->base + STM32_SPI_TXDR);
drivers/spi/spi-stm32.c:	spin_unlock_irqrestore(&spi->lock, flags);
drivers/spi/spi-stm32.c:	dev_dbg(spi->dev, "%d x 8-bit fifo size\n", count);
drivers/spi/spi-stm32.c:	spin_lock_irqsave(&spi->lock, flags);
drivers/spi/spi-stm32.c:	cfg1 = readl_relaxed(spi->base + STM32_SPI_CFG1);
drivers/spi/spi-stm32.c:	spin_unlock_irqrestore(&spi->lock, flags);
drivers/spi/spi-stm32.c:	dev_dbg(spi->dev, "%d-bit maximum data frame\n", max_bpw);
drivers/spi/spi-stm32.c:	div = DIV_ROUND_UP(spi->clk_rate, speed_hz);
drivers/spi/spi-stm32.c:	spi->cur_speed = spi->clk_rate / (1 << mbrdiv);
drivers/spi/spi-stm32.c:	half_fifo = (spi->fifo_size / 2);
drivers/spi/spi-stm32.c:	if (spi->cur_bpw <= 8)
drivers/spi/spi-stm32.c:	else if (spi->cur_bpw <= 16)
drivers/spi/spi-stm32.c:	if (spi->cur_bpw > 8)
drivers/spi/spi-stm32.c:	while ((spi->tx_len > 0) &&
drivers/spi/spi-stm32.c:	       (readl_relaxed(spi->base + STM32_SPI_SR) & SPI_SR_TXP)) {
drivers/spi/spi-stm32.c:		u32 offs = spi->cur_xferlen - spi->tx_len;
drivers/spi/spi-stm32.c:		if (spi->tx_len >= sizeof(u32)) {
drivers/spi/spi-stm32.c:			const u32 *tx_buf32 = (const u32 *)(spi->tx_buf + offs);
drivers/spi/spi-stm32.c:			writel_relaxed(*tx_buf32, spi->base + STM32_SPI_TXDR);
drivers/spi/spi-stm32.c:			spi->tx_len -= sizeof(u32);
drivers/spi/spi-stm32.c:		} else if (spi->tx_len >= sizeof(u16)) {
drivers/spi/spi-stm32.c:			const u16 *tx_buf16 = (const u16 *)(spi->tx_buf + offs);
drivers/spi/spi-stm32.c:			writew_relaxed(*tx_buf16, spi->base + STM32_SPI_TXDR);
drivers/spi/spi-stm32.c:			spi->tx_len -= sizeof(u16);
drivers/spi/spi-stm32.c:			const u8 *tx_buf8 = (const u8 *)(spi->tx_buf + offs);
drivers/spi/spi-stm32.c:			writeb_relaxed(*tx_buf8, spi->base + STM32_SPI_TXDR);
drivers/spi/spi-stm32.c:			spi->tx_len -= sizeof(u8);
drivers/spi/spi-stm32.c:	dev_dbg(spi->dev, "%s: %d bytes left\n", __func__, spi->tx_len);
drivers/spi/spi-stm32.c:	u32 sr = readl_relaxed(spi->base + STM32_SPI_SR);
drivers/spi/spi-stm32.c:	while ((spi->rx_len > 0) &&
drivers/spi/spi-stm32.c:		u32 offs = spi->cur_xferlen - spi->rx_len;
drivers/spi/spi-stm32.c:		if ((spi->rx_len >= sizeof(u32)) ||
drivers/spi/spi-stm32.c:			u32 *rx_buf32 = (u32 *)(spi->rx_buf + offs);
drivers/spi/spi-stm32.c:			*rx_buf32 = readl_relaxed(spi->base + STM32_SPI_RXDR);
drivers/spi/spi-stm32.c:			spi->rx_len -= sizeof(u32);
drivers/spi/spi-stm32.c:		} else if ((spi->rx_len >= sizeof(u16)) ||
drivers/spi/spi-stm32.c:			   (flush && (rxplvl >= 2 || spi->cur_bpw > 8))) {
drivers/spi/spi-stm32.c:			u16 *rx_buf16 = (u16 *)(spi->rx_buf + offs);
drivers/spi/spi-stm32.c:			*rx_buf16 = readw_relaxed(spi->base + STM32_SPI_RXDR);
drivers/spi/spi-stm32.c:			spi->rx_len -= sizeof(u16);
drivers/spi/spi-stm32.c:			u8 *rx_buf8 = (u8 *)(spi->rx_buf + offs);
drivers/spi/spi-stm32.c:			*rx_buf8 = readb_relaxed(spi->base + STM32_SPI_RXDR);
drivers/spi/spi-stm32.c:			spi->rx_len -= sizeof(u8);
drivers/spi/spi-stm32.c:		sr = readl_relaxed(spi->base + STM32_SPI_SR);
drivers/spi/spi-stm32.c:	dev_dbg(spi->dev, "%s%s: %d bytes left\n", __func__,
drivers/spi/spi-stm32.c:		flush ? "(flush)" : "", spi->rx_len);
drivers/spi/spi-stm32.c:	dev_dbg(spi->dev, "enable controller\n");
drivers/spi/spi-stm32.c:	dev_dbg(spi->dev, "disable controller\n");
drivers/spi/spi-stm32.c:	spin_lock_irqsave(&spi->lock, flags);
drivers/spi/spi-stm32.c:	cr1 = readl_relaxed(spi->base + STM32_SPI_CR1);
drivers/spi/spi-stm32.c:		spin_unlock_irqrestore(&spi->lock, flags);
drivers/spi/spi-stm32.c:	if (readl_relaxed_poll_timeout_atomic(spi->base + STM32_SPI_SR,
drivers/spi/spi-stm32.c:				       spi->base + STM32_SPI_CR1);
drivers/spi/spi-stm32.c:						spi->base + STM32_SPI_SR,
drivers/spi/spi-stm32.c:				dev_warn(spi->dev,
drivers/spi/spi-stm32.c:	if (!spi->cur_usedma && spi->rx_buf && (spi->rx_len > 0))
drivers/spi/spi-stm32.c:	if (spi->cur_usedma && spi->tx_buf)
drivers/spi/spi-stm32.c:		dmaengine_terminate_all(spi->dma_tx);
drivers/spi/spi-stm32.c:	if (spi->cur_usedma && spi->rx_buf)
drivers/spi/spi-stm32.c:		dmaengine_terminate_all(spi->dma_rx);
drivers/spi/spi-stm32.c:	writel_relaxed(0, spi->base + STM32_SPI_IER);
drivers/spi/spi-stm32.c:	writel_relaxed(SPI_IFCR_ALL, spi->base + STM32_SPI_IFCR);
drivers/spi/spi-stm32.c:	spin_unlock_irqrestore(&spi->lock, flags);
drivers/spi/spi-stm32.c:	dev_dbg(spi->dev, "%s: %s\n", __func__,
drivers/spi/spi-stm32.c:		(transfer->len > spi->fifo_size) ? "true" : "false");
drivers/spi/spi-stm32.c:	return (transfer->len > spi->fifo_size);
drivers/spi/spi-stm32.c:	spin_lock_irqsave(&spi->lock, flags);
drivers/spi/spi-stm32.c:	sr = readl_relaxed(spi->base + STM32_SPI_SR);
drivers/spi/spi-stm32.c:	ier = readl_relaxed(spi->base + STM32_SPI_IER);
drivers/spi/spi-stm32.c:	if (spi->rx_buf && !spi->cur_usedma)
drivers/spi/spi-stm32.c:		dev_dbg(spi->dev, "spurious IT (sr=0x%08x, ier=0x%08x)\n",
drivers/spi/spi-stm32.c:		spin_unlock_irqrestore(&spi->lock, flags);
drivers/spi/spi-stm32.c:		dev_warn(spi->dev, "Communication suspended\n");
drivers/spi/spi-stm32.c:		if (!spi->cur_usedma && (spi->rx_buf && (spi->rx_len > 0)))
drivers/spi/spi-stm32.c:		if (spi->cur_usedma)
drivers/spi/spi-stm32.c:		dev_warn(spi->dev, "Mode fault: transfer aborted\n");
drivers/spi/spi-stm32.c:		dev_warn(spi->dev, "Overrun: received value discarded\n");
drivers/spi/spi-stm32.c:		if (!spi->cur_usedma && (spi->rx_buf && (spi->rx_len > 0)))
drivers/spi/spi-stm32.c:		if (spi->cur_usedma)
drivers/spi/spi-stm32.c:		if (!spi->cur_usedma && (spi->rx_buf && (spi->rx_len > 0)))
drivers/spi/spi-stm32.c:		if (!spi->cur_usedma && (spi->tx_buf && (spi->tx_len > 0)))
drivers/spi/spi-stm32.c:		if (!spi->cur_usedma && (spi->rx_buf && (spi->rx_len > 0)))
drivers/spi/spi-stm32.c:	writel_relaxed(mask, spi->base + STM32_SPI_IFCR);
drivers/spi/spi-stm32.c:	spin_unlock_irqrestore(&spi->lock, flags);
drivers/spi/spi-stm32.c:	spi->cur_midi = 0;
drivers/spi/spi-stm32.c:	if (np && !of_property_read_u32(np, "st,spi-midi-ns", &spi->cur_midi))
drivers/spi/spi-stm32.c:		dev_dbg(spi->dev, "%dns inter-data idleness\n", spi->cur_midi);
drivers/spi/spi-stm32.c:	dev_dbg(spi->dev, "cpol=%d cpha=%d lsb_first=%d cs_high=%d\n",
drivers/spi/spi-stm32.c:	spin_lock_irqsave(&spi->lock, flags);
drivers/spi/spi-stm32.c:			(readl_relaxed(spi->base + STM32_SPI_CFG2) &
drivers/spi/spi-stm32.c:			       spi->base + STM32_SPI_CFG2);
drivers/spi/spi-stm32.c:	spin_unlock_irqrestore(&spi->lock, flags);
drivers/spi/spi-stm32.c:	spin_lock_irqsave(&spi->lock, flags);
drivers/spi/spi-stm32.c:	sr = readl_relaxed(spi->base + STM32_SPI_SR);
drivers/spi/spi-stm32.c:	spin_unlock_irqrestore(&spi->lock, flags);
drivers/spi/spi-stm32.c:		dev_warn(spi->dev, "DMA error (sr=0x%08x)\n", sr);
drivers/spi/spi-stm32.c:	if (spi->cur_bpw <= 8)
drivers/spi/spi-stm32.c:	else if (spi->cur_bpw <= 16)
drivers/spi/spi-stm32.c:	if (spi->cur_fthlv == 2)
drivers/spi/spi-stm32.c:		maxburst = spi->cur_fthlv;
drivers/spi/spi-stm32.c:		dma_conf->src_addr = spi->phys_addr + STM32_SPI_RXDR;
drivers/spi/spi-stm32.c:		dev_dbg(spi->dev, "Rx DMA config buswidth=%d, maxburst=%d\n",
drivers/spi/spi-stm32.c:		dma_conf->dst_addr = spi->phys_addr + STM32_SPI_TXDR;
drivers/spi/spi-stm32.c:		dev_dbg(spi->dev, "Tx DMA config buswidth=%d, maxburst=%d\n",
drivers/spi/spi-stm32.c:	if (spi->tx_buf && spi->rx_buf)	/* Full Duplex */
drivers/spi/spi-stm32.c:	else if (spi->tx_buf)		/* Half-Duplex TX dir or Simplex TX */
drivers/spi/spi-stm32.c:	else if (spi->rx_buf)		/* Half-Duplex RX dir or Simplex RX */
drivers/spi/spi-stm32.c:	spin_lock_irqsave(&spi->lock, flags);
drivers/spi/spi-stm32.c:	if (spi->tx_buf)
drivers/spi/spi-stm32.c:	writel_relaxed(ier, spi->base + STM32_SPI_IER);
drivers/spi/spi-stm32.c:	spin_unlock_irqrestore(&spi->lock, flags);
drivers/spi/spi-stm32.c:	spin_lock_irqsave(&spi->lock, flags);
drivers/spi/spi-stm32.c:	if (spi->rx_buf) {
drivers/spi/spi-stm32.c:		dmaengine_slave_config(spi->dma_rx, &rx_dma_conf);
drivers/spi/spi-stm32.c:					spi->dma_rx, xfer->rx_sg.sgl,
drivers/spi/spi-stm32.c:	if (spi->tx_buf) {
drivers/spi/spi-stm32.c:		dmaengine_slave_config(spi->dma_tx, &tx_dma_conf);
drivers/spi/spi-stm32.c:					spi->dma_tx, xfer->tx_sg.sgl,
drivers/spi/spi-stm32.c:	if ((spi->tx_buf && !tx_dma_desc) ||
drivers/spi/spi-stm32.c:	    (spi->rx_buf && !rx_dma_desc))
drivers/spi/spi-stm32.c:			dev_err(spi->dev, "Rx DMA submit failed\n");
drivers/spi/spi-stm32.c:		dma_async_issue_pending(spi->dma_rx);
drivers/spi/spi-stm32.c:		if (spi->cur_comm == SPI_SIMPLEX_TX) {
drivers/spi/spi-stm32.c:			dev_err(spi->dev, "Tx DMA submit failed\n");
drivers/spi/spi-stm32.c:		dma_async_issue_pending(spi->dma_tx);
drivers/spi/spi-stm32.c:	writel_relaxed(ier, spi->base + STM32_SPI_IER);
drivers/spi/spi-stm32.c:	spin_unlock_irqrestore(&spi->lock, flags);
drivers/spi/spi-stm32.c:	if (spi->rx_buf)
drivers/spi/spi-stm32.c:		dmaengine_terminate_all(spi->dma_rx);
drivers/spi/spi-stm32.c:	spin_unlock_irqrestore(&spi->lock, flags);
drivers/spi/spi-stm32.c:	dev_info(spi->dev, "DMA issue: fall back to irq transfer\n");
drivers/spi/spi-stm32.c:	spin_lock_irqsave(&spi->lock, flags);
drivers/spi/spi-stm32.c:	if (spi->cur_bpw != transfer->bits_per_word) {
drivers/spi/spi-stm32.c:		spi->cur_bpw = transfer->bits_per_word;
drivers/spi/spi-stm32.c:		bpw = spi->cur_bpw - 1;
drivers/spi/spi-stm32.c:		spi->cur_fthlv = stm32_spi_prepare_fthlv(spi);
drivers/spi/spi-stm32.c:		fthlv = spi->cur_fthlv - 1;
drivers/spi/spi-stm32.c:	if (spi->cur_speed != transfer->speed_hz) {
drivers/spi/spi-stm32.c:		/* Update spi->cur_speed with real clock speed */
drivers/spi/spi-stm32.c:		transfer->speed_hz = spi->cur_speed;
drivers/spi/spi-stm32.c:		writel_relaxed((readl_relaxed(spi->base + STM32_SPI_CFG1) &
drivers/spi/spi-stm32.c:			       spi->base + STM32_SPI_CFG1);
drivers/spi/spi-stm32.c:	if (spi->cur_comm != mode) {
drivers/spi/spi-stm32.c:		spi->cur_comm = mode;
drivers/spi/spi-stm32.c:	if ((transfer->len > 1) && (spi->cur_midi > 0)) {
drivers/spi/spi-stm32.c:		u32 sck_period_ns = DIV_ROUND_UP(SPI_1HZ_NS, spi->cur_speed);
drivers/spi/spi-stm32.c:		u32 midi = min((u32)DIV_ROUND_UP(spi->cur_midi, sck_period_ns),
drivers/spi/spi-stm32.c:		dev_dbg(spi->dev, "period=%dns, midi=%d(=%dns)\n",
drivers/spi/spi-stm32.c:		writel_relaxed((readl_relaxed(spi->base + STM32_SPI_CFG2) &
drivers/spi/spi-stm32.c:			       spi->base + STM32_SPI_CFG2);
drivers/spi/spi-stm32.c:	if (spi->cur_bpw <= 8)
drivers/spi/spi-stm32.c:	else if (spi->cur_bpw <= 16)
drivers/spi/spi-stm32.c:		writel_relaxed(nb_words, spi->base + STM32_SPI_CR2);
drivers/spi/spi-stm32.c:	spi->cur_xferlen = transfer->len;
drivers/spi/spi-stm32.c:	dev_dbg(spi->dev, "transfer communication mode set to %d\n",
drivers/spi/spi-stm32.c:		spi->cur_comm);
drivers/spi/spi-stm32.c:	dev_dbg(spi->dev,
drivers/spi/spi-stm32.c:		spi->cur_bpw, spi->cur_fthlv);
drivers/spi/spi-stm32.c:	dev_dbg(spi->dev, "speed set to %dHz\n", spi->cur_speed);
drivers/spi/spi-stm32.c:	dev_dbg(spi->dev, "transfer of %d bytes (%d data frames)\n",
drivers/spi/spi-stm32.c:		spi->cur_xferlen, nb_words);
drivers/spi/spi-stm32.c:	dev_dbg(spi->dev, "dma %s\n",
drivers/spi/spi-stm32.c:		(spi->cur_usedma) ? "enabled" : "disabled");
drivers/spi/spi-stm32.c:	spin_unlock_irqrestore(&spi->lock, flags);
drivers/spi/spi-stm32.c:	spi->tx_buf = transfer->tx_buf;
drivers/spi/spi-stm32.c:	spi->rx_buf = transfer->rx_buf;
drivers/spi/spi-stm32.c:	spi->tx_len = spi->tx_buf ? transfer->len : 0;
drivers/spi/spi-stm32.c:	spi->rx_len = spi->rx_buf ? transfer->len : 0;
drivers/spi/spi-stm32.c:	spi->cur_usedma = (master->can_dma &&
drivers/spi/spi-stm32.c:		dev_err(spi->dev, "SPI transfer setup failed\n");
drivers/spi/spi-stm32.c:	if (spi->cur_usedma)
drivers/spi/spi-stm32.c:	spin_lock_irqsave(&spi->lock, flags);
drivers/spi/spi-stm32.c:	spin_unlock_irqrestore(&spi->lock, flags);
drivers/spi/spi-stm32.c:	spi->dev = &pdev->dev;
drivers/spi/spi-stm32.c:	spi->master = master;
drivers/spi/spi-stm32.c:	spin_lock_init(&spi->lock);
drivers/spi/spi-stm32.c:	spi->base = devm_ioremap_resource(&pdev->dev, res);
drivers/spi/spi-stm32.c:	if (IS_ERR(spi->base)) {
drivers/spi/spi-stm32.c:		ret = PTR_ERR(spi->base);
drivers/spi/spi-stm32.c:	spi->phys_addr = (dma_addr_t)res->start;
drivers/spi/spi-stm32.c:	spi->irq = platform_get_irq(pdev, 0);
drivers/spi/spi-stm32.c:	if (spi->irq <= 0) {
drivers/spi/spi-stm32.c:		dev_err(&pdev->dev, "no irq: %d\n", spi->irq);
drivers/spi/spi-stm32.c:	ret = devm_request_threaded_irq(&pdev->dev, spi->irq, NULL,
drivers/spi/spi-stm32.c:		dev_err(&pdev->dev, "irq%d request failed: %d\n", spi->irq,
drivers/spi/spi-stm32.c:	spi->clk = devm_clk_get(&pdev->dev, 0);
drivers/spi/spi-stm32.c:	if (IS_ERR(spi->clk)) {
drivers/spi/spi-stm32.c:		ret = PTR_ERR(spi->clk);
drivers/spi/spi-stm32.c:	ret = clk_prepare_enable(spi->clk);
drivers/spi/spi-stm32.c:	spi->clk_rate = clk_get_rate(spi->clk);
drivers/spi/spi-stm32.c:	if (!spi->clk_rate) {
drivers/spi/spi-stm32.c:	spi->rst = devm_reset_control_get_exclusive(&pdev->dev, NULL);
drivers/spi/spi-stm32.c:	if (!IS_ERR(spi->rst)) {
drivers/spi/spi-stm32.c:		reset_control_assert(spi->rst);
drivers/spi/spi-stm32.c:		reset_control_deassert(spi->rst);
drivers/spi/spi-stm32.c:	spi->fifo_size = stm32_spi_get_fifo_size(spi);
drivers/spi/spi-stm32.c:	master->max_speed_hz = spi->clk_rate / SPI_MBR_DIV_MIN;
drivers/spi/spi-stm32.c:	master->min_speed_hz = spi->clk_rate / SPI_MBR_DIV_MAX;
drivers/spi/spi-stm32.c:	spi->dma_tx = dma_request_slave_channel(spi->dev, "tx");
drivers/spi/spi-stm32.c:	if (!spi->dma_tx)
drivers/spi/spi-stm32.c:		master->dma_tx = spi->dma_tx;
drivers/spi/spi-stm32.c:	spi->dma_rx = dma_request_slave_channel(spi->dev, "rx");
drivers/spi/spi-stm32.c:	if (!spi->dma_rx)
drivers/spi/spi-stm32.c:		master->dma_rx = spi->dma_rx;
drivers/spi/spi-stm32.c:	if (spi->dma_tx || spi->dma_rx)
drivers/spi/spi-stm32.c:	if (spi->dma_tx)
drivers/spi/spi-stm32.c:		dma_release_channel(spi->dma_tx);
drivers/spi/spi-stm32.c:	if (spi->dma_rx)
drivers/spi/spi-stm32.c:		dma_release_channel(spi->dma_rx);
drivers/spi/spi-stm32.c:	clk_disable_unprepare(spi->clk);
drivers/spi/spi-stm32.c:	clk_disable_unprepare(spi->clk);
drivers/spi/spi-stm32.c:	clk_disable_unprepare(spi->clk);
drivers/spi/spi-stm32.c:	return clk_prepare_enable(spi->clk);
drivers/spi/spi-stm32.c:		clk_disable_unprepare(spi->clk);
drivers/spi/spi-slave-system-control.c:		dev_info(&priv->spi->dev, "Rebooting system...\n");
drivers/spi/spi-slave-system-control.c:		dev_info(&priv->spi->dev, "Powering off system...\n");
drivers/spi/spi-slave-system-control.c:		dev_info(&priv->spi->dev, "Halting system...\n");
drivers/spi/spi-slave-system-control.c:		dev_info(&priv->spi->dev, "Suspending system...\n");
drivers/spi/spi-slave-system-control.c:		dev_warn(&priv->spi->dev, "Unknown command 0x%x\n", cmd);
drivers/spi/spi-slave-system-control.c:	dev_info(&priv->spi->dev, "Terminating\n");
drivers/spi/spi-slave-system-control.c:		dev_err(&priv->spi->dev, "spi_async() failed %d\n", ret);
drivers/spi/spi-slave-system-control.c:	priv = devm_kzalloc(&spi->dev, sizeof(*priv), GFP_KERNEL);
drivers/spi/spi-slave-system-control.c:		.name	= "spi-slave-system-control",
drivers/spi/spi-lp8841-rtc.c:	struct spi_lp8841_rtc *data = spi_master_get_devdata(spi->master);
drivers/spi/spi-lp8841-rtc.c:	if ((spi->mode & SPI_CS_HIGH) == 0) {
drivers/spi/spi-lp8841-rtc.c:		dev_err(&spi->dev, "unsupported active low chip select\n");
drivers/spi/spi-lp8841-rtc.c:	if ((spi->mode & SPI_LSB_FIRST) == 0) {
drivers/spi/spi-lp8841-rtc.c:		dev_err(&spi->dev, "unsupported MSB first mode\n");
drivers/spi/spi-lp8841-rtc.c:	if ((spi->mode & SPI_3WIRE) == 0) {
drivers/spi/spi-lp8841-rtc.c:		dev_err(&spi->dev, "unsupported wiring. 3 wires required\n");
drivers/spi/spi-lp8841-rtc.c:	{ .compatible = "icpdas,lp8841-spi-rtc" },
drivers/spi/spi-bfin-sport.c:	struct bfin_sport_spi_master_data *drv_data = spi_master_get_devdata(spi->master);
drivers/spi/spi-bfin-sport.c:	dev_dbg(&spi->dev, "adding an msg in transfer()\n");
drivers/spi/spi-bfin-sport.c:		chip_info = spi->controller_data;
drivers/spi/spi-bfin-sport.c:				dev_err(&spi->dev, "don't set ctl_reg/enable_dma fields\n");
drivers/spi/spi-bfin-sport.c:	if (spi->mode & SPI_CPHA)
drivers/spi/spi-bfin-sport.c:	if (spi->mode & SPI_LSB_FIRST)
drivers/spi/spi-bfin-sport.c:	chip->baud = bfin_sport_hz_to_spi_baud(spi->max_speed_hz);
drivers/spi/spi-bfin-sport.c:	chip->cs_gpio = spi->chip_select;
drivers/spi/spi-bfin-sport.c:	ret = gpio_request(chip->cs_gpio, spi->modalias);
drivers/spi/spi-bfin-sport.c:	dev_dbg(&spi->dev, "setup spi chip %s, width is %d\n",
drivers/spi/spi-bfin-sport.c:			spi->modalias, spi->bits_per_word);
drivers/spi/spi-bfin-sport.c:	dev_dbg(&spi->dev, "ctl_reg is 0x%x, GPIO is %i\n",
drivers/spi/spi-bfin-sport.c:			chip->ctl_reg, spi->chip_select);
drivers/spi/spi-imx.c:#include <linux/platform_data/spi-imx.h>
drivers/spi/spi-imx.c:	struct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);
drivers/spi/spi-imx.c:	if (spi->mode & SPI_READY)
drivers/spi/spi-imx.c:	ctrl |= MX51_ECSPI_CTRL_CS(spi->chip_select);
drivers/spi/spi-imx.c:		cfg &= ~MX51_ECSPI_CONFIG_SBBCTRL(spi->chip_select);
drivers/spi/spi-imx.c:		cfg |= MX51_ECSPI_CONFIG_SBBCTRL(spi->chip_select);
drivers/spi/spi-imx.c:	if (spi->mode & SPI_CPHA)
drivers/spi/spi-imx.c:		cfg |= MX51_ECSPI_CONFIG_SCLKPHA(spi->chip_select);
drivers/spi/spi-imx.c:		cfg &= ~MX51_ECSPI_CONFIG_SCLKPHA(spi->chip_select);
drivers/spi/spi-imx.c:	if (spi->mode & SPI_CPOL) {
drivers/spi/spi-imx.c:		cfg |= MX51_ECSPI_CONFIG_SCLKPOL(spi->chip_select);
drivers/spi/spi-imx.c:		cfg |= MX51_ECSPI_CONFIG_SCLKCTL(spi->chip_select);
drivers/spi/spi-imx.c:		cfg &= ~MX51_ECSPI_CONFIG_SCLKPOL(spi->chip_select);
drivers/spi/spi-imx.c:		cfg &= ~MX51_ECSPI_CONFIG_SCLKCTL(spi->chip_select);
drivers/spi/spi-imx.c:	if (spi->mode & SPI_CS_HIGH)
drivers/spi/spi-imx.c:		cfg |= MX51_ECSPI_CONFIG_SSBPOL(spi->chip_select);
drivers/spi/spi-imx.c:		cfg &= ~MX51_ECSPI_CONFIG_SSBPOL(spi->chip_select);
drivers/spi/spi-imx.c:	if (spi->mode & SPI_LOOP)
drivers/spi/spi-imx.c:	struct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);
drivers/spi/spi-imx.c:	if (spi->mode & SPI_CPHA)
drivers/spi/spi-imx.c:	if (spi->mode & SPI_CPOL)
drivers/spi/spi-imx.c:	if (spi->mode & SPI_CS_HIGH)
drivers/spi/spi-imx.c:	if (!gpio_is_valid(spi->cs_gpio))
drivers/spi/spi-imx.c:		reg |= (spi->chip_select) <<
drivers/spi/spi-imx.c:	if (spi->mode & SPI_LOOP)
drivers/spi/spi-imx.c:	struct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);
drivers/spi/spi-imx.c:	if (spi->mode & SPI_CPHA)
drivers/spi/spi-imx.c:	if (spi->mode & SPI_CPOL)
drivers/spi/spi-imx.c:	if (spi->mode & SPI_CS_HIGH)
drivers/spi/spi-imx.c:	if (!gpio_is_valid(spi->cs_gpio))
drivers/spi/spi-imx.c:		reg |= spi->chip_select << MX21_CSPICTRL_CS_SHIFT;
drivers/spi/spi-imx.c:	struct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);
drivers/spi/spi-imx.c:	if (spi->mode & SPI_CPHA)
drivers/spi/spi-imx.c:	if (spi->mode & SPI_CPOL)
drivers/spi/spi-imx.c:	int dev_is_lowactive = !(spi->mode & SPI_CS_HIGH);
drivers/spi/spi-imx.c:	if (spi->mode & SPI_NO_CS)
drivers/spi/spi-imx.c:	if (!gpio_is_valid(spi->cs_gpio))
drivers/spi/spi-imx.c:	gpio_set_value(spi->cs_gpio, dev_is_lowactive ^ active);
drivers/spi/spi-imx.c:	struct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);
drivers/spi/spi-imx.c:		ret = spi_imx_dma_configure(spi->master);
drivers/spi/spi-imx.c:	struct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);
drivers/spi/spi-imx.c:		dev_err(&spi->dev, "I/O Error in PIO\n");
drivers/spi/spi-imx.c:	struct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);
drivers/spi/spi-imx.c:		dev_err(&spi->dev, "Transaction too big, max size is %d bytes\n",
drivers/spi/spi-imx.c:		dev_dbg(&spi->dev, "interrupted\n");
drivers/spi/spi-imx.c:	struct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);
drivers/spi/spi-imx.c:	dev_dbg(&spi->dev, "%s: mode %d, %u bpw, %d hz\n", __func__,
drivers/spi/spi-imx.c:		 spi->mode, spi->bits_per_word, spi->max_speed_hz);
drivers/spi/spi-imx.c:	if (spi->mode & SPI_NO_CS)
drivers/spi/spi-imx.c:	if (gpio_is_valid(spi->cs_gpio))
drivers/spi/spi-imx.c:		gpio_direction_output(spi->cs_gpio,
drivers/spi/spi-imx.c:				      spi->mode & SPI_CS_HIGH ? 0 : 1);
drivers/spi/spi-imx.c:			of_property_read_bool(np, "spi-slave");
drivers/spi/spi-imx.c:	ret = of_property_read_u32(np, "fsl,spi-rdy-drctl", &spi_drctl);
drivers/spi/spi-pxa2xx-dma.c:#include "spi-pxa2xx.h"
drivers/spi/spi-pxa2xx-dma.c:	struct pxa2xx_spi_chip *chip_info = spi->controller_data;
drivers/spi/spi-xilinx.c:	if (!xspi->tx_ptr) {
drivers/spi/spi-xilinx.c:		xspi->write_fn(0, xspi->regs + XSPI_TXD_OFFSET);
drivers/spi/spi-xilinx.c:	switch (xspi->bytes_per_word) {
drivers/spi/spi-xilinx.c:		data = *(u8 *)(xspi->tx_ptr);
drivers/spi/spi-xilinx.c:		data = *(u16 *)(xspi->tx_ptr);
drivers/spi/spi-xilinx.c:		data = *(u32 *)(xspi->tx_ptr);
drivers/spi/spi-xilinx.c:	xspi->write_fn(data, xspi->regs + XSPI_TXD_OFFSET);
drivers/spi/spi-xilinx.c:	xspi->tx_ptr += xspi->bytes_per_word;
drivers/spi/spi-xilinx.c:	u32 data = xspi->read_fn(xspi->regs + XSPI_RXD_OFFSET);
drivers/spi/spi-xilinx.c:	if (!xspi->rx_ptr)
drivers/spi/spi-xilinx.c:	switch (xspi->bytes_per_word) {
drivers/spi/spi-xilinx.c:		*(u8 *)(xspi->rx_ptr) = data;
drivers/spi/spi-xilinx.c:		*(u16 *)(xspi->rx_ptr) = data;
drivers/spi/spi-xilinx.c:		*(u32 *)(xspi->rx_ptr) = data;
drivers/spi/spi-xilinx.c:	xspi->rx_ptr += xspi->bytes_per_word;
drivers/spi/spi-xilinx.c:	void __iomem *regs_base = xspi->regs;
drivers/spi/spi-xilinx.c:	xspi->write_fn(XIPIF_V123B_RESET_MASK,
drivers/spi/spi-xilinx.c:	xspi->write_fn(XSPI_INTR_TX_EMPTY,
drivers/spi/spi-xilinx.c:	xspi->write_fn(0, regs_base + XIPIF_V123B_DGIER_OFFSET);
drivers/spi/spi-xilinx.c:	xspi->write_fn(0xffff, regs_base + XSPI_SSR_OFFSET);
drivers/spi/spi-xilinx.c:	xspi->write_fn(XSPI_CR_MANUAL_SSELECT |	XSPI_CR_MASTER_MODE |
drivers/spi/spi-xilinx.c:	struct xilinx_spi *xspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-xilinx.c:		xspi->write_fn(xspi->cs_inactive, xspi->regs + XSPI_SSR_OFFSET);
drivers/spi/spi-xilinx.c:	cr = xspi->read_fn(xspi->regs + XSPI_CR_OFFSET)	& ~XSPI_CR_MODE_MASK;
drivers/spi/spi-xilinx.c:	if (spi->mode & SPI_CPHA)
drivers/spi/spi-xilinx.c:	if (spi->mode & SPI_CPOL)
drivers/spi/spi-xilinx.c:	if (spi->mode & SPI_LSB_FIRST)
drivers/spi/spi-xilinx.c:	if (spi->mode & SPI_LOOP)
drivers/spi/spi-xilinx.c:	xspi->write_fn(cr, xspi->regs + XSPI_CR_OFFSET);
drivers/spi/spi-xilinx.c:	/* We do not check spi->max_speed_hz here as the SPI clock
drivers/spi/spi-xilinx.c:	cs = xspi->cs_inactive;
drivers/spi/spi-xilinx.c:	cs ^= BIT(spi->chip_select);
drivers/spi/spi-xilinx.c:	xspi->write_fn(cs, xspi->regs + XSPI_SSR_OFFSET);
drivers/spi/spi-xilinx.c:	struct xilinx_spi *xspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-xilinx.c:	if (spi->mode & SPI_CS_HIGH)
drivers/spi/spi-xilinx.c:		xspi->cs_inactive &= ~BIT(spi->chip_select);
drivers/spi/spi-xilinx.c:		xspi->cs_inactive |= BIT(spi->chip_select);
drivers/spi/spi-xilinx.c:	struct xilinx_spi *xspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-xilinx.c:	xspi->tx_ptr = t->tx_buf;
drivers/spi/spi-xilinx.c:	xspi->rx_ptr = t->rx_buf;
drivers/spi/spi-xilinx.c:	remaining_words = t->len / xspi->bytes_per_word;
drivers/spi/spi-xilinx.c:	if (xspi->irq >= 0 &&  remaining_words > xspi->buffer_size) {
drivers/spi/spi-xilinx.c:		cr = xspi->read_fn(xspi->regs + XSPI_CR_OFFSET);
drivers/spi/spi-xilinx.c:		xspi->write_fn(cr | XSPI_CR_TRANS_INHIBIT,
drivers/spi/spi-xilinx.c:			       xspi->regs + XSPI_CR_OFFSET);
drivers/spi/spi-xilinx.c:		isr = xspi->read_fn(xspi->regs + XIPIF_V123B_IISR_OFFSET);
drivers/spi/spi-xilinx.c:			xspi->write_fn(isr,
drivers/spi/spi-xilinx.c:				       xspi->regs + XIPIF_V123B_IISR_OFFSET);
drivers/spi/spi-xilinx.c:		xspi->write_fn(XIPIF_V123B_GINTR_ENABLE,
drivers/spi/spi-xilinx.c:				xspi->regs + XIPIF_V123B_DGIER_OFFSET);
drivers/spi/spi-xilinx.c:		reinit_completion(&xspi->done);
drivers/spi/spi-xilinx.c:		n_words = min(remaining_words, xspi->buffer_size);
drivers/spi/spi-xilinx.c:			xspi->write_fn(cr, xspi->regs + XSPI_CR_OFFSET);
drivers/spi/spi-xilinx.c:			wait_for_completion(&xspi->done);
drivers/spi/spi-xilinx.c:			xspi->write_fn(cr | XSPI_CR_TRANS_INHIBIT,
drivers/spi/spi-xilinx.c:				       xspi->regs + XSPI_CR_OFFSET);
drivers/spi/spi-xilinx.c:			sr = xspi->read_fn(xspi->regs + XSPI_SR_OFFSET);
drivers/spi/spi-xilinx.c:				dev_err(&spi->dev,
drivers/spi/spi-xilinx.c:			sr = xspi->read_fn(xspi->regs + XSPI_SR_OFFSET);
drivers/spi/spi-xilinx.c:		xspi->write_fn(0, xspi->regs + XIPIF_V123B_DGIER_OFFSET);
drivers/spi/spi-xilinx.c:		xspi->write_fn(cr, xspi->regs + XSPI_CR_OFFSET);
drivers/spi/spi-xilinx.c:	ipif_isr = xspi->read_fn(xspi->regs + XIPIF_V123B_IISR_OFFSET);
drivers/spi/spi-xilinx.c:	xspi->write_fn(ipif_isr, xspi->regs + XIPIF_V123B_IISR_OFFSET);
drivers/spi/spi-xilinx.c:		complete(&xspi->done);
drivers/spi/spi-xilinx.c:	xspi->write_fn(XIPIF_V123B_RESET_MASK,
drivers/spi/spi-xilinx.c:		xspi->regs + XIPIF_V123B_RESETR_OFFSET);
drivers/spi/spi-xilinx.c:		xspi->write_fn(0, xspi->regs + XSPI_TXD_OFFSET);
drivers/spi/spi-xilinx.c:		sr = xspi->read_fn(xspi->regs + XSPI_SR_OFFSET);
drivers/spi/spi-xilinx.c:	{ .compatible = "xlnx,axi-quad-spi-1.00.a", },
drivers/spi/spi-xilinx.c:	{ .compatible = "xlnx,xps-spi-2.00.a", },
drivers/spi/spi-xilinx.c:	{ .compatible = "xlnx,xps-spi-2.00.b", },
drivers/spi/spi-xilinx.c:	/* the spi->mode bits understood by this driver: */
drivers/spi/spi-xilinx.c:	xspi->cs_inactive = 0xffffffff;
drivers/spi/spi-xilinx.c:	xspi->bitbang.master = master;
drivers/spi/spi-xilinx.c:	xspi->bitbang.chipselect = xilinx_spi_chipselect;
drivers/spi/spi-xilinx.c:	xspi->bitbang.setup_transfer = xilinx_spi_setup_transfer;
drivers/spi/spi-xilinx.c:	xspi->bitbang.txrx_bufs = xilinx_spi_txrx_bufs;
drivers/spi/spi-xilinx.c:	init_completion(&xspi->done);
drivers/spi/spi-xilinx.c:	xspi->regs = devm_ioremap_resource(&pdev->dev, res);
drivers/spi/spi-xilinx.c:	if (IS_ERR(xspi->regs)) {
drivers/spi/spi-xilinx.c:		ret = PTR_ERR(xspi->regs);
drivers/spi/spi-xilinx.c:	xspi->read_fn = xspi_read32;
drivers/spi/spi-xilinx.c:	xspi->write_fn = xspi_write32;
drivers/spi/spi-xilinx.c:	xspi->write_fn(XSPI_CR_LOOP, xspi->regs + XSPI_CR_OFFSET);
drivers/spi/spi-xilinx.c:	tmp = xspi->read_fn(xspi->regs + XSPI_CR_OFFSET);
drivers/spi/spi-xilinx.c:		xspi->read_fn = xspi_read32_be;
drivers/spi/spi-xilinx.c:		xspi->write_fn = xspi_write32_be;
drivers/spi/spi-xilinx.c:	xspi->bytes_per_word = bits_per_word / 8;
drivers/spi/spi-xilinx.c:	xspi->buffer_size = xilinx_spi_find_buffer_size(xspi);
drivers/spi/spi-xilinx.c:	xspi->irq = platform_get_irq(pdev, 0);
drivers/spi/spi-xilinx.c:	if (xspi->irq < 0 && xspi->irq != -ENXIO) {
drivers/spi/spi-xilinx.c:		ret = xspi->irq;
drivers/spi/spi-xilinx.c:	} else if (xspi->irq >= 0) {
drivers/spi/spi-xilinx.c:		ret = devm_request_irq(&pdev->dev, xspi->irq, xilinx_spi_irq, 0,
drivers/spi/spi-xilinx.c:	ret = spi_bitbang_start(&xspi->bitbang);
drivers/spi/spi-xilinx.c:		(unsigned long long)res->start, xspi->regs, xspi->irq);
drivers/spi/spi-xilinx.c:	void __iomem *regs_base = xspi->regs;
drivers/spi/spi-xilinx.c:	spi_bitbang_stop(&xspi->bitbang);
drivers/spi/spi-xilinx.c:	xspi->write_fn(0, regs_base + XIPIF_V123B_IIER_OFFSET);
drivers/spi/spi-xilinx.c:	xspi->write_fn(0, regs_base + XIPIF_V123B_DGIER_OFFSET);
drivers/spi/spi-xilinx.c:	spi_master_put(xspi->bitbang.master);
drivers/spi/spi-mt65xx.c:#include <linux/platform_data/spi-mt65xx.h>
drivers/spi/spi-mt65xx.c:	struct mtk_chip_config *chip_config = spi->controller_data;
drivers/spi/spi-mt65xx.c:	cpha = spi->mode & SPI_CPHA ? 1 : 0;
drivers/spi/spi-mt65xx.c:	cpol = spi->mode & SPI_CPOL ? 1 : 0;
drivers/spi/spi-mt65xx.c:		writel(mdata->pad_sel[spi->chip_select],
drivers/spi/spi-mt65xx.c:	struct mtk_spi *mdata = spi_master_get_devdata(spi->master);
drivers/spi/spi-mt65xx.c:	struct mtk_spi *mdata = spi_master_get_devdata(spi->master);
drivers/spi/spi-mt65xx.c:	if (!spi->controller_data)
drivers/spi/spi-mt65xx.c:		spi->controller_data = (void *)&mtk_default_chip_info;
drivers/spi/spi-mt65xx.c:	if (mdata->dev_comp->need_pad_sel && gpio_is_valid(spi->cs_gpio))
drivers/spi/spi-mt65xx.c:		gpio_direction_output(spi->cs_gpio, !(spi->mode & SPI_CS_HIGH));
drivers/spi/spi-mt65xx.c:	mdata->spi_clk = devm_clk_get(&pdev->dev, "spi-clk");
drivers/spi/spi-mt65xx.c:		dev_err(&pdev->dev, "failed to get spi-clk: %d\n", ret);
drivers/spi/spi-efm32.c:	struct efm32_spi_ddata *ddata = spi_master_get_devdata(spi->master);
drivers/spi/spi-efm32.c:	int value = !(spi->mode & SPI_CS_HIGH) == !(is_on == BITBANG_CS_ACTIVE);
drivers/spi/spi-efm32.c:	gpio_set_value(ddata->csgpio[spi->chip_select], value);
drivers/spi/spi-efm32.c:	struct efm32_spi_ddata *ddata = spi_master_get_devdata(spi->master);
drivers/spi/spi-efm32.c:	unsigned bpw = t->bits_per_word ?: spi->bits_per_word;
drivers/spi/spi-efm32.c:	unsigned speed = t->speed_hz ?: spi->max_speed_hz;
drivers/spi/spi-efm32.c:			(spi->mode & SPI_CPHA ? REG_CTRL_CLKPHA : 0) |
drivers/spi/spi-efm32.c:			(spi->mode & SPI_CPOL ? REG_CTRL_CLKPOL : 0), REG_CTRL);
drivers/spi/spi-efm32.c:	struct efm32_spi_ddata *ddata = spi_master_get_devdata(spi->master);
drivers/spi/spi-fsl-espi.c:	return ioread32be(espi->reg_base + offset);
drivers/spi/spi-fsl-espi.c:	return ioread16be(espi->reg_base + offset);
drivers/spi/spi-fsl-espi.c:	return ioread8(espi->reg_base + offset);
drivers/spi/spi-fsl-espi.c:	iowrite32be(val, espi->reg_base + offset);
drivers/spi/spi-fsl-espi.c:	iowrite16be(val, espi->reg_base + offset);
drivers/spi/spi-fsl-espi.c:	iowrite8(val, espi->reg_base + offset);
drivers/spi/spi-fsl-espi.c:	struct fsl_espi *espi = spi_master_get_devdata(m->spi->master);
drivers/spi/spi-fsl-espi.c:		dev_err(espi->dev, "message too long, size is %u bytes\n",
drivers/spi/spi-fsl-espi.c:			dev_err(espi->dev, "bits_per_word/speed_hz should be the same for all transfers\n");
drivers/spi/spi-fsl-espi.c:	if (!(m->spi->mode & SPI_LSB_FIRST) && first->bits_per_word != 8 &&
drivers/spi/spi-fsl-espi.c:		dev_err(espi->dev,
drivers/spi/spi-fsl-espi.c:	tx_left = espi->tx_t->len - espi->tx_pos;
drivers/spi/spi-fsl-espi.c:	tx_buf = espi->tx_t->tx_buf;
drivers/spi/spi-fsl-espi.c:			else if (espi->swab)
drivers/spi/spi-fsl-espi.c:					swahb32p(tx_buf + espi->tx_pos));
drivers/spi/spi-fsl-espi.c:					*(u32 *)(tx_buf + espi->tx_pos));
drivers/spi/spi-fsl-espi.c:			espi->tx_pos += 4;
drivers/spi/spi-fsl-espi.c:		} else if (tx_left >= 2 && tx_buf && espi->swab) {
drivers/spi/spi-fsl-espi.c:					swab16p(tx_buf + espi->tx_pos));
drivers/spi/spi-fsl-espi.c:			espi->tx_pos += 2;
drivers/spi/spi-fsl-espi.c:					*(u8 *)(tx_buf + espi->tx_pos));
drivers/spi/spi-fsl-espi.c:			espi->tx_pos += 1;
drivers/spi/spi-fsl-espi.c:		if (list_is_last(&espi->tx_t->transfer_list,
drivers/spi/spi-fsl-espi.c:		    espi->m_transfers) || espi->rxskip) {
drivers/spi/spi-fsl-espi.c:			espi->tx_done = true;
drivers/spi/spi-fsl-espi.c:		espi->tx_t = list_next_entry(espi->tx_t, transfer_list);
drivers/spi/spi-fsl-espi.c:		espi->tx_pos = 0;
drivers/spi/spi-fsl-espi.c:	rx_left = espi->rx_t->len - espi->rx_pos;
drivers/spi/spi-fsl-espi.c:	rx_buf = espi->rx_t->rx_buf;
drivers/spi/spi-fsl-espi.c:			if (rx_buf && espi->swab)
drivers/spi/spi-fsl-espi.c:				*(u32 *)(rx_buf + espi->rx_pos) = swahb32(val);
drivers/spi/spi-fsl-espi.c:				*(u32 *)(rx_buf + espi->rx_pos) = val;
drivers/spi/spi-fsl-espi.c:			espi->rx_pos += 4;
drivers/spi/spi-fsl-espi.c:		} else if (rx_left >= 2 && rx_buf && espi->swab) {
drivers/spi/spi-fsl-espi.c:			*(u16 *)(rx_buf + espi->rx_pos) = swab16(val);
drivers/spi/spi-fsl-espi.c:			espi->rx_pos += 2;
drivers/spi/spi-fsl-espi.c:				*(u8 *)(rx_buf + espi->rx_pos) = val;
drivers/spi/spi-fsl-espi.c:			espi->rx_pos += 1;
drivers/spi/spi-fsl-espi.c:		if (list_is_last(&espi->rx_t->transfer_list,
drivers/spi/spi-fsl-espi.c:		    espi->m_transfers)) {
drivers/spi/spi-fsl-espi.c:			espi->rx_done = true;
drivers/spi/spi-fsl-espi.c:		espi->rx_t = list_next_entry(espi->rx_t, transfer_list);
drivers/spi/spi-fsl-espi.c:		espi->rx_pos = 0;
drivers/spi/spi-fsl-espi.c:	struct fsl_espi *espi = spi_master_get_devdata(spi->master);
drivers/spi/spi-fsl-espi.c:	int bits_per_word = t ? t->bits_per_word : spi->bits_per_word;
drivers/spi/spi-fsl-espi.c:	u32 pm, hz = t ? t->speed_hz : spi->max_speed_hz;
drivers/spi/spi-fsl-espi.c:	pm = DIV_ROUND_UP(espi->spibrg, hz * 4) - 1;
drivers/spi/spi-fsl-espi.c:		pm = DIV_ROUND_UP(espi->spibrg, hz * 16 * 4) - 1;
drivers/spi/spi-fsl-espi.c:		fsl_espi_write_reg(espi, ESPI_SPMODEx(spi->chip_select),
drivers/spi/spi-fsl-espi.c:	struct fsl_espi *espi = spi_master_get_devdata(spi->master);
drivers/spi/spi-fsl-espi.c:	reinit_completion(&espi->done);
drivers/spi/spi-fsl-espi.c:	spcom = SPCOM_CS(spi->chip_select);
drivers/spi/spi-fsl-espi.c:	if (espi->rxskip) {
drivers/spi/spi-fsl-espi.c:		spcom |= SPCOM_RXSKIP(espi->rxskip);
drivers/spi/spi-fsl-espi.c:		rx_len = t->len - espi->rxskip;
drivers/spi/spi-fsl-espi.c:	spin_lock_irq(&espi->lock);
drivers/spi/spi-fsl-espi.c:	spin_unlock_irq(&espi->lock);
drivers/spi/spi-fsl-espi.c:	ret = wait_for_completion_timeout(&espi->done, 2 * HZ);
drivers/spi/spi-fsl-espi.c:		dev_err(espi->dev, "Transfer timed out!\n");
drivers/spi/spi-fsl-espi.c:	struct fsl_espi *espi = spi_master_get_devdata(m->spi->master);
drivers/spi/spi-fsl-espi.c:	espi->swab = spi->mode & SPI_LSB_FIRST && trans->bits_per_word > 8;
drivers/spi/spi-fsl-espi.c:	espi->m_transfers = &m->transfers;
drivers/spi/spi-fsl-espi.c:	espi->tx_t = list_first_entry(&m->transfers, struct spi_transfer,
drivers/spi/spi-fsl-espi.c:	espi->tx_pos = 0;
drivers/spi/spi-fsl-espi.c:	espi->tx_done = false;
drivers/spi/spi-fsl-espi.c:	espi->rx_t = list_first_entry(&m->transfers, struct spi_transfer,
drivers/spi/spi-fsl-espi.c:	espi->rx_pos = 0;
drivers/spi/spi-fsl-espi.c:	espi->rx_done = false;
drivers/spi/spi-fsl-espi.c:	espi->rxskip = fsl_espi_check_rxskip_mode(m);
drivers/spi/spi-fsl-espi.c:	if (trans->rx_nbits == SPI_NBITS_DUAL && !espi->rxskip) {
drivers/spi/spi-fsl-espi.c:		dev_err(espi->dev, "Dual output mode requires RXSKIP mode!\n");
drivers/spi/spi-fsl-espi.c:	if (espi->rxskip)
drivers/spi/spi-fsl-espi.c:		espi->rx_t = list_next_entry(espi->rx_t, transfer_list);
drivers/spi/spi-fsl-espi.c:	espi = spi_master_get_devdata(spi->master);
drivers/spi/spi-fsl-espi.c:	pm_runtime_get_sync(espi->dev);
drivers/spi/spi-fsl-espi.c:	cs->hw_mode = fsl_espi_read_reg(espi, ESPI_SPMODEx(spi->chip_select));
drivers/spi/spi-fsl-espi.c:	if (spi->mode & SPI_CPHA)
drivers/spi/spi-fsl-espi.c:	if (spi->mode & SPI_CPOL)
drivers/spi/spi-fsl-espi.c:	if (!(spi->mode & SPI_LSB_FIRST))
drivers/spi/spi-fsl-espi.c:	if (spi->mode & SPI_LOOP)
drivers/spi/spi-fsl-espi.c:	pm_runtime_mark_last_busy(espi->dev);
drivers/spi/spi-fsl-espi.c:	pm_runtime_put_autosuspend(espi->dev);
drivers/spi/spi-fsl-espi.c:	if (!espi->rx_done)
drivers/spi/spi-fsl-espi.c:	if (!espi->tx_done)
drivers/spi/spi-fsl-espi.c:	if (!espi->tx_done || !espi->rx_done)
drivers/spi/spi-fsl-espi.c:		dev_err(espi->dev,
drivers/spi/spi-fsl-espi.c:		dev_err(espi->dev, "Transfer done but rx/tx fifo's aren't empty!\n");
drivers/spi/spi-fsl-espi.c:	complete(&espi->done);
drivers/spi/spi-fsl-espi.c:	spin_lock(&espi->lock);
drivers/spi/spi-fsl-espi.c:		spin_unlock(&espi->lock);
drivers/spi/spi-fsl-espi.c:	dev_vdbg(espi->dev, "%s: events %x\n", __func__, events);
drivers/spi/spi-fsl-espi.c:	spin_unlock(&espi->lock);
drivers/spi/spi-fsl-espi.c:	spin_lock_init(&espi->lock);
drivers/spi/spi-fsl-espi.c:	espi->dev = dev;
drivers/spi/spi-fsl-espi.c:	espi->spibrg = fsl_get_sys_freq();
drivers/spi/spi-fsl-espi.c:	if (espi->spibrg == -1) {
drivers/spi/spi-fsl-espi.c:	master->min_speed_hz = DIV_ROUND_UP(espi->spibrg, 4 * 16 * 16);
drivers/spi/spi-fsl-espi.c:	master->max_speed_hz = DIV_ROUND_UP(espi->spibrg, 4);
drivers/spi/spi-fsl-espi.c:	init_completion(&espi->done);
drivers/spi/spi-fsl-espi.c:	espi->reg_base = devm_ioremap_resource(dev, mem);
drivers/spi/spi-fsl-espi.c:	if (IS_ERR(espi->reg_base)) {
drivers/spi/spi-fsl-espi.c:		ret = PTR_ERR(espi->reg_base);
drivers/spi/spi-fsl-espi.c:	dev_info(dev, "at 0x%p (irq = %u)\n", espi->reg_base, irq);
drivers/spi/spi-fsl-espi.c:	ret = of_property_read_u32(np, "fsl,espi-num-chipselects", &num_cs);
drivers/spi/spi-fsl-espi.c:		dev_err(dev, "No 'fsl,espi-num-chipselects' property\n");
Binary file drivers/spi/spi-sun4i.o matches
drivers/spi/spi-gpio.c: * spi->controller_state ... reserved for bitbang framework code
drivers/spi/spi-gpio.c: * spi->controller_data ... holds chipselect GPIO
drivers/spi/spi-gpio.c: * spi->master->dev.driver_data ... points to spi_gpio->bitbang
drivers/spi/spi-gpio.c: *		#include "spi-gpio.c"
drivers/spi/spi-gpio.c:	bang = spi_master_get_devdata(spi->master);
drivers/spi/spi-gpio.c:#include "spi-bitbang-txrx.h"
drivers/spi/spi-gpio.c:	unsigned flags = spi->master->flags;
drivers/spi/spi-gpio.c:	unsigned flags = spi->master->flags;
drivers/spi/spi-gpio.c:	unsigned flags = spi->master->flags;
drivers/spi/spi-gpio.c:	unsigned flags = spi->master->flags;
drivers/spi/spi-gpio.c:	unsigned long cs = spi_gpio->cs_gpios[spi->chip_select];
drivers/spi/spi-gpio.c:		setsck(spi, spi->mode & SPI_CPOL);
drivers/spi/spi-gpio.c:		gpio_set_value_cansleep(cs, (spi->mode & SPI_CS_HIGH) ? is_active : !is_active);
drivers/spi/spi-gpio.c:	struct device_node	*np = spi->master->dev.of_node;
drivers/spi/spi-gpio.c:		cs = spi_gpio->cs_gpios[spi->chip_select];
drivers/spi/spi-gpio.c:		 * ... otherwise, take it from spi->controller_data
drivers/spi/spi-gpio.c:		cs = (uintptr_t) spi->controller_data;
drivers/spi/spi-gpio.c:	if (!spi->controller_state) {
drivers/spi/spi-gpio.c:			status = gpio_request(cs, dev_name(&spi->dev));
drivers/spi/spi-gpio.c:					!(spi->mode & SPI_CS_HIGH));
drivers/spi/spi-gpio.c:		spi_gpio->cs_gpios[spi->chip_select] = cs;
drivers/spi/spi-gpio.c:		if (!spi->controller_state && cs != SPI_GPIO_NO_CHIPSELECT)
drivers/spi/spi-gpio.c:	unsigned long cs = spi_gpio->cs_gpios[spi->chip_select];
drivers/spi/spi-gpio.c:	{ .compatible = "spi-gpio" },
drivers/spi/spi-s3c24xx.c:#include "spi-s3c24xx-fiq.h"
drivers/spi/spi-s3c24xx.c:	gpio_set_value(spi->pin_cs, pol);
drivers/spi/spi-s3c24xx.c:	struct s3c24xx_spi_devstate *cs = spi->controller_state;
drivers/spi/spi-s3c24xx.c:	unsigned int cspol = spi->mode & SPI_CS_HIGH ? 1 : 0;
drivers/spi/spi-s3c24xx.c:		hw->set_cs(hw->pdata, spi->chip_select, cspol^1);
drivers/spi/spi-s3c24xx.c:		hw->set_cs(hw->pdata, spi->chip_select, cspol);
drivers/spi/spi-s3c24xx.c:	struct s3c24xx_spi_devstate *cs = spi->controller_state;
drivers/spi/spi-s3c24xx.c:	hz  = t ? t->speed_hz : spi->max_speed_hz;
drivers/spi/spi-s3c24xx.c:		hz = spi->max_speed_hz;
drivers/spi/spi-s3c24xx.c:	if (spi->mode != cs->mode) {
drivers/spi/spi-s3c24xx.c:		if (spi->mode & SPI_CPHA)
drivers/spi/spi-s3c24xx.c:		if (spi->mode & SPI_CPOL)
drivers/spi/spi-s3c24xx.c:		cs->mode = spi->mode;
drivers/spi/spi-s3c24xx.c:		dev_dbg(&spi->dev, "pre-scaler=%d (wanted %d, got %ld)\n",
drivers/spi/spi-s3c24xx.c:	struct s3c24xx_spi_devstate *cs = spi->controller_state;
drivers/spi/spi-s3c24xx.c:	struct s3c24xx_spi_devstate *cs = spi->controller_state;
drivers/spi/spi-s3c24xx.c:		cs = devm_kzalloc(&spi->dev,
drivers/spi/spi-s3c24xx.c:		spi->controller_state = cs;
drivers/spi/spi-s3c24xx.c:	return spi->fiq_inuse;
drivers/spi/spi-s3c24xx.c:	/* the spi->mode bits understood by this driver: */
Binary file drivers/spi/spi-bitbang.o matches
drivers/spi/modules.builtin:kernel/drivers/spi/spi-sun6i.ko
drivers/spi/spi-oc-tiny.c:		gpio_set_value(hw->gpio_cs[spi->chip_select],
drivers/spi/spi-oc-tiny.c:			(spi->mode & SPI_CS_HIGH) ? is_active : !is_active);
drivers/spi/spi-oc-tiny.c:	if (spi->max_speed_hz != hw->speed_hz) {
drivers/spi/spi-oc-tiny.c:		hw->speed_hz = spi->max_speed_hz;
drivers/spi/spi-oc-tiny.c:	hw->mode = spi->mode & (SPI_CPOL | SPI_CPHA);
drivers/spi/spi-oc-tiny.c:	{ .compatible = "opencores,tiny-spi-rtlsvn2", },
drivers/spi/spi-cavium-octeon.c:#include "spi-cavium.h"
drivers/spi/spi-cavium-octeon.c:		.name		= "spi-octeon",
drivers/spi/spi-fsl-lpspi.c:	unsigned int val = readl(fsl_lpspi->base + IMX7ULP_RDR);	\
drivers/spi/spi-fsl-lpspi.c:	if (fsl_lpspi->rx_buf) {					\
drivers/spi/spi-fsl-lpspi.c:		*(type *)fsl_lpspi->rx_buf = val;			\
drivers/spi/spi-fsl-lpspi.c:		fsl_lpspi->rx_buf += sizeof(type);                      \
drivers/spi/spi-fsl-lpspi.c:	if (fsl_lpspi->tx_buf) {					\
drivers/spi/spi-fsl-lpspi.c:		val = *(type *)fsl_lpspi->tx_buf;			\
drivers/spi/spi-fsl-lpspi.c:		fsl_lpspi->tx_buf += sizeof(type);			\
drivers/spi/spi-fsl-lpspi.c:	fsl_lpspi->remain -= sizeof(type);				\
drivers/spi/spi-fsl-lpspi.c:	writel(val, fsl_lpspi->base + IMX7ULP_TDR);			\
drivers/spi/spi-fsl-lpspi.c:	writel(enable, fsl_lpspi->base + IMX7ULP_IER);
drivers/spi/spi-fsl-lpspi.c:	return clk_prepare_enable(fsl_lpspi->clk);
drivers/spi/spi-fsl-lpspi.c:	clk_disable_unprepare(fsl_lpspi->clk);
drivers/spi/spi-fsl-lpspi.c:		txcnt = readl(fsl_lpspi->base + IMX7ULP_FSR) & 0xff;
drivers/spi/spi-fsl-lpspi.c:			dev_dbg(fsl_lpspi->dev, "txfifo empty timeout\n");
drivers/spi/spi-fsl-lpspi.c:	txfifo_cnt = readl(fsl_lpspi->base + IMX7ULP_FSR) & 0xff;
drivers/spi/spi-fsl-lpspi.c:	while (txfifo_cnt < fsl_lpspi->txfifosize) {
drivers/spi/spi-fsl-lpspi.c:		if (!fsl_lpspi->remain)
drivers/spi/spi-fsl-lpspi.c:		fsl_lpspi->tx(fsl_lpspi);
drivers/spi/spi-fsl-lpspi.c:	if (!fsl_lpspi->remain && (txfifo_cnt < fsl_lpspi->txfifosize))
drivers/spi/spi-fsl-lpspi.c:		writel(0, fsl_lpspi->base + IMX7ULP_TDR);
drivers/spi/spi-fsl-lpspi.c:	while (!(readl(fsl_lpspi->base + IMX7ULP_RSR) & RSR_RXEMPTY))
drivers/spi/spi-fsl-lpspi.c:		fsl_lpspi->rx(fsl_lpspi);
drivers/spi/spi-fsl-lpspi.c:	temp |= fsl_lpspi->config.bpw - 1;
drivers/spi/spi-fsl-lpspi.c:	temp |= fsl_lpspi->config.prescale << 27;
drivers/spi/spi-fsl-lpspi.c:	temp |= (fsl_lpspi->config.mode & 0x3) << 30;
drivers/spi/spi-fsl-lpspi.c:	temp |= (fsl_lpspi->config.chip_select & 0x3) << 24;
drivers/spi/spi-fsl-lpspi.c:	writel(temp, fsl_lpspi->base + IMX7ULP_TCR);
drivers/spi/spi-fsl-lpspi.c:	dev_dbg(fsl_lpspi->dev, "TCR=0x%x\n", temp);
drivers/spi/spi-fsl-lpspi.c:	temp = fsl_lpspi->txfifosize >> 1 | (fsl_lpspi->rxfifosize >> 1) << 16;
drivers/spi/spi-fsl-lpspi.c:	writel(temp, fsl_lpspi->base + IMX7ULP_FCR);
drivers/spi/spi-fsl-lpspi.c:	dev_dbg(fsl_lpspi->dev, "FCR=0x%x\n", temp);
drivers/spi/spi-fsl-lpspi.c:	struct lpspi_config config = fsl_lpspi->config;
drivers/spi/spi-fsl-lpspi.c:	perclk_rate = clk_get_rate(fsl_lpspi->clk);
drivers/spi/spi-fsl-lpspi.c:			fsl_lpspi->config.prescale = prescale;
drivers/spi/spi-fsl-lpspi.c:	writel(scldiv, fsl_lpspi->base + IMX7ULP_CCR);
drivers/spi/spi-fsl-lpspi.c:	dev_dbg(fsl_lpspi->dev, "perclk=%d, speed=%d, prescale =%d, scldiv=%d\n",
drivers/spi/spi-fsl-lpspi.c:	writel(temp, fsl_lpspi->base + IMX7ULP_CR);
drivers/spi/spi-fsl-lpspi.c:	writel(0, fsl_lpspi->base + IMX7ULP_CR);
drivers/spi/spi-fsl-lpspi.c:	if (fsl_lpspi->config.mode & SPI_CS_HIGH)
drivers/spi/spi-fsl-lpspi.c:	writel(temp, fsl_lpspi->base + IMX7ULP_CFGR1);
drivers/spi/spi-fsl-lpspi.c:	temp = readl(fsl_lpspi->base + IMX7ULP_CR);
drivers/spi/spi-fsl-lpspi.c:	writel(temp, fsl_lpspi->base + IMX7ULP_CR);
drivers/spi/spi-fsl-lpspi.c:	struct fsl_lpspi_data *fsl_lpspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-fsl-lpspi.c:	fsl_lpspi->config.mode = spi->mode;
drivers/spi/spi-fsl-lpspi.c:	fsl_lpspi->config.bpw = t ? t->bits_per_word : spi->bits_per_word;
drivers/spi/spi-fsl-lpspi.c:	fsl_lpspi->config.speed_hz = t ? t->speed_hz : spi->max_speed_hz;
drivers/spi/spi-fsl-lpspi.c:	fsl_lpspi->config.chip_select = spi->chip_select;
drivers/spi/spi-fsl-lpspi.c:	if (!fsl_lpspi->config.speed_hz)
drivers/spi/spi-fsl-lpspi.c:		fsl_lpspi->config.speed_hz = spi->max_speed_hz;
drivers/spi/spi-fsl-lpspi.c:	if (!fsl_lpspi->config.bpw)
drivers/spi/spi-fsl-lpspi.c:		fsl_lpspi->config.bpw = spi->bits_per_word;
drivers/spi/spi-fsl-lpspi.c:	if (fsl_lpspi->config.bpw <= 8) {
drivers/spi/spi-fsl-lpspi.c:		fsl_lpspi->rx = fsl_lpspi_buf_rx_u8;
drivers/spi/spi-fsl-lpspi.c:		fsl_lpspi->tx = fsl_lpspi_buf_tx_u8;
drivers/spi/spi-fsl-lpspi.c:	} else if (fsl_lpspi->config.bpw <= 16) {
drivers/spi/spi-fsl-lpspi.c:		fsl_lpspi->rx = fsl_lpspi_buf_rx_u16;
drivers/spi/spi-fsl-lpspi.c:		fsl_lpspi->tx = fsl_lpspi_buf_tx_u16;
drivers/spi/spi-fsl-lpspi.c:		fsl_lpspi->rx = fsl_lpspi_buf_rx_u32;
drivers/spi/spi-fsl-lpspi.c:		fsl_lpspi->tx = fsl_lpspi_buf_tx_u32;
drivers/spi/spi-fsl-lpspi.c:	fsl_lpspi->tx_buf = t->tx_buf;
drivers/spi/spi-fsl-lpspi.c:	fsl_lpspi->rx_buf = t->rx_buf;
drivers/spi/spi-fsl-lpspi.c:	fsl_lpspi->remain = t->len;
drivers/spi/spi-fsl-lpspi.c:	reinit_completion(&fsl_lpspi->xfer_done);
drivers/spi/spi-fsl-lpspi.c:	ret = wait_for_completion_timeout(&fsl_lpspi->xfer_done, HZ);
drivers/spi/spi-fsl-lpspi.c:		dev_dbg(fsl_lpspi->dev, "wait for completion timeout\n");
drivers/spi/spi-fsl-lpspi.c:	temp = readl(fsl_lpspi->base + IMX7ULP_TCR);
drivers/spi/spi-fsl-lpspi.c:	writel(temp, fsl_lpspi->base + IMX7ULP_TCR);
drivers/spi/spi-fsl-lpspi.c:	temp = readl(fsl_lpspi->base + IMX7ULP_SR);
drivers/spi/spi-fsl-lpspi.c:		if (!fsl_lpspi->remain)
drivers/spi/spi-fsl-lpspi.c:			complete(&fsl_lpspi->xfer_done);
drivers/spi/spi-fsl-lpspi.c:	fsl_lpspi->dev = &pdev->dev;
drivers/spi/spi-fsl-lpspi.c:	init_completion(&fsl_lpspi->xfer_done);
drivers/spi/spi-fsl-lpspi.c:	fsl_lpspi->base = devm_ioremap_resource(&pdev->dev, res);
drivers/spi/spi-fsl-lpspi.c:	if (IS_ERR(fsl_lpspi->base)) {
drivers/spi/spi-fsl-lpspi.c:		ret = PTR_ERR(fsl_lpspi->base);
drivers/spi/spi-fsl-lpspi.c:	fsl_lpspi->clk = devm_clk_get(&pdev->dev, "ipg");
drivers/spi/spi-fsl-lpspi.c:	if (IS_ERR(fsl_lpspi->clk)) {
drivers/spi/spi-fsl-lpspi.c:		ret = PTR_ERR(fsl_lpspi->clk);
drivers/spi/spi-fsl-lpspi.c:	ret = clk_prepare_enable(fsl_lpspi->clk);
drivers/spi/spi-fsl-lpspi.c:	temp = readl(fsl_lpspi->base + IMX7ULP_PARAM);
drivers/spi/spi-fsl-lpspi.c:	fsl_lpspi->txfifosize = 1 << (temp & 0x0f);
drivers/spi/spi-fsl-lpspi.c:	fsl_lpspi->rxfifosize = 1 << ((temp >> 8) & 0x0f);
drivers/spi/spi-fsl-lpspi.c:	clk_disable_unprepare(fsl_lpspi->clk);
drivers/spi/spi-fsl-lpspi.c:	clk_disable_unprepare(fsl_lpspi->clk);
drivers/spi/spi-tegra20-sflash.c:	struct tegra_sflash_data *tsd = spi_master_get_devdata(spi->master);
drivers/spi/spi-tegra20-sflash.c:		if (spi->mode & SPI_CPHA)
drivers/spi/spi-tegra20-sflash.c:		if (spi->mode & SPI_CPOL)
drivers/spi/spi-tegra20-sflash.c:		command |= SPI_CS0_EN << spi->chip_select;
drivers/spi/spi-tegra20-sflash.c:	/* the spi->mode bits understood by this driver: */
drivers/spi/spi-tegra20-sflash.c:	if (of_property_read_u32(tsd->dev->of_node, "spi-max-frequency",
drivers/spi/spi-tegra20-sflash.c:		.name		= "spi-tegra-sflash",
drivers/spi/spi-tegra20-sflash.c:MODULE_ALIAS("platform:spi-tegra-sflash");
drivers/spi/spi-dw-pci.c:#include "spi-dw.h"
drivers/spi/spi-fsl-cpm.h:#include "spi-fsl-lib.h"
drivers/spi/spi-atmel.c:	struct atmel_spi_device *asd = spi->controller_state;
drivers/spi/spi-atmel.c:	unsigned active = spi->mode & SPI_CS_HIGH;
drivers/spi/spi-atmel.c:		spi_writel(as, CSR0 + 4 * spi->chip_select, asd->csr);
drivers/spi/spi-atmel.c:					SPI_BF(PCS, ~(0x01 << spi->chip_select))
drivers/spi/spi-atmel.c:					SPI_BF(PCS, ~(0x01 << spi->chip_select))
drivers/spi/spi-atmel.c:		u32 cpol = (spi->mode & SPI_CPOL) ? SPI_BIT(CPOL) : 0;
drivers/spi/spi-atmel.c:		for (i = 0; i < spi->master->num_chipselect; i++) {
drivers/spi/spi-atmel.c:		mr = SPI_BFINS(PCS, ~(1 << spi->chip_select), mr);
drivers/spi/spi-atmel.c:		if (as->use_cs_gpios && spi->chip_select != 0)
drivers/spi/spi-atmel.c:	dev_dbg(&spi->dev, "activate %u%s, mr %08x\n",
drivers/spi/spi-atmel.c:	struct atmel_spi_device *asd = spi->controller_state;
drivers/spi/spi-atmel.c:	unsigned active = spi->mode & SPI_CS_HIGH;
drivers/spi/spi-atmel.c:	if (~SPI_BFEXT(PCS, mr) & (1 << spi->chip_select)) {
drivers/spi/spi-atmel.c:	dev_dbg(&spi->dev, "DEactivate %u%s, mr %08x\n",
drivers/spi/spi-atmel.c:	else if (atmel_spi_is_v2(as) || spi->chip_select != 0)
drivers/spi/spi-atmel.c:		dev_err(&spi->dev,
drivers/spi/spi-atmel.c:		dev_err(&spi->dev,
drivers/spi/spi-atmel.c:	csr = spi_readl(as, CSR0 + 4 * spi->chip_select);
drivers/spi/spi-atmel.c:	spi_writel(as, CSR0 + 4 * spi->chip_select, csr);
drivers/spi/spi-atmel.c:	if (msg->spi->bits_per_word > 8)
drivers/spi/spi-atmel.c:	dev_dbg(&msg->spi->dev,
drivers/spi/spi-atmel.c:		if (msg->spi->bits_per_word > 8)
drivers/spi/spi-atmel.c:		dev_dbg(&msg->spi->dev,
drivers/spi/spi-atmel.c:	unsigned int		bits = spi->bits_per_word;
drivers/spi/spi-atmel.c:	as = spi_master_get_devdata(spi->master);
drivers/spi/spi-atmel.c:			&& spi->chip_select == 0
drivers/spi/spi-atmel.c:			&& (spi->mode & SPI_CS_HIGH)) {
drivers/spi/spi-atmel.c:		dev_dbg(&spi->dev, "setup: can't be active-high\n");
drivers/spi/spi-atmel.c:	if (spi->mode & SPI_CPOL)
drivers/spi/spi-atmel.c:	if (!(spi->mode & SPI_CPHA))
drivers/spi/spi-atmel.c:	npcs_pin = (unsigned long)spi->controller_data;
drivers/spi/spi-atmel.c:		npcs_pin = spi->chip_select;
drivers/spi/spi-atmel.c:	else if (gpio_is_valid(spi->cs_gpio))
drivers/spi/spi-atmel.c:		npcs_pin = spi->cs_gpio;
drivers/spi/spi-atmel.c:	asd = spi->controller_state;
drivers/spi/spi-atmel.c:					      !(spi->mode & SPI_CS_HIGH));
drivers/spi/spi-atmel.c:		spi->controller_state = asd;
drivers/spi/spi-atmel.c:	dev_dbg(&spi->dev,
drivers/spi/spi-atmel.c:		bits, spi->mode, spi->chip_select, csr);
drivers/spi/spi-atmel.c:		spi_writel(as, CSR0 + 4 * spi->chip_select, csr);
drivers/spi/spi-atmel.c:		dev_dbg(&spi->dev, "missing rx or tx buf\n");
drivers/spi/spi-atmel.c:	asd = spi->controller_state;
drivers/spi/spi-atmel.c:		dev_dbg(&spi->dev,
drivers/spi/spi-atmel.c:				dev_err(&spi->dev,
drivers/spi/spi-atmel.c:			dev_err(&spi->dev, "spi transfer timeout\n");
drivers/spi/spi-atmel.c:	dev_dbg(&spi->dev, "new message %p submitted for %s\n",
drivers/spi/spi-atmel.c:					msg, dev_name(&spi->dev));
drivers/spi/spi-atmel.c:		dev_dbg(&spi->dev,
drivers/spi/spi-atmel.c:	spi_finalize_current_message(spi->master);
drivers/spi/spi-atmel.c:	struct atmel_spi_device	*asd = spi->controller_state;
drivers/spi/spi-atmel.c:	spi->controller_state = NULL;
drivers/spi/spi-atmel.c:	/* the spi->mode bits understood by this driver: */
drivers/spi/spi-st-ssc4.c:	if (spi->bits_per_word > 8) {
drivers/spi/spi-st-ssc4.c:	} else if (spi->bits_per_word == 8 && !(t->len & 0x1)) {
drivers/spi/spi-st-ssc4.c:	spi_finalize_current_transfer(spi->master);
drivers/spi/spi-st-ssc4.c:	gpio_free(spi->cs_gpio);
drivers/spi/spi-st-ssc4.c:/* the spi->mode bits understood by this driver: */
drivers/spi/spi-st-ssc4.c:	struct spi_st *spi_st = spi_master_get_devdata(spi->master);
drivers/spi/spi-st-ssc4.c:	u32 hz = spi->max_speed_hz;
drivers/spi/spi-st-ssc4.c:	int cs = spi->cs_gpio;
drivers/spi/spi-st-ssc4.c:		dev_err(&spi->dev, "max_speed_hz unspecified\n");
drivers/spi/spi-st-ssc4.c:		dev_err(&spi->dev, "%d is not a valid gpio\n", cs);
drivers/spi/spi-st-ssc4.c:	ret = gpio_request(cs, dev_name(&spi->dev));
drivers/spi/spi-st-ssc4.c:		dev_err(&spi->dev, "could not request gpio:%d\n", cs);
drivers/spi/spi-st-ssc4.c:	ret = gpio_direction_output(cs, spi->mode & SPI_CS_HIGH);
drivers/spi/spi-st-ssc4.c:		dev_err(&spi->dev,
drivers/spi/spi-st-ssc4.c:	dev_dbg(&spi->dev,
drivers/spi/spi-st-ssc4.c:	if (spi->mode & SPI_CPOL)
drivers/spi/spi-st-ssc4.c:	if (spi->mode & SPI_CPHA)
drivers/spi/spi-st-ssc4.c:	if ((spi->mode & SPI_LSB_FIRST) == 0)
drivers/spi/spi-st-ssc4.c:	if (spi->mode & SPI_LOOP)
drivers/spi/spi-st-ssc4.c:	var |= (spi->bits_per_word - 1);
drivers/spi/spi-st-ssc4.c:		.name = "spi-st",
drivers/spi/spi-ti-qspi.c:	return readl(qspi->base + reg);
drivers/spi/spi-ti-qspi.c:	writel(val, qspi->base + reg);
drivers/spi/spi-ti-qspi.c:	struct ti_qspi	*qspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-ti-qspi.c:	struct ti_qspi_regs *ctx_reg = &qspi->ctx_reg;
drivers/spi/spi-ti-qspi.c:	if (spi->master->busy) {
drivers/spi/spi-ti-qspi.c:		dev_dbg(qspi->dev, "master busy doing other transfers\n");
drivers/spi/spi-ti-qspi.c:	if (!qspi->spi_max_frequency) {
drivers/spi/spi-ti-qspi.c:		dev_err(qspi->dev, "spi max frequency not defined\n");
drivers/spi/spi-ti-qspi.c:	clk_rate = clk_get_rate(qspi->fclk);
drivers/spi/spi-ti-qspi.c:	clk_div = DIV_ROUND_UP(clk_rate, qspi->spi_max_frequency) - 1;
drivers/spi/spi-ti-qspi.c:		dev_dbg(qspi->dev, "clock divider < 0, using /1 divider\n");
drivers/spi/spi-ti-qspi.c:		dev_dbg(qspi->dev, "clock divider >%d , using /%d divider\n",
drivers/spi/spi-ti-qspi.c:	dev_dbg(qspi->dev, "hz: %d, clock divider %d\n",
drivers/spi/spi-ti-qspi.c:			qspi->spi_max_frequency, clk_div);
drivers/spi/spi-ti-qspi.c:	ret = pm_runtime_get_sync(qspi->dev);
drivers/spi/spi-ti-qspi.c:		dev_err(qspi->dev, "pm_runtime_get_sync() failed\n");
drivers/spi/spi-ti-qspi.c:	pm_runtime_mark_last_busy(qspi->dev);
drivers/spi/spi-ti-qspi.c:	ret = pm_runtime_put_autosuspend(qspi->dev);
drivers/spi/spi-ti-qspi.c:		dev_err(qspi->dev, "pm_runtime_put_autosuspend() failed\n");
drivers/spi/spi-ti-qspi.c:	struct ti_qspi_regs *ctx_reg = &qspi->ctx_reg;
drivers/spi/spi-ti-qspi.c:	cmd = qspi->cmd | QSPI_WR_SNGL;
drivers/spi/spi-ti-qspi.c:			dev_dbg(qspi->dev, "tx cmd %08x dc %08x data %02x\n",
drivers/spi/spi-ti-qspi.c:					cmd, qspi->dc, *txbuf);
drivers/spi/spi-ti-qspi.c:				writel(data, qspi->base +
drivers/spi/spi-ti-qspi.c:				writel(data, qspi->base +
drivers/spi/spi-ti-qspi.c:				writel(data, qspi->base +
drivers/spi/spi-ti-qspi.c:				writel(data, qspi->base +
drivers/spi/spi-ti-qspi.c:				writeb(*txbuf, qspi->base + QSPI_SPI_DATA_REG);
drivers/spi/spi-ti-qspi.c:				cmd = qspi->cmd | QSPI_WR_SNGL;
drivers/spi/spi-ti-qspi.c:			dev_dbg(qspi->dev, "tx cmd %08x dc %08x data %04x\n",
drivers/spi/spi-ti-qspi.c:					cmd, qspi->dc, *txbuf);
drivers/spi/spi-ti-qspi.c:			writew(*((u16 *)txbuf), qspi->base + QSPI_SPI_DATA_REG);
drivers/spi/spi-ti-qspi.c:			dev_dbg(qspi->dev, "tx cmd %08x dc %08x data %08x\n",
drivers/spi/spi-ti-qspi.c:					cmd, qspi->dc, *txbuf);
drivers/spi/spi-ti-qspi.c:			writel(*((u32 *)txbuf), qspi->base + QSPI_SPI_DATA_REG);
drivers/spi/spi-ti-qspi.c:			dev_err(qspi->dev, "write timed out\n");
drivers/spi/spi-ti-qspi.c:	cmd = qspi->cmd;
drivers/spi/spi-ti-qspi.c:		dev_dbg(qspi->dev, "rx cmd %08x dc %08x\n", cmd, qspi->dc);
drivers/spi/spi-ti-qspi.c:			dev_err(qspi->dev, "read timed out\n");
drivers/spi/spi-ti-qspi.c:			*rxbuf = readb(qspi->base + QSPI_SPI_DATA_REG);
drivers/spi/spi-ti-qspi.c:			*((u16 *)rxbuf) = readw(qspi->base + QSPI_SPI_DATA_REG);
drivers/spi/spi-ti-qspi.c:			*((u32 *)rxbuf) = readl(qspi->base + QSPI_SPI_DATA_REG);
drivers/spi/spi-ti-qspi.c:			dev_dbg(qspi->dev, "Error while writing\n");
drivers/spi/spi-ti-qspi.c:			dev_dbg(qspi->dev, "Error while reading\n");
drivers/spi/spi-ti-qspi.c:	complete(&qspi->transfer_complete);
drivers/spi/spi-ti-qspi.c:	struct dma_chan *chan = qspi->rx_chan;
drivers/spi/spi-ti-qspi.c:		dev_err(qspi->dev, "device_prep_dma_memcpy error\n");
drivers/spi/spi-ti-qspi.c:	reinit_completion(&qspi->transfer_complete);
drivers/spi/spi-ti-qspi.c:		dev_err(qspi->dev, "dma_submit_error %d\n", cookie);
drivers/spi/spi-ti-qspi.c:	ret = wait_for_completion_timeout(&qspi->transfer_complete,
drivers/spi/spi-ti-qspi.c:		dev_err(qspi->dev, "DMA wait_for_completion_timeout\n");
drivers/spi/spi-ti-qspi.c:	dma_addr_t dma_src = qspi->mmap_phys_base + msg->from;
drivers/spi/spi-ti-qspi.c:		ret = ti_qspi_dma_xfer(qspi, qspi->rx_bb_dma_addr,
drivers/spi/spi-ti-qspi.c:		memcpy(to, qspi->rx_bb_addr, xfer_len);
drivers/spi/spi-ti-qspi.c:	dma_addr_t dma_src = qspi->mmap_phys_base + from;
drivers/spi/spi-ti-qspi.c:	struct ti_qspi  *qspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-ti-qspi.c:	if (qspi->ctrl_base) {
drivers/spi/spi-ti-qspi.c:		regmap_update_bits(qspi->ctrl_base, qspi->ctrl_reg,
drivers/spi/spi-ti-qspi.c:				   MEM_CS_EN(spi->chip_select),
drivers/spi/spi-ti-qspi.c:	qspi->mmap_enabled = true;
drivers/spi/spi-ti-qspi.c:	struct ti_qspi  *qspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-ti-qspi.c:	if (qspi->ctrl_base)
drivers/spi/spi-ti-qspi.c:		regmap_update_bits(qspi->ctrl_base, qspi->ctrl_reg,
drivers/spi/spi-ti-qspi.c:	qspi->mmap_enabled = false;
drivers/spi/spi-ti-qspi.c:	struct ti_qspi  *qspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-ti-qspi.c:		      QSPI_SPI_SETUP_REG(spi->chip_select));
drivers/spi/spi-ti-qspi.c:	struct ti_qspi *qspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-ti-qspi.c:	mutex_lock(&qspi->list_lock);
drivers/spi/spi-ti-qspi.c:	if (!qspi->mmap_enabled)
drivers/spi/spi-ti-qspi.c:	if (qspi->rx_chan) {
drivers/spi/spi-ti-qspi.c:		memcpy_fromio(msg->buf, qspi->mmap_base + msg->from, msg->len);
drivers/spi/spi-ti-qspi.c:	mutex_unlock(&qspi->list_lock);
drivers/spi/spi-ti-qspi.c:	qspi->dc = 0;
drivers/spi/spi-ti-qspi.c:	if (spi->mode & SPI_CPHA)
drivers/spi/spi-ti-qspi.c:		qspi->dc |= QSPI_CKPHA(spi->chip_select);
drivers/spi/spi-ti-qspi.c:	if (spi->mode & SPI_CPOL)
drivers/spi/spi-ti-qspi.c:		qspi->dc |= QSPI_CKPOL(spi->chip_select);
drivers/spi/spi-ti-qspi.c:	if (spi->mode & SPI_CS_HIGH)
drivers/spi/spi-ti-qspi.c:		qspi->dc |= QSPI_CSPOL(spi->chip_select);
drivers/spi/spi-ti-qspi.c:	qspi->cmd = 0;
drivers/spi/spi-ti-qspi.c:	qspi->cmd |= QSPI_EN_CS(spi->chip_select);
drivers/spi/spi-ti-qspi.c:	qspi->cmd |= QSPI_FLEN(frame_len_words);
drivers/spi/spi-ti-qspi.c:	ti_qspi_write(qspi, qspi->dc, QSPI_SPI_DC_REG);
drivers/spi/spi-ti-qspi.c:	mutex_lock(&qspi->list_lock);
drivers/spi/spi-ti-qspi.c:	if (qspi->mmap_enabled)
drivers/spi/spi-ti-qspi.c:		qspi->cmd = ((qspi->cmd & ~QSPI_WLEN_MASK) |
drivers/spi/spi-ti-qspi.c:			dev_dbg(qspi->dev, "transfer message failed\n");
drivers/spi/spi-ti-qspi.c:			mutex_unlock(&qspi->list_lock);
drivers/spi/spi-ti-qspi.c:	mutex_unlock(&qspi->list_lock);
drivers/spi/spi-ti-qspi.c:	ti_qspi_write(qspi, qspi->cmd | QSPI_INVAL, QSPI_SPI_CMD_REG);
drivers/spi/spi-ti-qspi.c:	qspi->master = master;
drivers/spi/spi-ti-qspi.c:	qspi->dev = &pdev->dev;
drivers/spi/spi-ti-qspi.c:	mutex_init(&qspi->list_lock);
drivers/spi/spi-ti-qspi.c:	qspi->base = devm_ioremap_resource(&pdev->dev, r);
drivers/spi/spi-ti-qspi.c:	if (IS_ERR(qspi->base)) {
drivers/spi/spi-ti-qspi.c:		ret = PTR_ERR(qspi->base);
drivers/spi/spi-ti-qspi.c:		qspi->ctrl_base =
drivers/spi/spi-ti-qspi.c:		if (IS_ERR(qspi->ctrl_base)) {
drivers/spi/spi-ti-qspi.c:			ret = PTR_ERR(qspi->ctrl_base);
drivers/spi/spi-ti-qspi.c:						 1, &qspi->ctrl_reg);
drivers/spi/spi-ti-qspi.c:	qspi->fclk = devm_clk_get(&pdev->dev, "fck");
drivers/spi/spi-ti-qspi.c:	if (IS_ERR(qspi->fclk)) {
drivers/spi/spi-ti-qspi.c:		ret = PTR_ERR(qspi->fclk);
drivers/spi/spi-ti-qspi.c:	if (!of_property_read_u32(np, "spi-max-frequency", &max_freq))
drivers/spi/spi-ti-qspi.c:		qspi->spi_max_frequency = max_freq;
drivers/spi/spi-ti-qspi.c:	qspi->rx_chan = dma_request_chan_by_mask(&mask);
drivers/spi/spi-ti-qspi.c:	if (IS_ERR(qspi->rx_chan)) {
drivers/spi/spi-ti-qspi.c:		dev_err(qspi->dev,
drivers/spi/spi-ti-qspi.c:		qspi->rx_chan = NULL;
drivers/spi/spi-ti-qspi.c:	qspi->rx_bb_addr = dma_alloc_coherent(qspi->dev,
drivers/spi/spi-ti-qspi.c:					      &qspi->rx_bb_dma_addr,
drivers/spi/spi-ti-qspi.c:	if (!qspi->rx_bb_addr) {
drivers/spi/spi-ti-qspi.c:		dev_err(qspi->dev,
drivers/spi/spi-ti-qspi.c:		dma_release_channel(qspi->rx_chan);
drivers/spi/spi-ti-qspi.c:	master->dma_rx = qspi->rx_chan;
drivers/spi/spi-ti-qspi.c:	init_completion(&qspi->transfer_complete);
drivers/spi/spi-ti-qspi.c:		qspi->mmap_phys_base = (dma_addr_t)res_mmap->start;
drivers/spi/spi-ti-qspi.c:	if (!qspi->rx_chan && res_mmap) {
drivers/spi/spi-ti-qspi.c:		qspi->mmap_base = devm_ioremap_resource(&pdev->dev, res_mmap);
drivers/spi/spi-ti-qspi.c:		if (IS_ERR(qspi->mmap_base)) {
drivers/spi/spi-ti-qspi.c:				 PTR_ERR(qspi->mmap_base));
drivers/spi/spi-ti-qspi.c:			qspi->mmap_base = NULL;
drivers/spi/spi-ti-qspi.c:	qspi->mmap_enabled = false;
drivers/spi/spi-ti-qspi.c:	rc = spi_master_suspend(qspi->master);
drivers/spi/spi-ti-qspi.c:	if (qspi->rx_bb_addr)
drivers/spi/spi-ti-qspi.c:		dma_free_coherent(qspi->dev, QSPI_DMA_BUFFER_SIZE,
drivers/spi/spi-ti-qspi.c:				  qspi->rx_bb_addr,
drivers/spi/spi-ti-qspi.c:				  qspi->rx_bb_dma_addr);
drivers/spi/spi-ti-qspi.c:	if (qspi->rx_chan)
drivers/spi/spi-ti-qspi.c:		dma_release_channel(qspi->rx_chan);
drivers/spi/spi-clps711x.c:	if (!spi->controller_state) {
drivers/spi/spi-clps711x.c:		ret = devm_gpio_request(&spi->master->dev, spi->cs_gpio,
drivers/spi/spi-clps711x.c:					dev_name(&spi->master->dev));
drivers/spi/spi-clps711x.c:		spi->controller_state = spi;
drivers/spi/spi-clps711x.c:	gpio_direction_output(spi->cs_gpio, !(spi->mode & SPI_CS_HIGH));
drivers/spi/spi-clps711x.c:				  (spi->mode & SPI_CPHA) ?
drivers/spi/spi-clps711x.c:	clk_set_rate(hw->spi_clk, xfer->speed_hz ? : spi->max_speed_hz);
drivers/spi/spi-cadence.c:	return readl_relaxed(xspi->regs + offset);
drivers/spi/spi-cadence.c:	writel_relaxed(val, xspi->regs + offset);
drivers/spi/spi-cadence.c:	if (xspi->is_decoded_cs)
drivers/spi/spi-cadence.c:	struct cdns_spi *xspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-cadence.c:		if (!(xspi->is_decoded_cs))
drivers/spi/spi-cadence.c:			ctrl_reg |= ((~(CDNS_SPI_SS0 << spi->chip_select)) <<
drivers/spi/spi-cadence.c:			ctrl_reg |= (spi->chip_select << CDNS_SPI_SS_SHIFT) &
drivers/spi/spi-cadence.c:	struct cdns_spi *xspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-cadence.c:	if (spi->mode & SPI_CPHA)
drivers/spi/spi-cadence.c:	if (spi->mode & SPI_CPOL)
drivers/spi/spi-cadence.c:	struct cdns_spi *xspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-cadence.c:	frequency = clk_get_rate(xspi->ref_clk);
drivers/spi/spi-cadence.c:	if (xspi->speed_hz != transfer->speed_hz) {
drivers/spi/spi-cadence.c:		xspi->speed_hz = frequency / (2 << baud_rate_val);
drivers/spi/spi-cadence.c:	struct cdns_spi *xspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-cadence.c:	dev_dbg(&spi->dev, "%s, mode %d, %u bits/w, %u clock speed\n",
drivers/spi/spi-cadence.c:		__func__, spi->mode, spi->bits_per_word,
drivers/spi/spi-cadence.c:		xspi->speed_hz);
drivers/spi/spi-cadence.c:	       (xspi->tx_bytes > 0)) {
drivers/spi/spi-cadence.c:		if (xspi->txbuf)
drivers/spi/spi-cadence.c:			cdns_spi_write(xspi, CDNS_SPI_TXD, *xspi->txbuf++);
drivers/spi/spi-cadence.c:		xspi->tx_bytes--;
drivers/spi/spi-cadence.c:		trans_cnt = xspi->rx_bytes - xspi->tx_bytes;
drivers/spi/spi-cadence.c:			if (xspi->rxbuf)
drivers/spi/spi-cadence.c:				*xspi->rxbuf++ = data;
drivers/spi/spi-cadence.c:			xspi->rx_bytes--;
drivers/spi/spi-cadence.c:		if (xspi->tx_bytes) {
drivers/spi/spi-cadence.c:	xspi->txbuf = transfer->tx_buf;
drivers/spi/spi-cadence.c:	xspi->rxbuf = transfer->rx_buf;
drivers/spi/spi-cadence.c:	xspi->tx_bytes = transfer->len;
drivers/spi/spi-cadence.c:	xspi->rx_bytes = transfer->len;
drivers/spi/spi-cadence.c:	if (spi->cs_gpio == -ENOENT)
drivers/spi/spi-cadence.c:	if (!cdns_spi_data->gpio_requested && gpio_is_valid(spi->cs_gpio)) {
drivers/spi/spi-cadence.c:		ret = gpio_request_one(spi->cs_gpio,
drivers/spi/spi-cadence.c:				       (spi->mode & SPI_CS_HIGH) ?
drivers/spi/spi-cadence.c:				       dev_name(&spi->dev));
drivers/spi/spi-cadence.c:			dev_err(&spi->dev, "can't request chipselect gpio %d\n",
drivers/spi/spi-cadence.c:				spi->cs_gpio);
drivers/spi/spi-cadence.c:		if (gpio_is_valid(spi->cs_gpio)) {
drivers/spi/spi-cadence.c:			int mode = ((spi->mode & SPI_CS_HIGH) ?
drivers/spi/spi-cadence.c:			ret = gpio_direction_output(spi->cs_gpio, mode);
drivers/spi/spi-cadence.c:				dev_err(&spi->dev, "chipselect gpio %d setup failed (%d)\n",
drivers/spi/spi-cadence.c:					spi->cs_gpio, ret);
drivers/spi/spi-cadence.c:			gpio_free(spi->cs_gpio);
drivers/spi/spi-cadence.c:	xspi->regs = devm_ioremap_resource(&pdev->dev, res);
drivers/spi/spi-cadence.c:	if (IS_ERR(xspi->regs)) {
drivers/spi/spi-cadence.c:		ret = PTR_ERR(xspi->regs);
drivers/spi/spi-cadence.c:	xspi->pclk = devm_clk_get(&pdev->dev, "pclk");
drivers/spi/spi-cadence.c:	if (IS_ERR(xspi->pclk)) {
drivers/spi/spi-cadence.c:		ret = PTR_ERR(xspi->pclk);
drivers/spi/spi-cadence.c:	xspi->ref_clk = devm_clk_get(&pdev->dev, "ref_clk");
drivers/spi/spi-cadence.c:	if (IS_ERR(xspi->ref_clk)) {
drivers/spi/spi-cadence.c:		ret = PTR_ERR(xspi->ref_clk);
drivers/spi/spi-cadence.c:	ret = clk_prepare_enable(xspi->pclk);
drivers/spi/spi-cadence.c:	ret = clk_prepare_enable(xspi->ref_clk);
drivers/spi/spi-cadence.c:				   &xspi->is_decoded_cs);
drivers/spi/spi-cadence.c:		xspi->is_decoded_cs = 0;
drivers/spi/spi-cadence.c:	master->max_speed_hz = clk_get_rate(xspi->ref_clk) / 4;
drivers/spi/spi-cadence.c:	xspi->speed_hz = master->max_speed_hz;
drivers/spi/spi-cadence.c:	clk_disable_unprepare(xspi->ref_clk);
drivers/spi/spi-cadence.c:	clk_disable_unprepare(xspi->pclk);
drivers/spi/spi-cadence.c:	clk_disable_unprepare(xspi->ref_clk);
drivers/spi/spi-cadence.c:	clk_disable_unprepare(xspi->pclk);
drivers/spi/spi-cadence.c:	ret = clk_prepare_enable(xspi->pclk);
drivers/spi/spi-cadence.c:	ret = clk_prepare_enable(xspi->ref_clk);
drivers/spi/spi-cadence.c:		clk_disable(xspi->pclk);
drivers/spi/spi-cadence.c:	clk_disable_unprepare(xspi->ref_clk);
drivers/spi/spi-cadence.c:	clk_disable_unprepare(xspi->pclk);
drivers/spi/spi-cadence.c:	{ .compatible = "xlnx,zynq-spi-r1p6" },
drivers/spi/spi-cadence.c:	{ .compatible = "cdns,spi-r1p6" },
drivers/spi/spi-bcm2835aux.c: * Based on: spi-bcm2835.c
drivers/spi/spi-bcm2835aux.c:			dev_dbg_ratelimited(&spi->dev,
drivers/spi/spi-bcm2835aux.c:	if (spi->mode & SPI_CPOL) {
drivers/spi/spi-bcm2835aux.c:		.name		= "spi-bcm2835aux",
drivers/spi/spi-sh-sci.c:#include "spi-bitbang-txrx.h"
drivers/spi/spi-qup.c:	struct spi_master *master = spi->master;
drivers/spi/spi-qup.c:	struct spi_master *master = spi->master;
drivers/spi/spi-qup.c:	struct spi_qup *controller = spi_master_get_devdata(spi->master);
drivers/spi/spi-qup.c:	if (spi->mode & SPI_LOOP && xfer->len > controller->in_fifo_sz) {
drivers/spi/spi-qup.c:	else if (spi->master->can_dma &&
drivers/spi/spi-qup.c:		 spi->master->can_dma(spi->master, spi, xfer) &&
drivers/spi/spi-qup.c:		 spi->master->cur_msg_mapped)
drivers/spi/spi-qup.c:	struct spi_qup *controller = spi_master_get_devdata(spi->master);
drivers/spi/spi-qup.c:	if (spi->mode & SPI_CPOL)
drivers/spi/spi-qup.c:	if (spi->mode & SPI_LOOP)
drivers/spi/spi-qup.c:	if (spi->mode & SPI_CPHA)
drivers/spi/spi-qup.c:	 * HS_MODE improves signal stability for spi-clk high rates,
drivers/spi/spi-qup.c:	if ((xfer->speed_hz >= SPI_HS_MIN_RATE) && !(spi->mode & SPI_LOOP))
drivers/spi/spi-qup.c:	struct dma_slave_config *rx_conf = &spi->rx_conf,
drivers/spi/spi-qup.c:				*tx_conf = &spi->tx_conf;
drivers/spi/spi-qup.c:	struct device *dev = spi->dev;
drivers/spi/spi-qup.c:	rx_conf->src_maxburst = spi->in_blk_sz;
drivers/spi/spi-qup.c:	tx_conf->dst_maxburst = spi->out_blk_sz;
drivers/spi/spi-qup.c:	controller = spi_master_get_devdata(spi->master);
drivers/spi/spi-qup.c:	if (of_property_read_u32(dev->of_node, "spi-max-frequency", &max_freq))
drivers/spi/spi-qup.c:	{ .compatible = "qcom,spi-qup-v1.1.1", .data = (void *)1, },
drivers/spi/spi-qup.c:	{ .compatible = "qcom,spi-qup-v2.1.1", },
drivers/spi/spi-qup.c:	{ .compatible = "qcom,spi-qup-v2.2.1", },
drivers/spi/spi-cavium-thunderx.c:#include "spi-cavium.h"
drivers/spi/spi-cavium-thunderx.c:#define DRV_NAME "spi-thunderx"
drivers/spi/spi-rspi.c: * Based on spi-sh.c:
drivers/spi/spi-rspi.c:	iowrite8(data, rspi->addr + offset);
drivers/spi/spi-rspi.c:	iowrite16(data, rspi->addr + offset);
drivers/spi/spi-rspi.c:	iowrite32(data, rspi->addr + offset);
drivers/spi/spi-rspi.c:	return ioread8(rspi->addr + offset);
drivers/spi/spi-rspi.c:	return ioread16(rspi->addr + offset);
drivers/spi/spi-rspi.c:	if (rspi->byte_access)
drivers/spi/spi-rspi.c:	if (rspi->byte_access)
drivers/spi/spi-rspi.c:	rspi_write8(rspi, rspi->sppcr, RSPI_SPPCR);
drivers/spi/spi-rspi.c:	spbr = DIV_ROUND_UP(clk_get_rate(rspi->clk),
drivers/spi/spi-rspi.c:			    2 * rspi->max_speed_hz) - 1;
drivers/spi/spi-rspi.c:	rspi->byte_access = 0;
drivers/spi/spi-rspi.c:	rspi->spcmd |= SPCMD_SPB_8_TO_16(access_size);
drivers/spi/spi-rspi.c:	rspi_write16(rspi, rspi->spcmd, RSPI_SPCMD0);
drivers/spi/spi-rspi.c:	rspi_write8(rspi, rspi->sppcr, RSPI_SPPCR);
drivers/spi/spi-rspi.c:	clksrc = clk_get_rate(rspi->clk);
drivers/spi/spi-rspi.c:		if (rspi->max_speed_hz >= clksrc/4) /* 4=(CLK/2)/2 */
drivers/spi/spi-rspi.c:	spbr = DIV_ROUND_UP(clksrc, 2 * rspi->max_speed_hz) - 1;
drivers/spi/spi-rspi.c:	rspi->spcmd |= div << 2;
drivers/spi/spi-rspi.c:	rspi->byte_access = 1;
drivers/spi/spi-rspi.c:	rspi->spcmd |= SPCMD_SPB_8_TO_16(access_size);
drivers/spi/spi-rspi.c:	rspi_write16(rspi, rspi->spcmd, RSPI_SPCMD0);
drivers/spi/spi-rspi.c:	rspi_write8(rspi, rspi->sppcr, RSPI_SPPCR);
drivers/spi/spi-rspi.c:	spbr = DIV_ROUND_UP(clk_get_rate(rspi->clk), 2 * rspi->max_speed_hz);
drivers/spi/spi-rspi.c:	rspi->byte_access = 1;
drivers/spi/spi-rspi.c:		rspi->spcmd |= SPCMD_SPB_8BIT;
drivers/spi/spi-rspi.c:		rspi->spcmd |= SPCMD_SPB_16BIT;
drivers/spi/spi-rspi.c:		rspi->spcmd |= SPCMD_SPB_32BIT;
drivers/spi/spi-rspi.c:	rspi->spcmd |= SPCMD_SCKDEN | SPCMD_SLNDEN | SPCMD_SPNDEN;
drivers/spi/spi-rspi.c:	rspi_write16(rspi, rspi->spcmd, RSPI_SPCMD0);
drivers/spi/spi-rspi.c:#define set_config_register(spi, n) spi->ops->set_config_register(spi, n)
drivers/spi/spi-rspi.c:	rspi->spsr = rspi_read8(rspi, RSPI_SPSR);
drivers/spi/spi-rspi.c:	if (rspi->spsr & wait_mask)
drivers/spi/spi-rspi.c:	ret = wait_event_timeout(rspi->wait, rspi->spsr & wait_mask, HZ);
drivers/spi/spi-rspi.c:	if (ret == 0 && !(rspi->spsr & wait_mask))
drivers/spi/spi-rspi.c:		dev_err(&rspi->master->dev, "transmit timeout\n");
drivers/spi/spi-rspi.c:		dev_err(&rspi->master->dev, "receive timeout\n");
drivers/spi/spi-rspi.c:	rspi->dma_callbacked = 1;
drivers/spi/spi-rspi.c:	wake_up_interruptible(&rspi->wait);
drivers/spi/spi-rspi.c:		desc_rx = dmaengine_prep_slave_sg(rspi->master->dma_rx,
drivers/spi/spi-rspi.c:		desc_tx = dmaengine_prep_slave_sg(rspi->master->dma_tx,
drivers/spi/spi-rspi.c:		disable_irq(other_irq = rspi->tx_irq);
drivers/spi/spi-rspi.c:	if (rx && rspi->rx_irq != other_irq)
drivers/spi/spi-rspi.c:		disable_irq(rspi->rx_irq);
drivers/spi/spi-rspi.c:	rspi->dma_callbacked = 0;
drivers/spi/spi-rspi.c:		dma_async_issue_pending(rspi->master->dma_rx);
drivers/spi/spi-rspi.c:		dma_async_issue_pending(rspi->master->dma_tx);
drivers/spi/spi-rspi.c:	ret = wait_event_interruptible_timeout(rspi->wait,
drivers/spi/spi-rspi.c:					       rspi->dma_callbacked, HZ);
drivers/spi/spi-rspi.c:	if (ret > 0 && rspi->dma_callbacked)
drivers/spi/spi-rspi.c:		dev_err(&rspi->master->dev, "DMA timeout\n");
drivers/spi/spi-rspi.c:			dmaengine_terminate_all(rspi->master->dma_tx);
drivers/spi/spi-rspi.c:			dmaengine_terminate_all(rspi->master->dma_rx);
drivers/spi/spi-rspi.c:		enable_irq(rspi->tx_irq);
drivers/spi/spi-rspi.c:	if (rx && rspi->rx_irq != other_irq)
drivers/spi/spi-rspi.c:		enable_irq(rspi->rx_irq);
drivers/spi/spi-rspi.c:		dmaengine_terminate_all(rspi->master->dma_rx);
drivers/spi/spi-rspi.c:			     dev_driver_string(&rspi->master->dev),
drivers/spi/spi-rspi.c:			     dev_name(&rspi->master->dev));
drivers/spi/spi-rspi.c:	return xfer->len > rspi->ops->fifo_size;
drivers/spi/spi-rspi.c:	if (!rspi->master->can_dma || !__rspi_can_dma(rspi, xfer))
drivers/spi/spi-rspi.c:				dev_err(&rspi->master->dev, "transmit timeout\n");
drivers/spi/spi-rspi.c:				dev_err(&rspi->master->dev, "receive timeout\n");
drivers/spi/spi-rspi.c:	if (rspi->master->can_dma && __rspi_can_dma(rspi, xfer)) {
drivers/spi/spi-rspi.c:				dev_err(&rspi->master->dev, "transmit timeout\n");
drivers/spi/spi-rspi.c:	if (rspi->master->can_dma && __rspi_can_dma(rspi, xfer)) {
drivers/spi/spi-rspi.c:				dev_err(&rspi->master->dev, "receive timeout\n");
drivers/spi/spi-rspi.c:	if (spi->mode & SPI_LOOP) {
drivers/spi/spi-rspi.c:	struct rspi_data *rspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-rspi.c:	rspi->max_speed_hz = spi->max_speed_hz;
drivers/spi/spi-rspi.c:	rspi->spcmd = SPCMD_SSLKP;
drivers/spi/spi-rspi.c:	if (spi->mode & SPI_CPOL)
drivers/spi/spi-rspi.c:		rspi->spcmd |= SPCMD_CPOL;
drivers/spi/spi-rspi.c:	if (spi->mode & SPI_CPHA)
drivers/spi/spi-rspi.c:		rspi->spcmd |= SPCMD_CPHA;
drivers/spi/spi-rspi.c:	rspi->sppcr = 0;
drivers/spi/spi-rspi.c:	if (spi->mode & SPI_LOOP)
drivers/spi/spi-rspi.c:		rspi->sppcr |= SPPCR_SPLP;
drivers/spi/spi-rspi.c:			dev_err(&msg->spi->dev,
drivers/spi/spi-rspi.c:		rspi_write16(rspi, rspi->spcmd | mode, RSPI_SPCMD(i));
drivers/spi/spi-rspi.c:	if (msg->spi->mode &
drivers/spi/spi-rspi.c:	rspi_write16(rspi, rspi->spcmd, RSPI_SPCMD0);
drivers/spi/spi-rspi.c:	rspi->spsr = spsr = rspi_read8(rspi, RSPI_SPSR);
drivers/spi/spi-rspi.c:		wake_up(&rspi->wait);
drivers/spi/spi-rspi.c:	rspi->spsr = spsr = rspi_read8(rspi, RSPI_SPSR);
drivers/spi/spi-rspi.c:		wake_up(&rspi->wait);
drivers/spi/spi-rspi.c:	rspi->spsr = spsr = rspi_read8(rspi, RSPI_SPSR);
drivers/spi/spi-rspi.c:		wake_up(&rspi->wait);
drivers/spi/spi-rspi.c:	rspi_release_dma(rspi->master);
drivers/spi/spi-rspi.c:	{ .compatible = "renesas,rspi-rz", .data = &rspi_rz_ops },
drivers/spi/spi-rspi.c:	rspi->ops = ops;
drivers/spi/spi-rspi.c:	rspi->master = master;
drivers/spi/spi-rspi.c:	rspi->addr = devm_ioremap_resource(&pdev->dev, res);
drivers/spi/spi-rspi.c:	if (IS_ERR(rspi->addr)) {
drivers/spi/spi-rspi.c:		ret = PTR_ERR(rspi->addr);
drivers/spi/spi-rspi.c:	rspi->clk = devm_clk_get(&pdev->dev, NULL);
drivers/spi/spi-rspi.c:	if (IS_ERR(rspi->clk)) {
drivers/spi/spi-rspi.c:		ret = PTR_ERR(rspi->clk);
drivers/spi/spi-rspi.c:	init_waitqueue_head(&rspi->wait);
drivers/spi/spi-rspi.c:			rspi->rx_irq = rspi->tx_irq = ret;
drivers/spi/spi-rspi.c:		rspi->rx_irq = ret;
drivers/spi/spi-rspi.c:			rspi->tx_irq = ret;
drivers/spi/spi-rspi.c:	if (rspi->rx_irq == rspi->tx_irq) {
drivers/spi/spi-rspi.c:		ret = rspi_request_irq(&pdev->dev, rspi->rx_irq, rspi_irq_mux,
drivers/spi/spi-rspi.c:		ret = rspi_request_irq(&pdev->dev, rspi->rx_irq, rspi_irq_rx,
drivers/spi/spi-rspi.c:			ret = rspi_request_irq(&pdev->dev, rspi->tx_irq,
drivers/spi/spi-rspi.c:	{ "rspi-rz",	(kernel_ulong_t)&rspi_rz_ops },
drivers/spi/spi-loopback-test.c: *  linux/drivers/spi/spi-loopback-test.c
drivers/spi/spi-loopback-test.c:#include "spi-test.h"
drivers/spi/spi-loopback-test.c:		spi->mode |= loop_req ? SPI_LOOP : 0;
drivers/spi/spi-loopback-test.c:		spi->mode |= no_cs ? SPI_NO_CS : 0;
drivers/spi/spi-loopback-test.c:			dev_err(&spi->dev, "SPI setup with SPI_LOOP or SPI_NO_CS failed (%d)\n",
drivers/spi/spi-loopback-test.c:	dev_info(&spi->dev, "Executing spi-loopback-tests\n");
drivers/spi/spi-loopback-test.c:	dev_info(&spi->dev, "Finished spi-loopback-tests with return: %i\n",
drivers/spi/spi-loopback-test.c:	{ .compatible	= "linux,spi-loopback-test", },
drivers/spi/spi-loopback-test.c:		.name = "spi-loopback-test",
drivers/spi/spi-loopback-test.c:	dev_info(&spi->dev, "  spi_msg@%pK\n", msg);
drivers/spi/spi-loopback-test.c:		dev_info(&spi->dev, "    status:        %i\n",
drivers/spi/spi-loopback-test.c:	dev_info(&spi->dev, "    frame_length:  %i\n",
drivers/spi/spi-loopback-test.c:	dev_info(&spi->dev, "    actual_length: %i\n",
drivers/spi/spi-loopback-test.c:		dev_info(&spi->dev, "    spi_transfer@%pK\n", xfer);
drivers/spi/spi-loopback-test.c:		dev_info(&spi->dev, "      len:    %i\n", xfer->len);
drivers/spi/spi-loopback-test.c:		dev_info(&spi->dev, "      tx_buf: %pK\n", xfer->tx_buf);
drivers/spi/spi-loopback-test.c:		dev_info(&spi->dev, "      rx_buf: %pK\n", xfer->rx_buf);
drivers/spi/spi-loopback-test.c:				dev_info(&spi->dev,
drivers/spi/spi-loopback-test.c:		dev_err(&spi->dev,
drivers/spi/spi-loopback-test.c:		dev_err(&spi->dev,
drivers/spi/spi-loopback-test.c:				dev_err(&spi->dev,
drivers/spi/spi-loopback-test.c:	dev_err(&spi->dev,
drivers/spi/spi-loopback-test.c:	dev_err(&spi->dev,
drivers/spi/spi-loopback-test.c:				dev_err(&spi->dev,
drivers/spi/spi-loopback-test.c:	dev_err(&spi->dev,
drivers/spi/spi-loopback-test.c:		dev_warn_once(&spi->dev,
drivers/spi/spi-loopback-test.c:		dev_warn_once(&spi->dev,
drivers/spi/spi-loopback-test.c:		dev_info(&spi->dev, "Running test %s\n", test.description);
drivers/spi/spi-loopback-test.c:		dev_info(&spi->dev,
drivers/spi/spi-loopback-test.c:			dev_info(&spi->dev,
drivers/spi/spi-loopback-test.c:				 "spi-message timed out - rerunning...\n");
drivers/spi/spi-loopback-test.c:			dev_err(&spi->dev,
drivers/spi/spi-loopback-test.c:			dev_err(&spi->dev,
drivers/spi/spi-loopback-test.c:		dev_err(&spi->dev,
drivers/spi/spi-loopback-test.c:			(spi->master->dma_alignment ?			\
drivers/spi/spi-loopback-test.c:			 spi->master->dma_alignment :			\
drivers/spi/spi-iproc-qspi.c:#include "spi-bcm-qspi.h"
drivers/spi/spi-iproc-qspi.c:	{ .compatible = "brcm,spi-nsp-qspi" },
drivers/spi/spi-iproc-qspi.c:	{ .compatible = "brcm,spi-ns2-qspi" },
drivers/spi/spi-sh-msiof.c:	struct device_node	*np = spi->master->dev.of_node;
drivers/spi/spi-sh-msiof.c:	struct sh_msiof_spi_priv *p = spi_master_get_devdata(spi->master);
drivers/spi/spi-sh-msiof.c:		 * Use spi->controller_data for CS (same strategy as spi_gpio),
drivers/spi/spi-sh-msiof.c:		spi->cs_gpio = (uintptr_t)spi->controller_data;
drivers/spi/spi-sh-msiof.c:	if (gpio_is_valid(spi->cs_gpio)) {
drivers/spi/spi-sh-msiof.c:		gpio_direction_output(spi->cs_gpio, !(spi->mode & SPI_CS_HIGH));
drivers/spi/spi-sh-msiof.c:	    (p->native_cs_high == !!(spi->mode & SPI_CS_HIGH)))
drivers/spi/spi-sh-msiof.c:	if (spi->mode & SPI_CS_HIGH)
drivers/spi/spi-sh-msiof.c:	p->native_cs_high = spi->mode & SPI_CS_HIGH;
drivers/spi/spi-sh-msiof.c:	if (gpio_is_valid(spi->cs_gpio)) {
drivers/spi/spi-sh-msiof.c:		ss = spi->chip_select;
drivers/spi/spi-sh-msiof.c:		cs_high = !!(spi->mode & SPI_CS_HIGH);
drivers/spi/spi-sh-msiof.c:	sh_msiof_spi_set_pin_regs(p, ss, !!(spi->mode & SPI_CPOL),
drivers/spi/spi-sh-msiof.c:				  !!(spi->mode & SPI_CPHA),
drivers/spi/spi-sh-msiof.c:				  !!(spi->mode & SPI_3WIRE),
drivers/spi/spi-sh-msiof.c:				  !!(spi->mode & SPI_LSB_FIRST), cs_high);
drivers/spi/spi-sh-msiof.c:	info->mode = of_property_read_bool(np, "spi-slave") ? MSIOF_SPI_SLAVE
drivers/spi/spi-cavium.c:#include "spi-cavium.h"
drivers/spi/spi-cavium.c:	mode = spi->mode;
drivers/spi/spi-cavium.c:	if (spi->chip_select < 4)
drivers/spi/spi-cavium.c:		p->cs_enax |= 1ull << (12 + spi->chip_select);
drivers/spi/spi-cavium.c:		mpi_tx.s.csid = spi->chip_select;
drivers/spi/spi-cavium.c:	mpi_tx.s.csid = spi->chip_select;
drivers/spi/spi-ep93xx.c:#include <linux/platform_data/spi-ep93xx.h>
drivers/spi/spi-ep93xx.c:	unsigned long spi_clk_rate = clk_get_rate(espi->clk);
drivers/spi/spi-ep93xx.c:	cr0 |= (spi->mode & (SPI_CPHA | SPI_CPOL)) << SSPCR0_MODE_SHIFT;
drivers/spi/spi-ep93xx.c:		spi->mode, div_cpsr, div_scr, dss);
drivers/spi/spi-ep93xx.c:	writel(div_cpsr, espi->mmio + SSPCPSR);
drivers/spi/spi-ep93xx.c:	writel(cr0, espi->mmio + SSPCR0);
drivers/spi/spi-ep93xx.c:			val = ((u16 *)xfer->tx_buf)[espi->tx];
drivers/spi/spi-ep93xx.c:		espi->tx += 2;
drivers/spi/spi-ep93xx.c:			val = ((u8 *)xfer->tx_buf)[espi->tx];
drivers/spi/spi-ep93xx.c:		espi->tx += 1;
drivers/spi/spi-ep93xx.c:	writel(val, espi->mmio + SSPDR);
drivers/spi/spi-ep93xx.c:	val = readl(espi->mmio + SSPDR);
drivers/spi/spi-ep93xx.c:			((u16 *)xfer->rx_buf)[espi->rx] = val;
drivers/spi/spi-ep93xx.c:		espi->rx += 2;
drivers/spi/spi-ep93xx.c:			((u8 *)xfer->rx_buf)[espi->rx] = val;
drivers/spi/spi-ep93xx.c:		espi->rx += 1;
drivers/spi/spi-ep93xx.c:	while ((readl(espi->mmio + SSPSR) & SSPSR_RNE)) {
drivers/spi/spi-ep93xx.c:		espi->fifo_level--;
drivers/spi/spi-ep93xx.c:	while (espi->fifo_level < SPI_FIFO_SIZE && espi->tx < xfer->len) {
drivers/spi/spi-ep93xx.c:		espi->fifo_level++;
drivers/spi/spi-ep93xx.c:	if (espi->rx == xfer->len)
drivers/spi/spi-ep93xx.c:		chan = espi->dma_rx;
drivers/spi/spi-ep93xx.c:		sgt = &espi->rx_sgt;
drivers/spi/spi-ep93xx.c:		conf.src_addr = espi->sspdr_phys;
drivers/spi/spi-ep93xx.c:		chan = espi->dma_tx;
drivers/spi/spi-ep93xx.c:		sgt = &espi->tx_sgt;
drivers/spi/spi-ep93xx.c:		conf.dst_addr = espi->sspdr_phys;
drivers/spi/spi-ep93xx.c:	 * because we are using @espi->zeropage to provide a zero RX buffer
drivers/spi/spi-ep93xx.c:			sg_set_page(sg, virt_to_page(espi->zeropage),
drivers/spi/spi-ep93xx.c:		chan = espi->dma_rx;
drivers/spi/spi-ep93xx.c:		sgt = &espi->rx_sgt;
drivers/spi/spi-ep93xx.c:		chan = espi->dma_tx;
drivers/spi/spi-ep93xx.c:		sgt = &espi->tx_sgt;
drivers/spi/spi-ep93xx.c:	dma_async_issue_pending(espi->dma_rx);
drivers/spi/spi-ep93xx.c:	dma_async_issue_pending(espi->dma_tx);
drivers/spi/spi-ep93xx.c:	if (readl(espi->mmio + SSPIIR) & SSPIIR_RORIS) {
drivers/spi/spi-ep93xx.c:		writel(0, espi->mmio + SSPICR);
drivers/spi/spi-ep93xx.c:	val = readl(espi->mmio + SSPCR1);
drivers/spi/spi-ep93xx.c:	writel(val, espi->mmio + SSPCR1);
drivers/spi/spi-ep93xx.c:	espi->rx = 0;
drivers/spi/spi-ep93xx.c:	espi->tx = 0;
drivers/spi/spi-ep93xx.c:	if (espi->dma_rx && xfer->len > SPI_FIFO_SIZE)
drivers/spi/spi-ep93xx.c:	val = readl(espi->mmio + SSPCR1);
drivers/spi/spi-ep93xx.c:	writel(val, espi->mmio + SSPCR1);
drivers/spi/spi-ep93xx.c:	while (readl(espi->mmio + SSPSR) & SSPSR_RNE) {
drivers/spi/spi-ep93xx.c:		readl(espi->mmio + SSPDR);
drivers/spi/spi-ep93xx.c:	espi->fifo_level = 0;
drivers/spi/spi-ep93xx.c:	ret = clk_enable(espi->clk);
drivers/spi/spi-ep93xx.c:	val = readl(espi->mmio + SSPCR1);
drivers/spi/spi-ep93xx.c:	writel(val, espi->mmio + SSPCR1);
drivers/spi/spi-ep93xx.c:	val = readl(espi->mmio + SSPCR1);
drivers/spi/spi-ep93xx.c:	writel(val, espi->mmio + SSPCR1);
drivers/spi/spi-ep93xx.c:	clk_disable(espi->clk);
drivers/spi/spi-ep93xx.c:	espi->zeropage = (void *)get_zeroed_page(GFP_KERNEL);
drivers/spi/spi-ep93xx.c:	if (!espi->zeropage)
drivers/spi/spi-ep93xx.c:	espi->dma_rx_data.port = EP93XX_DMA_SSP;
drivers/spi/spi-ep93xx.c:	espi->dma_rx_data.direction = DMA_DEV_TO_MEM;
drivers/spi/spi-ep93xx.c:	espi->dma_rx_data.name = "ep93xx-spi-rx";
drivers/spi/spi-ep93xx.c:	espi->dma_rx = dma_request_channel(mask, ep93xx_spi_dma_filter,
drivers/spi/spi-ep93xx.c:					   &espi->dma_rx_data);
drivers/spi/spi-ep93xx.c:	if (!espi->dma_rx) {
drivers/spi/spi-ep93xx.c:	espi->dma_tx_data.port = EP93XX_DMA_SSP;
drivers/spi/spi-ep93xx.c:	espi->dma_tx_data.direction = DMA_MEM_TO_DEV;
drivers/spi/spi-ep93xx.c:	espi->dma_tx_data.name = "ep93xx-spi-tx";
drivers/spi/spi-ep93xx.c:	espi->dma_tx = dma_request_channel(mask, ep93xx_spi_dma_filter,
drivers/spi/spi-ep93xx.c:					   &espi->dma_tx_data);
drivers/spi/spi-ep93xx.c:	if (!espi->dma_tx) {
drivers/spi/spi-ep93xx.c:	dma_release_channel(espi->dma_rx);
drivers/spi/spi-ep93xx.c:	espi->dma_rx = NULL;
drivers/spi/spi-ep93xx.c:	free_page((unsigned long)espi->zeropage);
drivers/spi/spi-ep93xx.c:	if (espi->dma_rx) {
drivers/spi/spi-ep93xx.c:		dma_release_channel(espi->dma_rx);
drivers/spi/spi-ep93xx.c:		sg_free_table(&espi->rx_sgt);
drivers/spi/spi-ep93xx.c:	if (espi->dma_tx) {
drivers/spi/spi-ep93xx.c:		dma_release_channel(espi->dma_tx);
drivers/spi/spi-ep93xx.c:		sg_free_table(&espi->tx_sgt);
drivers/spi/spi-ep93xx.c:	if (espi->zeropage)
drivers/spi/spi-ep93xx.c:		free_page((unsigned long)espi->zeropage);
drivers/spi/spi-ep93xx.c:	espi->clk = devm_clk_get(&pdev->dev, NULL);
drivers/spi/spi-ep93xx.c:	if (IS_ERR(espi->clk)) {
drivers/spi/spi-ep93xx.c:		error = PTR_ERR(espi->clk);
drivers/spi/spi-ep93xx.c:	master->max_speed_hz = clk_get_rate(espi->clk) / 2;
drivers/spi/spi-ep93xx.c:	master->min_speed_hz = clk_get_rate(espi->clk) / (254 * 256);
drivers/spi/spi-ep93xx.c:	espi->sspdr_phys = res->start + SSPDR;
drivers/spi/spi-ep93xx.c:	espi->mmio = devm_ioremap_resource(&pdev->dev, res);
drivers/spi/spi-ep93xx.c:	if (IS_ERR(espi->mmio)) {
drivers/spi/spi-ep93xx.c:		error = PTR_ERR(espi->mmio);
drivers/spi/spi-ep93xx.c:	writel(0, espi->mmio + SSPCR1);
drivers/spi/spi-altera.c:		writel(BIT(spi->chip_select), hw->base + ALTERA_SPI_SLAVE_SEL);
drivers/spi/spi-altera.c:	{ .compatible = "ALTR,spi-1.0", },
drivers/spi/spi-altera.c:	{ .compatible = "altr,spi-1.0", },
drivers/spi/spi-bcm63xx.c:	struct bcm63xx_spi *bs = spi_master_get_devdata(spi->master);
drivers/spi/spi-bcm63xx.c:	dev_dbg(&spi->dev, "Setting clock register to %02x (hz %d)\n",
drivers/spi/spi-bcm63xx.c:/* the spi->mode bits understood by this driver: */
drivers/spi/spi-bcm63xx.c:	struct bcm63xx_spi *bs = spi_master_get_devdata(spi->master);
drivers/spi/spi-bcm63xx.c:	dev_dbg(&spi->dev, "txrx: tx %p, rx %p, len %d\n",
drivers/spi/spi-bcm63xx.c:	cmd |= (spi->chip_select << SPI_CMD_DEVICE_ID_SHIFT);
drivers/spi/spi-bcm63xx.c:			dev_err(&spi->dev, "unable to do transfers larger than FIFO size (%i > %i)\n",
drivers/spi/spi-bcm63xx.c:			dev_err(&spi->dev, "unable to change speed between transfers\n");
drivers/spi/spi-bcm63xx.c:			dev_err(&spi->dev, "unable to keep CS asserted after transfer\n");
drivers/spi/spi-bcm63xx.c:	struct bcm63xx_spi *bs = spi_master_get_devdata(spi->master);
drivers/spi/spi-sh.c:	struct spi_sh_data *ss = spi_master_get_devdata(spi->master);
drivers/spi/spi-sh.c:	struct spi_sh_data *ss = spi_master_get_devdata(spi->master);
drivers/spi/spi-sh.c:	pr_debug("\tmode = %02x\n", spi->mode);
drivers/spi/spi-sh.c:	struct spi_sh_data *ss = spi_master_get_devdata(spi->master);
drivers/spi/spi-tle62x0.c:	pdata = dev_get_platdata(&spi->dev);
drivers/spi/spi-tle62x0.c:		dev_err(&spi->dev, "no device data specified\n");
drivers/spi/spi-tle62x0.c:	ret = device_create_file(&spi->dev, &dev_attr_status_show);
drivers/spi/spi-tle62x0.c:		dev_err(&spi->dev, "cannot create status attribute\n");
drivers/spi/spi-tle62x0.c:		ret = device_create_file(&spi->dev, gpio_attrs[ptr]);
drivers/spi/spi-tle62x0.c:			dev_err(&spi->dev, "cannot create gpio attribute\n");
drivers/spi/spi-tle62x0.c:		device_remove_file(&spi->dev, gpio_attrs[ptr]);
drivers/spi/spi-tle62x0.c:	device_remove_file(&spi->dev, &dev_attr_status_show);
drivers/spi/spi-tle62x0.c:		device_remove_file(&spi->dev, gpio_attrs[ptr]);
drivers/spi/spi-tle62x0.c:	device_remove_file(&spi->dev, &dev_attr_status_show);
Binary file drivers/spi/spi.o matches
drivers/spi/spi-butterfly.c:	return spi->controller_data;
drivers/spi/spi-butterfly.c:		setsck(spi, spi->mode & SPI_CPOL);
drivers/spi/spi-butterfly.c:#include "spi-bitbang-txrx.h"
drivers/spi/spi-fsl-spi.c:#include "spi-fsl-lib.h"
drivers/spi/spi-fsl-spi.c:#include "spi-fsl-cpm.h"
drivers/spi/spi-fsl-spi.c:#include "spi-fsl-spi.h"
drivers/spi/spi-fsl-spi.c:	struct mpc8xxx_spi *mspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-fsl-spi.c:	struct spi_mpc8xxx_cs *cs = spi->controller_state;
drivers/spi/spi-fsl-spi.c:	struct fsl_spi_reg *reg_base = mspi->reg_base;
drivers/spi/spi-fsl-spi.c:	if (mspi->flags & SPI_CPM_MODE) {
drivers/spi/spi-fsl-spi.c:	struct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);
drivers/spi/spi-fsl-spi.c:	bool pol = spi->mode & SPI_CS_HIGH;
drivers/spi/spi-fsl-spi.c:	struct spi_mpc8xxx_cs	*cs = spi->controller_state;
drivers/spi/spi-fsl-spi.c:	pdata = spi->dev.parent->parent->platform_data;
drivers/spi/spi-fsl-spi.c:		mpc8xxx_spi->rx_shift = cs->rx_shift;
drivers/spi/spi-fsl-spi.c:		mpc8xxx_spi->tx_shift = cs->tx_shift;
drivers/spi/spi-fsl-spi.c:		mpc8xxx_spi->get_rx = cs->get_rx;
drivers/spi/spi-fsl-spi.c:		mpc8xxx_spi->get_tx = cs->get_tx;
drivers/spi/spi-fsl-spi.c:	if (mpc8xxx_spi->set_shifts)
drivers/spi/spi-fsl-spi.c:		mpc8xxx_spi->set_shifts(&cs->rx_shift, &cs->tx_shift,
drivers/spi/spi-fsl-spi.c:					!(spi->mode & SPI_LSB_FIRST));
drivers/spi/spi-fsl-spi.c:	mpc8xxx_spi->rx_shift = cs->rx_shift;
drivers/spi/spi-fsl-spi.c:	mpc8xxx_spi->tx_shift = cs->tx_shift;
drivers/spi/spi-fsl-spi.c:	mpc8xxx_spi->get_rx = cs->get_rx;
drivers/spi/spi-fsl-spi.c:	mpc8xxx_spi->get_tx = cs->get_tx;
drivers/spi/spi-fsl-spi.c:	if (spi->mode & SPI_LSB_FIRST &&
drivers/spi/spi-fsl-spi.c:	struct spi_mpc8xxx_cs	*cs = spi->controller_state;
drivers/spi/spi-fsl-spi.c:	mpc8xxx_spi = spi_master_get_devdata(spi->master);
drivers/spi/spi-fsl-spi.c:		bits_per_word = spi->bits_per_word;
drivers/spi/spi-fsl-spi.c:		hz = spi->max_speed_hz;
drivers/spi/spi-fsl-spi.c:	if (!(mpc8xxx_spi->flags & SPI_CPM_MODE))
drivers/spi/spi-fsl-spi.c:	else if (mpc8xxx_spi->flags & SPI_QE)
drivers/spi/spi-fsl-spi.c:	if ((mpc8xxx_spi->spibrg / hz) > 64) {
drivers/spi/spi-fsl-spi.c:		pm = (mpc8xxx_spi->spibrg - 1) / (hz * 64) + 1;
drivers/spi/spi-fsl-spi.c:			  dev_name(&spi->dev), hz, mpc8xxx_spi->spibrg / 1024);
drivers/spi/spi-fsl-spi.c:		pm = (mpc8xxx_spi->spibrg - 1) / (hz * 4) + 1;
drivers/spi/spi-fsl-spi.c:	struct fsl_spi_reg *reg_base = mspi->reg_base;
drivers/spi/spi-fsl-spi.c:	mspi->count = len;
drivers/spi/spi-fsl-spi.c:	word = mspi->get_tx(mspi);
drivers/spi/spi-fsl-spi.c:	struct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);
drivers/spi/spi-fsl-spi.c:	reg_base = mpc8xxx_spi->reg_base;
drivers/spi/spi-fsl-spi.c:	bits_per_word = spi->bits_per_word;
drivers/spi/spi-fsl-spi.c:	mpc8xxx_spi->tx = t->tx_buf;
drivers/spi/spi-fsl-spi.c:	mpc8xxx_spi->rx = t->rx_buf;
drivers/spi/spi-fsl-spi.c:	reinit_completion(&mpc8xxx_spi->done);
drivers/spi/spi-fsl-spi.c:	if (mpc8xxx_spi->flags & SPI_CPM_MODE)
drivers/spi/spi-fsl-spi.c:	wait_for_completion(&mpc8xxx_spi->done);
drivers/spi/spi-fsl-spi.c:	if (mpc8xxx_spi->flags & SPI_CPM_MODE)
drivers/spi/spi-fsl-spi.c:	return mpc8xxx_spi->count;
drivers/spi/spi-fsl-spi.c:			dev_err(&spi->dev,
drivers/spi/spi-fsl-spi.c:	if (!spi->max_speed_hz)
drivers/spi/spi-fsl-spi.c:	mpc8xxx_spi = spi_master_get_devdata(spi->master);
drivers/spi/spi-fsl-spi.c:	reg_base = mpc8xxx_spi->reg_base;
drivers/spi/spi-fsl-spi.c:	if (spi->mode & SPI_CPHA)
drivers/spi/spi-fsl-spi.c:	if (spi->mode & SPI_CPOL)
drivers/spi/spi-fsl-spi.c:	if (!(spi->mode & SPI_LSB_FIRST))
drivers/spi/spi-fsl-spi.c:	if (spi->mode & SPI_LOOP)
drivers/spi/spi-fsl-spi.c:	if (mpc8xxx_spi->type == TYPE_GRLIB) {
drivers/spi/spi-fsl-spi.c:		if (gpio_is_valid(spi->cs_gpio)) {
drivers/spi/spi-fsl-spi.c:			retval = gpio_request(spi->cs_gpio,
drivers/spi/spi-fsl-spi.c:					      dev_name(&spi->dev));
drivers/spi/spi-fsl-spi.c:			desel = !(spi->mode & SPI_CS_HIGH);
drivers/spi/spi-fsl-spi.c:			retval = gpio_direction_output(spi->cs_gpio, desel);
drivers/spi/spi-fsl-spi.c:				gpio_free(spi->cs_gpio);
drivers/spi/spi-fsl-spi.c:		} else if (spi->cs_gpio != -ENOENT) {
drivers/spi/spi-fsl-spi.c:			if (spi->cs_gpio < 0)
drivers/spi/spi-fsl-spi.c:				return spi->cs_gpio;
drivers/spi/spi-fsl-spi.c:		/* When spi->cs_gpio == -ENOENT, a hole in the phandle list
drivers/spi/spi-fsl-spi.c:	struct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);
drivers/spi/spi-fsl-spi.c:	if (mpc8xxx_spi->type == TYPE_GRLIB && gpio_is_valid(spi->cs_gpio))
drivers/spi/spi-fsl-spi.c:		gpio_free(spi->cs_gpio);
drivers/spi/spi-fsl-spi.c:	struct fsl_spi_reg *reg_base = mspi->reg_base;
drivers/spi/spi-fsl-spi.c:		if (mspi->rx)
drivers/spi/spi-fsl-spi.c:			mspi->get_rx(rx_data, mspi);
drivers/spi/spi-fsl-spi.c:	mspi->count -= 1;
drivers/spi/spi-fsl-spi.c:	if (mspi->count) {
drivers/spi/spi-fsl-spi.c:		u32 word = mspi->get_tx(mspi);
drivers/spi/spi-fsl-spi.c:		complete(&mspi->done);
drivers/spi/spi-fsl-spi.c:	struct fsl_spi_reg *reg_base = mspi->reg_base;
drivers/spi/spi-fsl-spi.c:	dev_dbg(mspi->dev, "%s: events %x\n", __func__, events);
drivers/spi/spi-fsl-spi.c:	if (mspi->flags & SPI_CPM_MODE)
drivers/spi/spi-fsl-spi.c:	struct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);
drivers/spi/spi-fsl-spi.c:	struct fsl_spi_reg *reg_base = mpc8xxx_spi->reg_base;
drivers/spi/spi-fsl-spi.c:	u16 cs = spi->chip_select;
drivers/spi/spi-fsl-spi.c:	if (gpio_is_valid(spi->cs_gpio)) {
drivers/spi/spi-fsl-spi.c:		gpio_set_value(spi->cs_gpio, on);
drivers/spi/spi-fsl-spi.c:	} else if (cs < mpc8xxx_spi->native_chipselects) {
drivers/spi/spi-fsl-spi.c:	struct fsl_spi_reg *reg_base = mpc8xxx_spi->reg_base;
drivers/spi/spi-fsl-spi.c:	mpc8xxx_spi->set_shifts = fsl_spi_grlib_set_shifts;
drivers/spi/spi-fsl-spi.c:		mpc8xxx_spi->max_bits_per_word = mbits + 1;
drivers/spi/spi-fsl-spi.c:	mpc8xxx_spi->native_chipselects = 0;
drivers/spi/spi-fsl-spi.c:		mpc8xxx_spi->native_chipselects = SPCAP_SSSZ(capabilities);
drivers/spi/spi-fsl-spi.c:	master->num_chipselect = mpc8xxx_spi->native_chipselects;
drivers/spi/spi-fsl-spi.c:	mpc8xxx_spi->max_bits_per_word = 32;
drivers/spi/spi-fsl-spi.c:	mpc8xxx_spi->type = fsl_spi_get_type(dev);
drivers/spi/spi-fsl-spi.c:	mpc8xxx_spi->reg_base = devm_ioremap_resource(dev, mem);
drivers/spi/spi-fsl-spi.c:	if (IS_ERR(mpc8xxx_spi->reg_base)) {
drivers/spi/spi-fsl-spi.c:		ret = PTR_ERR(mpc8xxx_spi->reg_base);
drivers/spi/spi-fsl-spi.c:	if (mpc8xxx_spi->type == TYPE_GRLIB)
drivers/spi/spi-fsl-spi.c:		SPI_BPW_RANGE_MASK(1, mpc8xxx_spi->max_bits_per_word);
drivers/spi/spi-fsl-spi.c:	if (mpc8xxx_spi->flags & SPI_QE_CPU_MODE)
drivers/spi/spi-fsl-spi.c:		mpc8xxx_spi->set_shifts = fsl_spi_qe_cpu_set_shifts;
drivers/spi/spi-fsl-spi.c:	if (mpc8xxx_spi->set_shifts)
drivers/spi/spi-fsl-spi.c:		mpc8xxx_spi->set_shifts(&mpc8xxx_spi->rx_shift,
drivers/spi/spi-fsl-spi.c:					&mpc8xxx_spi->tx_shift, 8, 1);
drivers/spi/spi-fsl-spi.c:	ret = devm_request_irq(dev, mpc8xxx_spi->irq, fsl_spi_irq,
drivers/spi/spi-fsl-spi.c:	reg_base = mpc8xxx_spi->reg_base;
drivers/spi/spi-fsl-spi.c:	if (mpc8xxx_spi->max_bits_per_word < 8) {
drivers/spi/spi-fsl-spi.c:		regval |= SPMODE_LEN(mpc8xxx_spi->max_bits_per_word - 1);
drivers/spi/spi-fsl-spi.c:	if (mpc8xxx_spi->flags & SPI_QE_CPU_MODE)
drivers/spi/spi-fsl-spi.c:		 mpc8xxx_spi->irq, mpc8xxx_spi_strmode(mpc8xxx_spi->flags));
drivers/spi/spi-fsl-spi.c:	struct device *dev = spi->dev.parent->parent;
drivers/spi/spi-fsl-spi.c:	u16 cs = spi->chip_select;
drivers/spi/spi-fsl-spi.c:	if (mpc8xxx_spi->type == TYPE_FSL)
drivers/spi/spi-dw.c:#include "spi-dw.h"
drivers/spi/spi-dw.c:	struct dw_spi *dws = spi_master_get_devdata(spi->master);
drivers/spi/spi-dw.c:		dw_writel(dws, DW_SPI_SER, BIT(spi->chip_select));
drivers/spi/spi-dw.c:		| (spi->mode << SPI_MODE_OFFSET)
drivers/spi/spi-dw.c:	chip_info = spi->controller_data;
drivers/spi/spi-dw.c:	if (gpio_is_valid(spi->cs_gpio)) {
drivers/spi/spi-dw.c:		ret = gpio_direction_output(spi->cs_gpio,
drivers/spi/spi-dw.c:				!(spi->mode & SPI_CS_HIGH));
drivers/spi/spi-jcore.c:	struct jcore_spi *hw = spi_master_get_devdata(spi->master);
drivers/spi/spi-jcore.c:	u32 csbit = 1U << (2 * spi->chip_select);
drivers/spi/spi-jcore.c:	dev_dbg(hw->master->dev.parent, "chipselect %d\n", spi->chip_select);
drivers/spi/spi-brcmstb-qspi.c:#include "spi-bcm-qspi.h"
drivers/spi/spi-brcmstb-qspi.c:	{ .compatible = "brcm,spi-brcmstb-qspi" },
drivers/spi/spi-brcmstb-qspi.c:	{ .compatible = "brcm,spi-brcmstb-mspi" },
drivers/spi/spi-dw-mmio.c:#include "spi-dw.h"
drivers/spi/spi-mpc512x-psc.c:	struct mpc512x_psc_spi_cs *cs = spi->controller_state;
drivers/spi/spi-mpc512x-psc.c:	    ? t->speed_hz : spi->max_speed_hz;
drivers/spi/spi-mpc512x-psc.c:	    ? t->bits_per_word : spi->bits_per_word;
drivers/spi/spi-mpc512x-psc.c:	struct mpc512x_psc_spi_cs *cs = spi->controller_state;
drivers/spi/spi-mpc512x-psc.c:	struct mpc512x_psc_spi *mps = spi_master_get_devdata(spi->master);
drivers/spi/spi-mpc512x-psc.c:	if (spi->mode & SPI_CPHA)
drivers/spi/spi-mpc512x-psc.c:	if (spi->mode & SPI_CPOL)
drivers/spi/spi-mpc512x-psc.c:	if (spi->mode & SPI_LSB_FIRST)
drivers/spi/spi-mpc512x-psc.c:	if (mps->cs_control && gpio_is_valid(spi->cs_gpio))
drivers/spi/spi-mpc512x-psc.c:		mps->cs_control(spi, (spi->mode & SPI_CS_HIGH) ? 1 : 0);
drivers/spi/spi-mpc512x-psc.c:	struct mpc512x_psc_spi *mps = spi_master_get_devdata(spi->master);
drivers/spi/spi-mpc512x-psc.c:	if (mps->cs_control && gpio_is_valid(spi->cs_gpio))
drivers/spi/spi-mpc512x-psc.c:		mps->cs_control(spi, (spi->mode & SPI_CS_HIGH) ? 0 : 1);
drivers/spi/spi-mpc512x-psc.c:	struct mpc512x_psc_spi *mps = spi_master_get_devdata(spi->master);
drivers/spi/spi-mpc512x-psc.c:			dev_warn(&spi->dev,
drivers/spi/spi-mpc512x-psc.c:	struct mpc512x_psc_spi_cs *cs = spi->controller_state;
drivers/spi/spi-mpc512x-psc.c:	if (spi->bits_per_word % 8)
drivers/spi/spi-mpc512x-psc.c:		if (gpio_is_valid(spi->cs_gpio)) {
drivers/spi/spi-mpc512x-psc.c:			ret = gpio_request(spi->cs_gpio, dev_name(&spi->dev));
drivers/spi/spi-mpc512x-psc.c:				dev_err(&spi->dev, "can't get CS gpio: %d\n",
drivers/spi/spi-mpc512x-psc.c:			gpio_direction_output(spi->cs_gpio,
drivers/spi/spi-mpc512x-psc.c:					spi->mode & SPI_CS_HIGH ? 0 : 1);
drivers/spi/spi-mpc512x-psc.c:		spi->controller_state = cs;
drivers/spi/spi-mpc512x-psc.c:	cs->bits_per_word = spi->bits_per_word;
drivers/spi/spi-mpc512x-psc.c:	cs->speed_hz = spi->max_speed_hz;
drivers/spi/spi-mpc512x-psc.c:	if (gpio_is_valid(spi->cs_gpio))
drivers/spi/spi-mpc512x-psc.c:		gpio_free(spi->cs_gpio);
drivers/spi/spi-mpc512x-psc.c:	kfree(spi->controller_state);
drivers/spi/spi-mpc512x-psc.c:	gpio_set_value(spi->cs_gpio, onoff);
drivers/spi/spi-xtensa-xtfpga.c:	__raw_writel(val, spi->regs + addr);
drivers/spi/spi-xtensa-xtfpga.c:	return __raw_readl(spi->regs + addr);
drivers/spi/spi-xtensa-xtfpga.c:	struct xtfpga_spi *xspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-xtensa-xtfpga.c:	xspi->data = (xspi->data << bits) | (v & GENMASK(bits - 1, 0));
drivers/spi/spi-xtensa-xtfpga.c:	xspi->data_sz += bits;
drivers/spi/spi-xtensa-xtfpga.c:	if (xspi->data_sz >= 16) {
drivers/spi/spi-xtensa-xtfpga.c:				   xspi->data >> (xspi->data_sz - 16));
drivers/spi/spi-xtensa-xtfpga.c:		xspi->data_sz -= 16;
drivers/spi/spi-xtensa-xtfpga.c:	struct xtfpga_spi *xspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-xtensa-xtfpga.c:	WARN_ON(xspi->data_sz != 0);
drivers/spi/spi-xtensa-xtfpga.c:	xspi->data_sz = 0;
drivers/spi/spi-xtensa-xtfpga.c:	xspi->bitbang.master = master;
drivers/spi/spi-xtensa-xtfpga.c:	xspi->bitbang.chipselect = xtfpga_spi_chipselect;
drivers/spi/spi-xtensa-xtfpga.c:	xspi->bitbang.txrx_word[SPI_MODE_0] = xtfpga_spi_txrx_word;
drivers/spi/spi-xtensa-xtfpga.c:	xspi->regs = devm_ioremap_resource(&pdev->dev, mem);
drivers/spi/spi-xtensa-xtfpga.c:	if (IS_ERR(xspi->regs)) {
drivers/spi/spi-xtensa-xtfpga.c:		ret = PTR_ERR(xspi->regs);
drivers/spi/spi-xtensa-xtfpga.c:	ret = spi_bitbang_start(&xspi->bitbang);
drivers/spi/spi-xtensa-xtfpga.c:	spi_bitbang_stop(&xspi->bitbang);
drivers/spi/.spi-sun6i.o.cmd:cmd_drivers/spi/spi-sun6i.o := arm-linux-gnueabi-gcc -Wp,-MD,drivers/spi/.spi-sun6i.o.d  -nostdinc -isystem /usr/lib/gcc-cross/arm-linux-gnueabi/7/include -I./arch/arm/include -I./arch/arm/include/generated  -I./include -I./arch/arm/include/uapi -I./arch/arm/include/generated/uapi -I./include/uapi -I./include/generated/uapi -include ./include/linux/kconfig.h -D__KERNEL__ -mlittle-endian -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -fshort-wchar -Werror-implicit-function-declaration -Wno-format-security -std=gnu89 -fno-PIE -fno-dwarf2-cfi-asm -fno-ipa-sra -mabi=aapcs-linux -mno-thumb-interwork -mfpu=vfp -funwind-tables -marm -Wa,-mno-warn-deprecated -D__LINUX_ARM_ARCH__=5 -march=armv5te -mtune=arm9tdmi -msoft-float -Uarm -fno-delete-null-pointer-checks -Wno-frame-address -Wno-format-truncation -Wno-format-overflow -Wno-int-in-bool-context -O2 --param=allow-store-data-races=0 -DCC_HAVE_ASM_GOTO -Wframe-larger-than=1024 -fno-stack-protector -Wno-unused-but-set-variable -Wno-unused-const-variable -fomit-frame-pointer -fno-var-tracking-assignments -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fno-stack-check -fconserve-stack -Werror=implicit-int -Werror=strict-prototypes -Werror=date-time -Werror=incompatible-pointer-types -Werror=designated-init    -DKBUILD_BASENAME='"spi_sun6i"'  -DKBUILD_MODNAME='"spi_sun6i"' -c -o drivers/spi/spi-sun6i.o drivers/spi/spi-sun6i.c
drivers/spi/.spi-sun6i.o.cmd:source_drivers/spi/spi-sun6i.o := drivers/spi/spi-sun6i.c
drivers/spi/.spi-sun6i.o.cmd:deps_drivers/spi/spi-sun6i.o := \
drivers/spi/.spi-sun6i.o.cmd:drivers/spi/spi-sun6i.o: $(deps_drivers/spi/spi-sun6i.o)
drivers/spi/.spi-sun6i.o.cmd:$(deps_drivers/spi/spi-sun6i.o):
drivers/spi/spi-sc18is602.c:		hw->buffer[0] = 1 << msg->spi->chip_select;
drivers/spi/spi-sc18is602.c:		status = sc18is602_setup_transfer(hw, t->speed_hz, spi->mode);
drivers/spi/spi-sc18is602.c:	struct sc18is602 *hw = spi_master_get_devdata(spi->master);
drivers/spi/spi-sc18is602.c:	if (hw->id == sc18is602 && spi->chip_select == 2)
drivers/spi/spi-meson-spicc.c:	if (spi->mode & SPI_CPOL)
drivers/spi/spi-meson-spicc.c:	if (spi->mode & SPI_CPHA)
drivers/spi/spi-meson-spicc.c:	if (spi->mode & SPI_CS_HIGH)
drivers/spi/spi-meson-spicc.c:	if (spi->mode & SPI_READY)
drivers/spi/spi-meson-spicc.c:	conf |= FIELD_PREP(SPICC_CS_MASK, spi->chip_select);
drivers/spi/spi-meson-spicc.c:	if (!spi->controller_state)
drivers/spi/spi-meson-spicc.c:		spi->controller_state = spi_master_get_devdata(spi->master);
drivers/spi/spi-meson-spicc.c:	else if (gpio_is_valid(spi->cs_gpio))
drivers/spi/spi-meson-spicc.c:	else if (spi->cs_gpio == -ENOENT)
drivers/spi/spi-meson-spicc.c:	if (gpio_is_valid(spi->cs_gpio)) {
drivers/spi/spi-meson-spicc.c:		ret = gpio_request(spi->cs_gpio, dev_name(&spi->dev));
drivers/spi/spi-meson-spicc.c:			dev_err(&spi->dev, "failed to request cs gpio\n");
drivers/spi/spi-meson-spicc.c:	ret = gpio_direction_output(spi->cs_gpio,
drivers/spi/spi-meson-spicc.c:			!(spi->mode & SPI_CS_HIGH));
drivers/spi/spi-meson-spicc.c:	if (gpio_is_valid(spi->cs_gpio))
drivers/spi/spi-meson-spicc.c:		gpio_free(spi->cs_gpio);
drivers/spi/spi-meson-spicc.c:	spi->controller_state = NULL;
drivers/spi/spi-rockchip.c:	struct spi_master *master = spi->master;
drivers/spi/spi-rockchip.c:	if (cs_asserted == rs->cs_asserted[spi->chip_select])
drivers/spi/spi-rockchip.c:				      BIT(spi->chip_select));
drivers/spi/spi-rockchip.c:				      BIT(spi->chip_select));
drivers/spi/spi-rockchip.c:	rs->cs_asserted[spi->chip_select] = cs_asserted;
drivers/spi/spi-rockchip.c:	rs->mode = spi->mode;
drivers/spi/spi-dw-mid.c:#include "spi-dw.h"
drivers/spi/Kconfig:	  based platforms. This driver works for both SPI master for spi-nor
drivers/spi/Kconfig:         will be called spi-dln2.
drivers/spi/.built-in.o.cmd:cmd_drivers/spi/built-in.o :=  rm -f drivers/spi/built-in.o; arm-linux-gnueabi-ar rcSTPD drivers/spi/built-in.o drivers/spi/spi.o drivers/spi/spi-sun6i.o 
drivers/spi/spi-fsl-dspi.c: * drivers/spi/spi-fsl-dspi.c
drivers/spi/spi-fsl-dspi.c:#include <linux/spi/spi-fsl-dspi.h>
drivers/spi/spi-fsl-dspi.c:	regmap_read(dspi->regmap, SPI_CTAR(0), &val);
drivers/spi/spi-fsl-dspi.c:	struct fsl_dspi_dma *dma = dspi->dma;
drivers/spi/spi-fsl-dspi.c:	struct fsl_dspi_dma *dma = dspi->dma;
drivers/spi/spi-fsl-dspi.c:	if (!(dspi->dataflags & TRAN_STATE_RX_VOID)) {
drivers/spi/spi-fsl-dspi.c:			d = dspi->dma->rx_dma_buf[i];
drivers/spi/spi-fsl-dspi.c:			rx_word ? (*(u16 *)dspi->rx = d) :
drivers/spi/spi-fsl-dspi.c:						(*(u8 *)dspi->rx = d);
drivers/spi/spi-fsl-dspi.c:			dspi->rx += rx_word + 1;
drivers/spi/spi-fsl-dspi.c:	struct fsl_dspi_dma *dma = dspi->dma;
drivers/spi/spi-fsl-dspi.c:	struct device *dev = &dspi->pdev->dev;
drivers/spi/spi-fsl-dspi.c:		dspi->dma->tx_dma_buf[i] = dspi_data_to_pushr(dspi, tx_word);
drivers/spi/spi-fsl-dspi.c:		if ((dspi->cs_change) && (!dspi->len))
drivers/spi/spi-fsl-dspi.c:			dspi->dma->tx_dma_buf[i] &= ~SPI_PUSHR_CONT;
drivers/spi/spi-fsl-dspi.c:	reinit_completion(&dspi->dma->cmd_rx_complete);
drivers/spi/spi-fsl-dspi.c:	reinit_completion(&dspi->dma->cmd_tx_complete);
drivers/spi/spi-fsl-dspi.c:	time_left = wait_for_completion_timeout(&dspi->dma->cmd_tx_complete,
drivers/spi/spi-fsl-dspi.c:	time_left = wait_for_completion_timeout(&dspi->dma->cmd_rx_complete,
drivers/spi/spi-fsl-dspi.c:	struct fsl_dspi_dma *dma = dspi->dma;
drivers/spi/spi-fsl-dspi.c:	struct device *dev = &dspi->pdev->dev;
drivers/spi/spi-fsl-dspi.c:	curr_remaining_bytes = dspi->len;
drivers/spi/spi-fsl-dspi.c:	struct device *dev = &dspi->pdev->dev;
drivers/spi/spi-fsl-dspi.c:	dspi->dma = dma;
drivers/spi/spi-fsl-dspi.c:	dspi->dma = NULL;
drivers/spi/spi-fsl-dspi.c:	struct fsl_dspi_dma *dma = dspi->dma;
drivers/spi/spi-fsl-dspi.c:	struct device *dev = &dspi->pdev->dev;
drivers/spi/spi-fsl-dspi.c:	if (!(dspi->dataflags & TRAN_STATE_TX_VOID))
drivers/spi/spi-fsl-dspi.c:		d16 = tx_word ? *(u16 *)dspi->tx : *(u8 *)dspi->tx;
drivers/spi/spi-fsl-dspi.c:		d16 = dspi->void_write_data;
drivers/spi/spi-fsl-dspi.c:	dspi->tx += tx_word + 1;
drivers/spi/spi-fsl-dspi.c:	dspi->len -= tx_word + 1;
drivers/spi/spi-fsl-dspi.c:		SPI_PUSHR_PCS(dspi->cs) |
drivers/spi/spi-fsl-dspi.c:	regmap_read(dspi->regmap, SPI_POPR, &val);
drivers/spi/spi-fsl-dspi.c:	if (!(dspi->dataflags & TRAN_STATE_RX_VOID))
drivers/spi/spi-fsl-dspi.c:		rx_word ? (*(u16 *)dspi->rx = d) : (*(u8 *)dspi->rx = d);
drivers/spi/spi-fsl-dspi.c:	dspi->rx += rx_word + 1;
drivers/spi/spi-fsl-dspi.c:	while (dspi->len && (tx_count < DSPI_FIFO_SIZE)) {
drivers/spi/spi-fsl-dspi.c:		if (tx_word && (dspi->len == 1)) {
drivers/spi/spi-fsl-dspi.c:			dspi->dataflags |= TRAN_STATE_WORD_ODD_NUM;
drivers/spi/spi-fsl-dspi.c:			regmap_update_bits(dspi->regmap, SPI_CTAR(0),
drivers/spi/spi-fsl-dspi.c:		if (dspi->len == 0 || tx_count == DSPI_FIFO_SIZE - 1) {
drivers/spi/spi-fsl-dspi.c:			if ((dspi->cs_change) && (!dspi->len))
drivers/spi/spi-fsl-dspi.c:		} else if (tx_word && (dspi->len == 1))
drivers/spi/spi-fsl-dspi.c:		regmap_write(dspi->regmap, SPI_PUSHR, dspi_pushr);
drivers/spi/spi-fsl-dspi.c:	while ((dspi->rx < dspi->rx_end)
drivers/spi/spi-fsl-dspi.c:		if (rx_word && (dspi->rx_end - dspi->rx) == 1)
drivers/spi/spi-fsl-dspi.c:	if (tx_word && (dspi->len == 1)) {
drivers/spi/spi-fsl-dspi.c:		dspi->dataflags |= TRAN_STATE_WORD_ODD_NUM;
drivers/spi/spi-fsl-dspi.c:		regmap_update_bits(dspi->regmap, SPI_CTAR(0),
drivers/spi/spi-fsl-dspi.c:	if ((dspi->cs_change) && (!dspi->len))
drivers/spi/spi-fsl-dspi.c:	regmap_write(dspi->regmap, SPI_PUSHR, dspi_pushr);
drivers/spi/spi-fsl-dspi.c:	if (rx_word && (dspi->rx_end - dspi->rx) == 1)
drivers/spi/spi-fsl-dspi.c:	regmap_read(dspi->regmap, SPI_TCR, &spi_tcr);
drivers/spi/spi-fsl-dspi.c:	dspi->spi_tcnt = SPI_TCR_GET_TCNT(spi_tcr);
drivers/spi/spi-fsl-dspi.c:		dspi->cur_transfer = transfer;
drivers/spi/spi-fsl-dspi.c:		dspi->cur_msg = message;
drivers/spi/spi-fsl-dspi.c:		dspi->cur_chip = spi_get_ctldata(spi);
drivers/spi/spi-fsl-dspi.c:		dspi->cs = spi->chip_select;
drivers/spi/spi-fsl-dspi.c:		dspi->cs_change = 0;
drivers/spi/spi-fsl-dspi.c:		if (list_is_last(&dspi->cur_transfer->transfer_list,
drivers/spi/spi-fsl-dspi.c:				 &dspi->cur_msg->transfers) || transfer->cs_change)
drivers/spi/spi-fsl-dspi.c:			dspi->cs_change = 1;
drivers/spi/spi-fsl-dspi.c:		dspi->void_write_data = dspi->cur_chip->void_write_data;
drivers/spi/spi-fsl-dspi.c:		dspi->dataflags = 0;
drivers/spi/spi-fsl-dspi.c:		dspi->tx = (void *)transfer->tx_buf;
drivers/spi/spi-fsl-dspi.c:		dspi->tx_end = dspi->tx + transfer->len;
drivers/spi/spi-fsl-dspi.c:		dspi->rx = transfer->rx_buf;
drivers/spi/spi-fsl-dspi.c:		dspi->rx_end = dspi->rx + transfer->len;
drivers/spi/spi-fsl-dspi.c:		dspi->len = transfer->len;
drivers/spi/spi-fsl-dspi.c:		if (!dspi->rx)
drivers/spi/spi-fsl-dspi.c:			dspi->dataflags |= TRAN_STATE_RX_VOID;
drivers/spi/spi-fsl-dspi.c:		if (!dspi->tx)
drivers/spi/spi-fsl-dspi.c:			dspi->dataflags |= TRAN_STATE_TX_VOID;
drivers/spi/spi-fsl-dspi.c:		regmap_write(dspi->regmap, SPI_MCR, dspi->cur_chip->mcr_val);
drivers/spi/spi-fsl-dspi.c:		regmap_update_bits(dspi->regmap, SPI_MCR,
drivers/spi/spi-fsl-dspi.c:		regmap_write(dspi->regmap, SPI_CTAR(0),
drivers/spi/spi-fsl-dspi.c:				dspi->cur_chip->ctar_val);
drivers/spi/spi-fsl-dspi.c:		trans_mode = dspi->devtype_data->trans_mode;
drivers/spi/spi-fsl-dspi.c:			regmap_write(dspi->regmap, SPI_RSER, SPI_RSER_EOQFE);
drivers/spi/spi-fsl-dspi.c:			regmap_write(dspi->regmap, SPI_RSER, SPI_RSER_TCFQE);
drivers/spi/spi-fsl-dspi.c:			regmap_write(dspi->regmap, SPI_RSER,
drivers/spi/spi-fsl-dspi.c:			dev_err(&dspi->pdev->dev, "unsupported trans_mode %u\n",
drivers/spi/spi-fsl-dspi.c:			if (wait_event_interruptible(dspi->waitq,
drivers/spi/spi-fsl-dspi.c:						dspi->waitflags))
drivers/spi/spi-fsl-dspi.c:				dev_err(&dspi->pdev->dev,
drivers/spi/spi-fsl-dspi.c:			dspi->waitflags = 0;
drivers/spi/spi-fsl-dspi.c:	struct fsl_dspi *dspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-fsl-dspi.c:	if ((spi->bits_per_word >= 4) && (spi->bits_per_word <= 16)) {
drivers/spi/spi-fsl-dspi.c:		fmsz = spi->bits_per_word - 1;
drivers/spi/spi-fsl-dspi.c:	pdata = dev_get_platdata(&dspi->pdev->dev);
drivers/spi/spi-fsl-dspi.c:		of_property_read_u32(spi->dev.of_node, "fsl,spi-cs-sck-delay",
drivers/spi/spi-fsl-dspi.c:		of_property_read_u32(spi->dev.of_node, "fsl,spi-sck-cs-delay",
drivers/spi/spi-fsl-dspi.c:	clkrate = clk_get_rate(dspi->clk);
drivers/spi/spi-fsl-dspi.c:	hz_to_spi_baud(&pbr, &br, spi->max_speed_hz, clkrate);
drivers/spi/spi-fsl-dspi.c:		| SPI_CTAR_CPOL(spi->mode & SPI_CPOL ? 1 : 0)
drivers/spi/spi-fsl-dspi.c:		| SPI_CTAR_CPHA(spi->mode & SPI_CPHA ? 1 : 0)
drivers/spi/spi-fsl-dspi.c:		| SPI_CTAR_LSBFE(spi->mode & SPI_LSB_FIRST ? 1 : 0)
drivers/spi/spi-fsl-dspi.c:	dev_dbg(&spi->dev, "spi_device %u.%u cleanup\n",
drivers/spi/spi-fsl-dspi.c:			spi->master->bus_num, spi->chip_select);
drivers/spi/spi-fsl-dspi.c:	struct spi_message *msg = dspi->cur_msg;
drivers/spi/spi-fsl-dspi.c:	regmap_read(dspi->regmap, SPI_SR, &spi_sr);
drivers/spi/spi-fsl-dspi.c:	regmap_write(dspi->regmap, SPI_SR, spi_sr);
drivers/spi/spi-fsl-dspi.c:		regmap_read(dspi->regmap, SPI_TCR, &spi_tcr);
drivers/spi/spi-fsl-dspi.c:		 * spi_tcnt my be less than dspi->spi_tcnt, it means the
drivers/spi/spi-fsl-dspi.c:		tcnt_diff = ((spi_tcnt + SPI_TCR_TCNT_MAX) - dspi->spi_tcnt)
drivers/spi/spi-fsl-dspi.c:		if (dspi->dataflags & TRAN_STATE_WORD_ODD_NUM)
drivers/spi/spi-fsl-dspi.c:		dspi->spi_tcnt = spi_tcnt;
drivers/spi/spi-fsl-dspi.c:		trans_mode = dspi->devtype_data->trans_mode;
drivers/spi/spi-fsl-dspi.c:			dev_err(&dspi->pdev->dev, "unsupported trans_mode %u\n",
drivers/spi/spi-fsl-dspi.c:		if (!dspi->len) {
drivers/spi/spi-fsl-dspi.c:			if (dspi->dataflags & TRAN_STATE_WORD_ODD_NUM) {
drivers/spi/spi-fsl-dspi.c:				regmap_update_bits(dspi->regmap,
drivers/spi/spi-fsl-dspi.c:				dspi->dataflags &= ~TRAN_STATE_WORD_ODD_NUM;
drivers/spi/spi-fsl-dspi.c:			dspi->waitflags = 1;
drivers/spi/spi-fsl-dspi.c:			wake_up_interruptible(&dspi->waitq);
drivers/spi/spi-fsl-dspi.c:				dev_err(&dspi->pdev->dev,
drivers/spi/spi-fsl-dspi.c:	clk_disable_unprepare(dspi->clk);
drivers/spi/spi-fsl-dspi.c:	ret = clk_prepare_enable(dspi->clk);
drivers/spi/spi-fsl-dspi.c:	regmap_write(dspi->regmap, SPI_SR, SPI_SR_CLEAR);
drivers/spi/spi-fsl-dspi.c:	dspi->pdev = pdev;
drivers/spi/spi-fsl-dspi.c:	dspi->master = master;
drivers/spi/spi-fsl-dspi.c:		dspi->devtype_data = &coldfire_data;
drivers/spi/spi-fsl-dspi.c:		ret = of_property_read_u32(np, "spi-num-chipselects", &cs_num);
drivers/spi/spi-fsl-dspi.c:			dev_err(&pdev->dev, "can't get spi-num-chipselects\n");
drivers/spi/spi-fsl-dspi.c:		dspi->devtype_data = of_device_get_match_data(&pdev->dev);
drivers/spi/spi-fsl-dspi.c:		if (!dspi->devtype_data) {
drivers/spi/spi-fsl-dspi.c:	dspi->regmap = devm_regmap_init_mmio_clk(&pdev->dev, NULL, base,
drivers/spi/spi-fsl-dspi.c:	if (IS_ERR(dspi->regmap)) {
drivers/spi/spi-fsl-dspi.c:				PTR_ERR(dspi->regmap));
drivers/spi/spi-fsl-dspi.c:		ret = PTR_ERR(dspi->regmap);
drivers/spi/spi-fsl-dspi.c:	dspi->irq = platform_get_irq(pdev, 0);
drivers/spi/spi-fsl-dspi.c:	if (dspi->irq < 0) {
drivers/spi/spi-fsl-dspi.c:		ret = dspi->irq;
drivers/spi/spi-fsl-dspi.c:	ret = devm_request_irq(&pdev->dev, dspi->irq, dspi_interrupt, 0,
drivers/spi/spi-fsl-dspi.c:	dspi->clk = devm_clk_get(&pdev->dev, "dspi");
drivers/spi/spi-fsl-dspi.c:	if (IS_ERR(dspi->clk)) {
drivers/spi/spi-fsl-dspi.c:		ret = PTR_ERR(dspi->clk);
drivers/spi/spi-fsl-dspi.c:	ret = clk_prepare_enable(dspi->clk);
drivers/spi/spi-fsl-dspi.c:	if (dspi->devtype_data->trans_mode == DSPI_DMA_MODE) {
drivers/spi/spi-fsl-dspi.c:		clk_get_rate(dspi->clk) / dspi->devtype_data->max_clock_factor;
drivers/spi/spi-fsl-dspi.c:	init_waitqueue_head(&dspi->waitq);
drivers/spi/spi-fsl-dspi.c:	clk_disable_unprepare(dspi->clk);
drivers/spi/spi-fsl-dspi.c:	clk_disable_unprepare(dspi->clk);
drivers/spi/spi-fsl-dspi.c:	spi_unregister_master(dspi->master);
drivers/spi/spi-pl022.c:	pl022->cur_cs = pl022->chipselects[msg->spi->chip_select];
drivers/spi/spi-pl022.c:	struct pl022 *pl022 = spi_master_get_devdata(spi->master);
drivers/spi/spi-pl022.c:	unsigned int bits = spi->bits_per_word;
drivers/spi/spi-pl022.c:	struct device_node *np = spi->dev.of_node;
drivers/spi/spi-pl022.c:	if (!spi->max_speed_hz)
drivers/spi/spi-pl022.c:		dev_dbg(&spi->dev,
drivers/spi/spi-pl022.c:	chip_info = spi->controller_data;
drivers/spi/spi-pl022.c:			dev_dbg(&spi->dev,
drivers/spi/spi-pl022.c:		dev_dbg(&spi->dev,
drivers/spi/spi-pl022.c:						  spi->max_speed_hz,
drivers/spi/spi-pl022.c:		dev_err(&spi->dev,
drivers/spi/spi-pl022.c:		dev_err(&spi->dev, "controller data is incorrect");
drivers/spi/spi-pl022.c:		if (!gpio_is_valid(pl022->chipselects[spi->chip_select]))
drivers/spi/spi-pl022.c:			dev_warn(&spi->dev,
drivers/spi/spi-pl022.c:		dev_err(&spi->dev, "illegal data size for this controller!\n");
drivers/spi/spi-pl022.c:		dev_err(&spi->dev, "This controller can only handle 4 <= n <= %d bit words\n",
drivers/spi/spi-pl022.c:		dev_dbg(&spi->dev, "4 <= n <=8 bits per word\n");
drivers/spi/spi-pl022.c:		dev_dbg(&spi->dev, "9 <= n <= 16 bits per word\n");
drivers/spi/spi-pl022.c:		dev_dbg(&spi->dev, "17 <= n <= 32 bits per word\n");
drivers/spi/spi-pl022.c:		dev_dbg(&spi->dev, "DMA mode set in controller state\n");
drivers/spi/spi-pl022.c:		dev_dbg(&spi->dev, "DMA mode NOT set in controller state\n");
drivers/spi/spi-pl022.c:		if (spi->mode & SPI_LSB_FIRST) {
drivers/spi/spi-pl022.c:	if (spi->mode & SPI_CPOL)
drivers/spi/spi-pl022.c:	if (spi->mode & SPI_CPHA)
drivers/spi/spi-pl022.c:		if (spi->mode & SPI_LOOP)
drivers/spi/spi-ath79.c: * This driver has been based on the spi-gpio.c:
drivers/spi/spi-ath79.c:	return spi_master_get_devdata(spi->master);
drivers/spi/spi-ath79.c:	int cs_high = (spi->mode & SPI_CS_HIGH) ? is_active : !is_active;
drivers/spi/spi-ath79.c:		if (spi->mode & SPI_CPOL)
drivers/spi/spi-ath79.c:	if (gpio_is_valid(spi->cs_gpio)) {
drivers/spi/spi-ath79.c:		gpio_set_value_cansleep(spi->cs_gpio, cs_high);
drivers/spi/spi-ath79.c:		u32 cs_bit = AR71XX_SPI_IOC_CS(spi->chip_select);
drivers/spi/spi-ath79.c:	if (gpio_is_valid(spi->cs_gpio)) {
drivers/spi/spi-ath79.c:		if (spi->mode & SPI_CS_HIGH)
drivers/spi/spi-ath79.c:		status = gpio_request_one(spi->cs_gpio, flags,
drivers/spi/spi-ath79.c:					  dev_name(&spi->dev));
drivers/spi/spi-ath79.c:		u32 cs_bit = AR71XX_SPI_IOC_CS(spi->chip_select);
drivers/spi/spi-ath79.c:		if (spi->mode & SPI_CS_HIGH)
drivers/spi/spi-ath79.c:	if (gpio_is_valid(spi->cs_gpio))
drivers/spi/spi-ath79.c:		gpio_free(spi->cs_gpio);
drivers/spi/spi-ath79.c:	if (!spi->controller_state) {
drivers/spi/spi-ath79.c:	if (status && !spi->controller_state)
drivers/spi/spi-bcm63xx-hsspi.c:	unsigned int profile = spi->chip_select;
drivers/spi/spi-bcm63xx-hsspi.c:	if (spi->mode & SPI_CPOL)
drivers/spi/spi-bcm63xx-hsspi.c:	struct bcm63xx_hsspi *bs = spi_master_get_devdata(spi->master);
drivers/spi/spi-bcm63xx-hsspi.c:	unsigned int chip_select = spi->chip_select;
drivers/spi/spi-bcm63xx-hsspi.c:	bcm63xx_hsspi_set_cs(bs, spi->chip_select, true);
drivers/spi/spi-bcm63xx-hsspi.c:	struct bcm63xx_hsspi *bs = spi_master_get_devdata(spi->master);
drivers/spi/spi-bcm63xx-hsspi.c:			  HSSPI_PROFILE_SIGNAL_CTRL_REG(spi->chip_select));
drivers/spi/spi-bcm63xx-hsspi.c:	if (spi->mode & SPI_CPHA)
drivers/spi/spi-bcm63xx-hsspi.c:		     HSSPI_PROFILE_SIGNAL_CTRL_REG(spi->chip_select));
drivers/spi/spi-bcm63xx-hsspi.c:		if (spi->mode & SPI_CS_HIGH)
drivers/spi/spi-bcm63xx-hsspi.c:			reg |= BIT(spi->chip_select);
drivers/spi/spi-bcm63xx-hsspi.c:			reg &= ~BIT(spi->chip_select);
drivers/spi/spi-bcm63xx-hsspi.c:	if (spi->mode & SPI_CS_HIGH)
drivers/spi/spi-bcm63xx-hsspi.c:		bs->cs_polarity |= BIT(spi->chip_select);
drivers/spi/spi-bcm63xx-hsspi.c:		bs->cs_polarity &= ~BIT(spi->chip_select);
drivers/spi/spi-bcm63xx-hsspi.c:	dummy_cs = !spi->chip_select;
drivers/spi/spi-bcm63xx-hsspi.c:			bcm63xx_hsspi_set_cs(bs, spi->chip_select, false);
drivers/spi/spi-dln2.c:	if (dln2->cs != spi->chip_select) {
drivers/spi/spi-dln2.c:		ret = dln2_spi_cs_set_one(dln2, spi->chip_select);
drivers/spi/spi-dln2.c:		dln2->cs = spi->chip_select;
drivers/spi/spi-dln2.c:					 spi->mode);
Binary file drivers/spi/spi-gpio.o matches
drivers/spi/spi-xlp.c:	xspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-xlp.c:	cs = spi->chip_select;
drivers/spi/spi-xlp.c:	fdiv = DIV_ROUND_UP(xspi->spi_clk, spi->max_speed_hz);
drivers/spi/spi-xlp.c:	if (spi->mode & SPI_CPHA)
drivers/spi/spi-xlp.c:	if (spi->mode & SPI_CPOL)
drivers/spi/spi-xlp.c:	if (!(spi->mode & SPI_CS_HIGH))
drivers/spi/spi-xlp.c:	if (spi->mode & SPI_LSB_FIRST)
drivers/spi/spi-xlp.c:	rxfifo_cnt = xlp_spi_reg_read(xspi, xspi->cs, XLP_SPI_FIFO_WCNT);
drivers/spi/spi-xlp.c:		rx_data = xlp_spi_reg_read(xspi, xspi->cs, XLP_SPI_RXDATA_FIFO);
drivers/spi/spi-xlp.c:		nbytes = min(xspi->rx_len, 4);
drivers/spi/spi-xlp.c:			xspi->rx_buf[i] = (rx_data >> (j * 8)) & 0xff;
drivers/spi/spi-xlp.c:		xspi->rx_len -= nbytes;
drivers/spi/spi-xlp.c:		xspi->rx_buf += nbytes;
drivers/spi/spi-xlp.c:	txfifo_cnt = xlp_spi_reg_read(xspi, xspi->cs, XLP_SPI_FIFO_WCNT);
drivers/spi/spi-xlp.c:	while (xspi->tx_len && (txfifo_cnt < XLP_SPI_FIFO_SIZE)) {
drivers/spi/spi-xlp.c:		nbytes = min(xspi->tx_len, 4);
drivers/spi/spi-xlp.c:			tx_data |= xspi->tx_buf[i] << (j * 8);
drivers/spi/spi-xlp.c:		xlp_spi_reg_write(xspi, xspi->cs, XLP_SPI_TXDATA_FIFO, tx_data);
drivers/spi/spi-xlp.c:		xspi->tx_len -= nbytes;
drivers/spi/spi-xlp.c:		xspi->tx_buf += nbytes;
drivers/spi/spi-xlp.c:	stat = xlp_spi_reg_read(xspi, xspi->cs, XLP_SPI_STATUS) &
drivers/spi/spi-xlp.c:		if (xspi->tx_len)
drivers/spi/spi-xlp.c:			xspi->txerrors++;
drivers/spi/spi-xlp.c:		if (xspi->rx_len)
drivers/spi/spi-xlp.c:			xspi->rxerrors++;
drivers/spi/spi-xlp.c:	xlp_spi_reg_write(xspi, xspi->cs, XLP_SPI_STATUS, stat);
drivers/spi/spi-xlp.c:		complete(&xspi->done);
drivers/spi/spi-xlp.c:	if (xspi->tx_buf)
drivers/spi/spi-xlp.c:	if (xspi->rx_buf)
drivers/spi/spi-xlp.c:	xlp_spi_reg_write(xspi, xspi->cs, XLP_SPI_CMD, cmd);
drivers/spi/spi-xlp.c:	xspi->cs = spi->chip_select;
drivers/spi/spi-xlp.c:	xspi->dev = spi->dev;
drivers/spi/spi-xlp.c:		xspi->cmd_cont = 0;
drivers/spi/spi-xlp.c:		xspi->cmd_cont = 1;
drivers/spi/spi-xlp.c:	xspi->base = devm_ioremap_resource(&pdev->dev, res);
drivers/spi/spi-xlp.c:	if (IS_ERR(xspi->base))
drivers/spi/spi-xlp.c:		return PTR_ERR(xspi->base);
drivers/spi/spi-xlp.c:	xspi->spi_clk = clk_get_rate(clk);
drivers/spi/spi-xlp.c:	init_completion(&xspi->done);
drivers/spi/spi-rb4xx.c:	return __raw_readl(rbspi->base + reg);
drivers/spi/spi-rb4xx.c:	__raw_writel(value, rbspi->base + reg);
drivers/spi/spi-rb4xx.c:	struct rb4xx_spi *rbspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-rb4xx.c:	if (spi->chip_select == 2)
drivers/spi/spi-rb4xx.c:	rbspi->base = spi_base;
drivers/spi/spi-rb4xx.c:	rbspi->clk = ahb_clk;
drivers/spi/spi-rb4xx.c:	clk_disable_unprepare(rbspi->clk);
drivers/spi/spi-pxa2xx.c:#include "spi-pxa2xx.h"
drivers/spi/spi-pxa2xx.c:	cs = drv_data->master->cur_msg->spi->chip_select;
drivers/spi/spi-pxa2xx.c:		dev_warn_ratelimited(&message->spi->dev,
drivers/spi/spi-pxa2xx.c:			dev_warn_ratelimited(&message->spi->dev,
drivers/spi/spi-pxa2xx.c:		dev_dbg(&message->spi->dev, "%u Hz actual, %s\n",
drivers/spi/spi-pxa2xx.c:		dev_dbg(&message->spi->dev, "%u Hz actual, %s\n",
drivers/spi/spi-pxa2xx.c:	struct driver_data *drv_data = spi_master_get_devdata(spi->master);
drivers/spi/spi-pxa2xx.c:		gpiod = drv_data->cs_gpiods[spi->chip_select];
drivers/spi/spi-pxa2xx.c:			chip->gpio_cs_inverted = spi->mode & SPI_CS_HIGH;
drivers/spi/spi-pxa2xx.c:			dev_err(&spi->dev, "failed to request chip select GPIO%d\n",
drivers/spi/spi-pxa2xx.c:		chip->gpio_cs_inverted = spi->mode & SPI_CS_HIGH;
drivers/spi/spi-pxa2xx.c:	struct driver_data *drv_data = spi_master_get_devdata(spi->master);
drivers/spi/spi-pxa2xx.c:			if (spi->chip_select > 4) {
drivers/spi/spi-pxa2xx.c:				dev_err(&spi->dev,
drivers/spi/spi-pxa2xx.c:			chip->frm = spi->chip_select;
drivers/spi/spi-pxa2xx.c:	chip_info = spi->controller_data;
drivers/spi/spi-pxa2xx.c:						spi->bits_per_word,
drivers/spi/spi-pxa2xx.c:			dev_warn(&spi->dev,
drivers/spi/spi-pxa2xx.c:	chip->cr1 |= (((spi->mode & SPI_CPHA) != 0) ? SSCR1_SPH : 0)
drivers/spi/spi-pxa2xx.c:			| (((spi->mode & SPI_CPOL) != 0) ? SSCR1_SPO : 0);
drivers/spi/spi-pxa2xx.c:	if (spi->mode & SPI_LOOP)
drivers/spi/spi-pxa2xx.c:	if (spi->bits_per_word <= 8) {
drivers/spi/spi-pxa2xx.c:	} else if (spi->bits_per_word <= 16) {
drivers/spi/spi-pxa2xx.c:	} else if (spi->bits_per_word <= 32) {
drivers/spi/spi-pxa2xx.c:	struct driver_data *drv_data = spi_master_get_devdata(spi->master);
drivers/spi/spi-pxa2xx.c:	/* the spi->mode bits understood by this driver: */
drivers/spi/spi-adi-v3.c:	drv_data->tx_dma_addr = dma_map_single(&msg->spi->dev,
drivers/spi/spi-adi-v3.c:	if (dma_mapping_error(&msg->spi->dev,
drivers/spi/spi-adi-v3.c:	drv_data->rx_dma_addr = dma_map_single(&msg->spi->dev,
drivers/spi/spi-adi-v3.c:	if (dma_mapping_error(&msg->spi->dev,
drivers/spi/spi-adi-v3.c:		dma_unmap_single(&msg->spi->dev,
drivers/spi/spi-adi-v3.c:	struct adi_spi_master *drv_data = spi_master_get_devdata(spi->master);
drivers/spi/spi-adi-v3.c:		struct adi_spi3_chip *chip_info = spi->controller_data;
drivers/spi/spi-adi-v3.c:				dev_err(&spi->dev,
drivers/spi/spi-adi-v3.c:		chip->cs = spi->chip_select;
drivers/spi/spi-adi-v3.c:			ret = peripheral_request(ssel[spi->master->bus_num]
drivers/spi/spi-adi-v3.c:					[chip->cs-1], dev_name(&spi->dev));
drivers/spi/spi-adi-v3.c:				dev_err(&spi->dev, "peripheral_request() error\n");
drivers/spi/spi-adi-v3.c:						dev_name(&spi->dev));
drivers/spi/spi-adi-v3.c:				dev_err(&spi->dev, "gpio_request_one() error\n");
drivers/spi/spi-adi-v3.c:	if (spi->mode & SPI_CPOL)
drivers/spi/spi-adi-v3.c:	if (spi->mode & SPI_CPHA)
drivers/spi/spi-adi-v3.c:	if (spi->mode & SPI_LSB_FIRST)
drivers/spi/spi-adi-v3.c:	chip->clock = hz_to_spi_clock(drv_data->sclk, spi->max_speed_hz);
drivers/spi/spi-adi-v3.c:	struct adi_spi_master *drv_data = spi_master_get_devdata(spi->master);
drivers/spi/spi-adi-v3.c:		peripheral_free(ssel[spi->master->bus_num]
Binary file drivers/spi/spi-sun6i.o matches
drivers/spi/spi-tegra20-slink.c:	return readl(tspi->base + reg);
drivers/spi/spi-tegra20-slink.c:	writel(val, tspi->base + reg);
drivers/spi/spi-tegra20-slink.c:		readl(tspi->base + SLINK_MAS_DATA);
drivers/spi/spi-tegra20-slink.c:	switch (tspi->bytes_per_word) {
drivers/spi/spi-tegra20-slink.c:	unsigned remain_len = t->len - tspi->cur_pos;
drivers/spi/spi-tegra20-slink.c:	tspi->bytes_per_word = DIV_ROUND_UP(bits_per_word, 8);
drivers/spi/spi-tegra20-slink.c:		tspi->is_packed = 1;
drivers/spi/spi-tegra20-slink.c:		tspi->words_per_32bit = 32/bits_per_word;
drivers/spi/spi-tegra20-slink.c:		tspi->is_packed = 0;
drivers/spi/spi-tegra20-slink.c:		tspi->words_per_32bit = 1;
drivers/spi/spi-tegra20-slink.c:	tspi->packed_size = tegra_slink_get_packed_size(tspi, t);
drivers/spi/spi-tegra20-slink.c:	if (tspi->is_packed) {
drivers/spi/spi-tegra20-slink.c:		max_len = min(remain_len, tspi->max_buf_size);
drivers/spi/spi-tegra20-slink.c:		tspi->curr_dma_words = max_len/tspi->bytes_per_word;
drivers/spi/spi-tegra20-slink.c:		max_word = (remain_len - 1) / tspi->bytes_per_word + 1;
drivers/spi/spi-tegra20-slink.c:		max_word = min(max_word, tspi->max_buf_size/4);
drivers/spi/spi-tegra20-slink.c:		tspi->curr_dma_words = max_word;
drivers/spi/spi-tegra20-slink.c:	u8 *tx_buf = (u8 *)t->tx_buf + tspi->cur_tx_pos;
drivers/spi/spi-tegra20-slink.c:	if (tspi->is_packed) {
drivers/spi/spi-tegra20-slink.c:		fifo_words_left = tx_empty_count * tspi->words_per_32bit;
drivers/spi/spi-tegra20-slink.c:		written_words = min(fifo_words_left, tspi->curr_dma_words);
drivers/spi/spi-tegra20-slink.c:		nbytes = written_words * tspi->bytes_per_word;
drivers/spi/spi-tegra20-slink.c:		max_n_32bit = min(tspi->curr_dma_words,  tx_empty_count);
drivers/spi/spi-tegra20-slink.c:		nbytes = written_words * tspi->bytes_per_word;
drivers/spi/spi-tegra20-slink.c:			for (i = 0; nbytes && (i < tspi->bytes_per_word);
drivers/spi/spi-tegra20-slink.c:	tspi->cur_tx_pos += written_words * tspi->bytes_per_word;
drivers/spi/spi-tegra20-slink.c:	u8 *rx_buf = (u8 *)t->rx_buf + tspi->cur_rx_pos;
drivers/spi/spi-tegra20-slink.c:	if (tspi->is_packed) {
drivers/spi/spi-tegra20-slink.c:		len = tspi->curr_dma_words * tspi->bytes_per_word;
drivers/spi/spi-tegra20-slink.c:		tspi->cur_rx_pos += tspi->curr_dma_words * tspi->bytes_per_word;
drivers/spi/spi-tegra20-slink.c:		read_words += tspi->curr_dma_words;
drivers/spi/spi-tegra20-slink.c:			for (i = 0; (i < tspi->bytes_per_word); i++)
drivers/spi/spi-tegra20-slink.c:		tspi->cur_rx_pos += rx_full_count * tspi->bytes_per_word;
drivers/spi/spi-tegra20-slink.c:	dma_sync_single_for_cpu(tspi->dev, tspi->tx_dma_phys,
drivers/spi/spi-tegra20-slink.c:				tspi->dma_buf_size, DMA_TO_DEVICE);
drivers/spi/spi-tegra20-slink.c:	if (tspi->is_packed) {
drivers/spi/spi-tegra20-slink.c:		unsigned len = tspi->curr_dma_words * tspi->bytes_per_word;
drivers/spi/spi-tegra20-slink.c:		memcpy(tspi->tx_dma_buf, t->tx_buf + tspi->cur_pos, len);
drivers/spi/spi-tegra20-slink.c:		u8 *tx_buf = (u8 *)t->tx_buf + tspi->cur_tx_pos;
drivers/spi/spi-tegra20-slink.c:		unsigned consume = tspi->curr_dma_words * tspi->bytes_per_word;
drivers/spi/spi-tegra20-slink.c:		for (count = 0; count < tspi->curr_dma_words; count++) {
drivers/spi/spi-tegra20-slink.c:			for (i = 0; consume && (i < tspi->bytes_per_word);
drivers/spi/spi-tegra20-slink.c:			tspi->tx_dma_buf[count] = x;
drivers/spi/spi-tegra20-slink.c:	tspi->cur_tx_pos += tspi->curr_dma_words * tspi->bytes_per_word;
drivers/spi/spi-tegra20-slink.c:	dma_sync_single_for_device(tspi->dev, tspi->tx_dma_phys,
drivers/spi/spi-tegra20-slink.c:				tspi->dma_buf_size, DMA_TO_DEVICE);
drivers/spi/spi-tegra20-slink.c:	dma_sync_single_for_cpu(tspi->dev, tspi->rx_dma_phys,
drivers/spi/spi-tegra20-slink.c:		tspi->dma_buf_size, DMA_FROM_DEVICE);
drivers/spi/spi-tegra20-slink.c:	if (tspi->is_packed) {
drivers/spi/spi-tegra20-slink.c:		len = tspi->curr_dma_words * tspi->bytes_per_word;
drivers/spi/spi-tegra20-slink.c:		memcpy(t->rx_buf + tspi->cur_rx_pos, tspi->rx_dma_buf, len);
drivers/spi/spi-tegra20-slink.c:		unsigned char *rx_buf = t->rx_buf + tspi->cur_rx_pos;
drivers/spi/spi-tegra20-slink.c:		for (count = 0; count < tspi->curr_dma_words; count++) {
drivers/spi/spi-tegra20-slink.c:			u32 x = tspi->rx_dma_buf[count] & rx_mask;
drivers/spi/spi-tegra20-slink.c:			for (i = 0; (i < tspi->bytes_per_word); i++)
drivers/spi/spi-tegra20-slink.c:	tspi->cur_rx_pos += tspi->curr_dma_words * tspi->bytes_per_word;
drivers/spi/spi-tegra20-slink.c:	dma_sync_single_for_device(tspi->dev, tspi->rx_dma_phys,
drivers/spi/spi-tegra20-slink.c:		tspi->dma_buf_size, DMA_FROM_DEVICE);
drivers/spi/spi-tegra20-slink.c:	reinit_completion(&tspi->tx_dma_complete);
drivers/spi/spi-tegra20-slink.c:	tspi->tx_dma_desc = dmaengine_prep_slave_single(tspi->tx_dma_chan,
drivers/spi/spi-tegra20-slink.c:				tspi->tx_dma_phys, len, DMA_MEM_TO_DEV,
drivers/spi/spi-tegra20-slink.c:	if (!tspi->tx_dma_desc) {
drivers/spi/spi-tegra20-slink.c:		dev_err(tspi->dev, "Not able to get desc for Tx\n");
drivers/spi/spi-tegra20-slink.c:	tspi->tx_dma_desc->callback = tegra_slink_dma_complete;
drivers/spi/spi-tegra20-slink.c:	tspi->tx_dma_desc->callback_param = &tspi->tx_dma_complete;
drivers/spi/spi-tegra20-slink.c:	dmaengine_submit(tspi->tx_dma_desc);
drivers/spi/spi-tegra20-slink.c:	dma_async_issue_pending(tspi->tx_dma_chan);
drivers/spi/spi-tegra20-slink.c:	reinit_completion(&tspi->rx_dma_complete);
drivers/spi/spi-tegra20-slink.c:	tspi->rx_dma_desc = dmaengine_prep_slave_single(tspi->rx_dma_chan,
drivers/spi/spi-tegra20-slink.c:				tspi->rx_dma_phys, len, DMA_DEV_TO_MEM,
drivers/spi/spi-tegra20-slink.c:	if (!tspi->rx_dma_desc) {
drivers/spi/spi-tegra20-slink.c:		dev_err(tspi->dev, "Not able to get desc for Rx\n");
drivers/spi/spi-tegra20-slink.c:	tspi->rx_dma_desc->callback = tegra_slink_dma_complete;
drivers/spi/spi-tegra20-slink.c:	tspi->rx_dma_desc->callback_param = &tspi->rx_dma_complete;
drivers/spi/spi-tegra20-slink.c:	dmaengine_submit(tspi->rx_dma_desc);
drivers/spi/spi-tegra20-slink.c:	dma_async_issue_pending(tspi->rx_dma_chan);
drivers/spi/spi-tegra20-slink.c:		dev_err(tspi->dev, "Rx/Tx fifo are not empty status 0x%08x\n",
drivers/spi/spi-tegra20-slink.c:	val = SLINK_DMA_BLOCK_SIZE(tspi->curr_dma_words - 1);
drivers/spi/spi-tegra20-slink.c:	val |= tspi->packed_size;
drivers/spi/spi-tegra20-slink.c:	if (tspi->is_packed)
drivers/spi/spi-tegra20-slink.c:		len = DIV_ROUND_UP(tspi->curr_dma_words * tspi->bytes_per_word,
drivers/spi/spi-tegra20-slink.c:		len = tspi->curr_dma_words * 4;
drivers/spi/spi-tegra20-slink.c:	if (tspi->cur_direction & DATA_DIR_TX)
drivers/spi/spi-tegra20-slink.c:	if (tspi->cur_direction & DATA_DIR_RX)
drivers/spi/spi-tegra20-slink.c:	tspi->dma_control_reg = val;
drivers/spi/spi-tegra20-slink.c:	if (tspi->cur_direction & DATA_DIR_TX) {
drivers/spi/spi-tegra20-slink.c:			dev_err(tspi->dev,
drivers/spi/spi-tegra20-slink.c:	if (tspi->cur_direction & DATA_DIR_RX) {
drivers/spi/spi-tegra20-slink.c:		dma_sync_single_for_device(tspi->dev, tspi->rx_dma_phys,
drivers/spi/spi-tegra20-slink.c:				tspi->dma_buf_size, DMA_FROM_DEVICE);
drivers/spi/spi-tegra20-slink.c:			dev_err(tspi->dev,
drivers/spi/spi-tegra20-slink.c:			if (tspi->cur_direction & DATA_DIR_TX)
drivers/spi/spi-tegra20-slink.c:				dmaengine_terminate_all(tspi->tx_dma_chan);
drivers/spi/spi-tegra20-slink.c:	tspi->is_curr_dma_xfer = true;
drivers/spi/spi-tegra20-slink.c:	if (tspi->is_packed) {
drivers/spi/spi-tegra20-slink.c:	tspi->dma_control_reg = val;
drivers/spi/spi-tegra20-slink.c:	val = tspi->packed_size;
drivers/spi/spi-tegra20-slink.c:	if (tspi->cur_direction & DATA_DIR_TX)
drivers/spi/spi-tegra20-slink.c:	if (tspi->cur_direction & DATA_DIR_RX)
drivers/spi/spi-tegra20-slink.c:	tspi->dma_control_reg = val;
drivers/spi/spi-tegra20-slink.c:	if (tspi->cur_direction & DATA_DIR_TX)
drivers/spi/spi-tegra20-slink.c:		cur_words = tspi->curr_dma_words;
drivers/spi/spi-tegra20-slink.c:	tspi->dma_control_reg = val;
drivers/spi/spi-tegra20-slink.c:	tspi->is_curr_dma_xfer = false;
drivers/spi/spi-tegra20-slink.c:	if (tspi->is_packed) {
drivers/spi/spi-tegra20-slink.c:	tspi->dma_control_reg = val;
drivers/spi/spi-tegra20-slink.c:	dma_chan = dma_request_slave_channel_reason(tspi->dev,
drivers/spi/spi-tegra20-slink.c:			dev_err(tspi->dev,
drivers/spi/spi-tegra20-slink.c:	dma_buf = dma_alloc_coherent(tspi->dev, tspi->dma_buf_size,
drivers/spi/spi-tegra20-slink.c:		dev_err(tspi->dev, " Not able to allocate the dma buffer\n");
drivers/spi/spi-tegra20-slink.c:		dma_sconfig.src_addr = tspi->phys + SLINK_RX_FIFO;
drivers/spi/spi-tegra20-slink.c:		dma_sconfig.dst_addr = tspi->phys + SLINK_TX_FIFO;
drivers/spi/spi-tegra20-slink.c:		tspi->rx_dma_chan = dma_chan;
drivers/spi/spi-tegra20-slink.c:		tspi->rx_dma_buf = dma_buf;
drivers/spi/spi-tegra20-slink.c:		tspi->rx_dma_phys = dma_phys;
drivers/spi/spi-tegra20-slink.c:		tspi->tx_dma_chan = dma_chan;
drivers/spi/spi-tegra20-slink.c:		tspi->tx_dma_buf = dma_buf;
drivers/spi/spi-tegra20-slink.c:		tspi->tx_dma_phys = dma_phys;
drivers/spi/spi-tegra20-slink.c:	dma_free_coherent(tspi->dev, tspi->dma_buf_size, dma_buf, dma_phys);
drivers/spi/spi-tegra20-slink.c:		dma_buf = tspi->rx_dma_buf;
drivers/spi/spi-tegra20-slink.c:		dma_chan = tspi->rx_dma_chan;
drivers/spi/spi-tegra20-slink.c:		dma_phys = tspi->rx_dma_phys;
drivers/spi/spi-tegra20-slink.c:		tspi->rx_dma_chan = NULL;
drivers/spi/spi-tegra20-slink.c:		tspi->rx_dma_buf = NULL;
drivers/spi/spi-tegra20-slink.c:		dma_buf = tspi->tx_dma_buf;
drivers/spi/spi-tegra20-slink.c:		dma_chan = tspi->tx_dma_chan;
drivers/spi/spi-tegra20-slink.c:		dma_phys = tspi->tx_dma_phys;
drivers/spi/spi-tegra20-slink.c:		tspi->tx_dma_buf = NULL;
drivers/spi/spi-tegra20-slink.c:		tspi->tx_dma_chan = NULL;
drivers/spi/spi-tegra20-slink.c:	dma_free_coherent(tspi->dev, tspi->dma_buf_size, dma_buf, dma_phys);
drivers/spi/spi-tegra20-slink.c:	struct tegra_slink_data *tspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-tegra20-slink.c:	if (speed != tspi->cur_speed) {
drivers/spi/spi-tegra20-slink.c:		clk_set_rate(tspi->clk, speed * 4);
drivers/spi/spi-tegra20-slink.c:		tspi->cur_speed = speed;
drivers/spi/spi-tegra20-slink.c:	tspi->cur_spi = spi;
drivers/spi/spi-tegra20-slink.c:	tspi->cur_pos = 0;
drivers/spi/spi-tegra20-slink.c:	tspi->cur_rx_pos = 0;
drivers/spi/spi-tegra20-slink.c:	tspi->cur_tx_pos = 0;
drivers/spi/spi-tegra20-slink.c:	tspi->curr_xfer = t;
drivers/spi/spi-tegra20-slink.c:	command = tspi->command_reg;
drivers/spi/spi-tegra20-slink.c:	command2 = tspi->command2_reg;
drivers/spi/spi-tegra20-slink.c:	tspi->command_reg = command;
drivers/spi/spi-tegra20-slink.c:	tspi->cur_direction = 0;
drivers/spi/spi-tegra20-slink.c:		tspi->cur_direction |= DATA_DIR_RX;
drivers/spi/spi-tegra20-slink.c:		tspi->cur_direction |= DATA_DIR_TX;
drivers/spi/spi-tegra20-slink.c:	tspi->command2_reg = command2;
drivers/spi/spi-tegra20-slink.c:	struct tegra_slink_data *tspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-tegra20-slink.c:	dev_dbg(&spi->dev, "setup %d bpw, %scpol, %scpha, %dHz\n",
drivers/spi/spi-tegra20-slink.c:		spi->bits_per_word,
drivers/spi/spi-tegra20-slink.c:		spi->mode & SPI_CPOL ? "" : "~",
drivers/spi/spi-tegra20-slink.c:		spi->mode & SPI_CPHA ? "" : "~",
drivers/spi/spi-tegra20-slink.c:		spi->max_speed_hz);
drivers/spi/spi-tegra20-slink.c:	ret = pm_runtime_get_sync(tspi->dev);
drivers/spi/spi-tegra20-slink.c:		dev_err(tspi->dev, "pm runtime failed, e = %d\n", ret);
drivers/spi/spi-tegra20-slink.c:	spin_lock_irqsave(&tspi->lock, flags);
drivers/spi/spi-tegra20-slink.c:	val = tspi->def_command_reg;
drivers/spi/spi-tegra20-slink.c:	if (spi->mode & SPI_CS_HIGH)
drivers/spi/spi-tegra20-slink.c:		val |= cs_pol_bit[spi->chip_select];
drivers/spi/spi-tegra20-slink.c:		val &= ~cs_pol_bit[spi->chip_select];
drivers/spi/spi-tegra20-slink.c:	tspi->def_command_reg = val;
drivers/spi/spi-tegra20-slink.c:	tegra_slink_writel(tspi, tspi->def_command_reg, SLINK_COMMAND);
drivers/spi/spi-tegra20-slink.c:	spin_unlock_irqrestore(&tspi->lock, flags);
drivers/spi/spi-tegra20-slink.c:	pm_runtime_put(tspi->dev);
drivers/spi/spi-tegra20-slink.c:	tspi->command_reg = tspi->def_command_reg;
drivers/spi/spi-tegra20-slink.c:	tspi->command_reg |= SLINK_CS_SW | SLINK_CS_VALUE;
drivers/spi/spi-tegra20-slink.c:	tspi->command2_reg = tspi->def_command2_reg;
drivers/spi/spi-tegra20-slink.c:	tspi->command2_reg |= SLINK_SS_EN_CS(spi->chip_select);
drivers/spi/spi-tegra20-slink.c:	tspi->command_reg &= ~SLINK_MODES;
drivers/spi/spi-tegra20-slink.c:	if (spi->mode & SPI_CPHA)
drivers/spi/spi-tegra20-slink.c:		tspi->command_reg |= SLINK_CK_SDA;
drivers/spi/spi-tegra20-slink.c:	if (spi->mode & SPI_CPOL)
drivers/spi/spi-tegra20-slink.c:		tspi->command_reg |= SLINK_IDLE_SCLK_DRIVE_HIGH;
drivers/spi/spi-tegra20-slink.c:		tspi->command_reg |= SLINK_IDLE_SCLK_DRIVE_LOW;
drivers/spi/spi-tegra20-slink.c:	reinit_completion(&tspi->xfer_completion);
drivers/spi/spi-tegra20-slink.c:		dev_err(tspi->dev,
drivers/spi/spi-tegra20-slink.c:	ret = wait_for_completion_timeout(&tspi->xfer_completion,
drivers/spi/spi-tegra20-slink.c:		dev_err(tspi->dev,
drivers/spi/spi-tegra20-slink.c:	if (tspi->tx_status)
drivers/spi/spi-tegra20-slink.c:		return tspi->tx_status;
drivers/spi/spi-tegra20-slink.c:	if (tspi->rx_status)
drivers/spi/spi-tegra20-slink.c:		return tspi->rx_status;
drivers/spi/spi-tegra20-slink.c:	tegra_slink_writel(tspi, tspi->def_command_reg, SLINK_COMMAND);
drivers/spi/spi-tegra20-slink.c:	tegra_slink_writel(tspi, tspi->def_command2_reg, SLINK_COMMAND2);
drivers/spi/spi-tegra20-slink.c:	struct spi_transfer *t = tspi->curr_xfer;
drivers/spi/spi-tegra20-slink.c:	spin_lock_irqsave(&tspi->lock, flags);
drivers/spi/spi-tegra20-slink.c:	if (tspi->tx_status ||  tspi->rx_status ||
drivers/spi/spi-tegra20-slink.c:				(tspi->status_reg & SLINK_BSY)) {
drivers/spi/spi-tegra20-slink.c:		dev_err(tspi->dev,
drivers/spi/spi-tegra20-slink.c:			"CpuXfer ERROR bit set 0x%x\n", tspi->status_reg);
drivers/spi/spi-tegra20-slink.c:		dev_err(tspi->dev,
drivers/spi/spi-tegra20-slink.c:			"CpuXfer 0x%08x:0x%08x:0x%08x\n", tspi->command_reg,
drivers/spi/spi-tegra20-slink.c:				tspi->command2_reg, tspi->dma_control_reg);
drivers/spi/spi-tegra20-slink.c:		reset_control_assert(tspi->rst);
drivers/spi/spi-tegra20-slink.c:		reset_control_deassert(tspi->rst);
drivers/spi/spi-tegra20-slink.c:		complete(&tspi->xfer_completion);
drivers/spi/spi-tegra20-slink.c:	if (tspi->cur_direction & DATA_DIR_RX)
drivers/spi/spi-tegra20-slink.c:	if (tspi->cur_direction & DATA_DIR_TX)
drivers/spi/spi-tegra20-slink.c:		tspi->cur_pos = tspi->cur_tx_pos;
drivers/spi/spi-tegra20-slink.c:		tspi->cur_pos = tspi->cur_rx_pos;
drivers/spi/spi-tegra20-slink.c:	if (tspi->cur_pos == t->len) {
drivers/spi/spi-tegra20-slink.c:		complete(&tspi->xfer_completion);
drivers/spi/spi-tegra20-slink.c:	tegra_slink_calculate_curr_xfer_param(tspi->cur_spi, tspi, t);
drivers/spi/spi-tegra20-slink.c:	spin_unlock_irqrestore(&tspi->lock, flags);
drivers/spi/spi-tegra20-slink.c:	struct spi_transfer *t = tspi->curr_xfer;
drivers/spi/spi-tegra20-slink.c:	if (tspi->cur_direction & DATA_DIR_TX) {
drivers/spi/spi-tegra20-slink.c:		if (tspi->tx_status) {
drivers/spi/spi-tegra20-slink.c:			dmaengine_terminate_all(tspi->tx_dma_chan);
drivers/spi/spi-tegra20-slink.c:				&tspi->tx_dma_complete, SLINK_DMA_TIMEOUT);
drivers/spi/spi-tegra20-slink.c:				dmaengine_terminate_all(tspi->tx_dma_chan);
drivers/spi/spi-tegra20-slink.c:				dev_err(tspi->dev, "TxDma Xfer failed\n");
drivers/spi/spi-tegra20-slink.c:	if (tspi->cur_direction & DATA_DIR_RX) {
drivers/spi/spi-tegra20-slink.c:		if (tspi->rx_status) {
drivers/spi/spi-tegra20-slink.c:			dmaengine_terminate_all(tspi->rx_dma_chan);
drivers/spi/spi-tegra20-slink.c:				&tspi->rx_dma_complete, SLINK_DMA_TIMEOUT);
drivers/spi/spi-tegra20-slink.c:				dmaengine_terminate_all(tspi->rx_dma_chan);
drivers/spi/spi-tegra20-slink.c:				dev_err(tspi->dev, "RxDma Xfer failed\n");
drivers/spi/spi-tegra20-slink.c:	spin_lock_irqsave(&tspi->lock, flags);
drivers/spi/spi-tegra20-slink.c:		dev_err(tspi->dev,
drivers/spi/spi-tegra20-slink.c:			"DmaXfer: ERROR bit set 0x%x\n", tspi->status_reg);
drivers/spi/spi-tegra20-slink.c:		dev_err(tspi->dev,
drivers/spi/spi-tegra20-slink.c:			"DmaXfer 0x%08x:0x%08x:0x%08x\n", tspi->command_reg,
drivers/spi/spi-tegra20-slink.c:				tspi->command2_reg, tspi->dma_control_reg);
drivers/spi/spi-tegra20-slink.c:		reset_control_assert(tspi->rst);
drivers/spi/spi-tegra20-slink.c:		reset_control_assert(tspi->rst);
drivers/spi/spi-tegra20-slink.c:		complete(&tspi->xfer_completion);
drivers/spi/spi-tegra20-slink.c:		spin_unlock_irqrestore(&tspi->lock, flags);
drivers/spi/spi-tegra20-slink.c:	if (tspi->cur_direction & DATA_DIR_RX)
drivers/spi/spi-tegra20-slink.c:	if (tspi->cur_direction & DATA_DIR_TX)
drivers/spi/spi-tegra20-slink.c:		tspi->cur_pos = tspi->cur_tx_pos;
drivers/spi/spi-tegra20-slink.c:		tspi->cur_pos = tspi->cur_rx_pos;
drivers/spi/spi-tegra20-slink.c:	if (tspi->cur_pos == t->len) {
drivers/spi/spi-tegra20-slink.c:		complete(&tspi->xfer_completion);
drivers/spi/spi-tegra20-slink.c:	total_fifo_words = tegra_slink_calculate_curr_xfer_param(tspi->cur_spi,
drivers/spi/spi-tegra20-slink.c:	spin_unlock_irqrestore(&tspi->lock, flags);
drivers/spi/spi-tegra20-slink.c:	if (!tspi->is_curr_dma_xfer)
drivers/spi/spi-tegra20-slink.c:	tspi->status_reg = tegra_slink_readl(tspi, SLINK_STATUS);
drivers/spi/spi-tegra20-slink.c:	if (tspi->cur_direction & DATA_DIR_TX)
drivers/spi/spi-tegra20-slink.c:		tspi->tx_status = tspi->status_reg &
drivers/spi/spi-tegra20-slink.c:	if (tspi->cur_direction & DATA_DIR_RX)
drivers/spi/spi-tegra20-slink.c:		tspi->rx_status = tspi->status_reg &
drivers/spi/spi-tegra20-slink.c:	/* the spi->mode bits understood by this driver: */
drivers/spi/spi-tegra20-slink.c:	tspi->master = master;
drivers/spi/spi-tegra20-slink.c:	tspi->dev = &pdev->dev;
drivers/spi/spi-tegra20-slink.c:	tspi->chip_data = cdata;
drivers/spi/spi-tegra20-slink.c:	spin_lock_init(&tspi->lock);
drivers/spi/spi-tegra20-slink.c:	if (of_property_read_u32(tspi->dev->of_node, "spi-max-frequency",
drivers/spi/spi-tegra20-slink.c:	tspi->phys = r->start;
drivers/spi/spi-tegra20-slink.c:	tspi->base = devm_ioremap_resource(&pdev->dev, r);
drivers/spi/spi-tegra20-slink.c:	if (IS_ERR(tspi->base)) {
drivers/spi/spi-tegra20-slink.c:		ret = PTR_ERR(tspi->base);
drivers/spi/spi-tegra20-slink.c:	tspi->irq = spi_irq;
drivers/spi/spi-tegra20-slink.c:	ret = request_threaded_irq(tspi->irq, tegra_slink_isr,
drivers/spi/spi-tegra20-slink.c:					tspi->irq);
drivers/spi/spi-tegra20-slink.c:	tspi->clk = devm_clk_get(&pdev->dev, NULL);
drivers/spi/spi-tegra20-slink.c:	if (IS_ERR(tspi->clk)) {
drivers/spi/spi-tegra20-slink.c:		ret = PTR_ERR(tspi->clk);
drivers/spi/spi-tegra20-slink.c:	tspi->rst = devm_reset_control_get_exclusive(&pdev->dev, "spi");
drivers/spi/spi-tegra20-slink.c:	if (IS_ERR(tspi->rst)) {
drivers/spi/spi-tegra20-slink.c:		ret = PTR_ERR(tspi->rst);
drivers/spi/spi-tegra20-slink.c:	tspi->max_buf_size = SLINK_FIFO_DEPTH << 2;
drivers/spi/spi-tegra20-slink.c:	tspi->dma_buf_size = DEFAULT_SPI_DMA_BUF_LEN;
drivers/spi/spi-tegra20-slink.c:	tspi->max_buf_size = tspi->dma_buf_size;
drivers/spi/spi-tegra20-slink.c:	init_completion(&tspi->tx_dma_complete);
drivers/spi/spi-tegra20-slink.c:	init_completion(&tspi->rx_dma_complete);
drivers/spi/spi-tegra20-slink.c:	init_completion(&tspi->xfer_completion);
drivers/spi/spi-tegra20-slink.c:	tspi->def_command_reg  = SLINK_M_S;
drivers/spi/spi-tegra20-slink.c:	tspi->def_command2_reg = SLINK_CS_ACTIVE_BETWEEN;
drivers/spi/spi-tegra20-slink.c:	tegra_slink_writel(tspi, tspi->def_command_reg, SLINK_COMMAND);
drivers/spi/spi-tegra20-slink.c:	tegra_slink_writel(tspi, tspi->def_command2_reg, SLINK_COMMAND2);
drivers/spi/spi-tegra20-slink.c:	free_irq(tspi->irq, tspi);
drivers/spi/spi-tegra20-slink.c:	if (tspi->tx_dma_chan)
drivers/spi/spi-tegra20-slink.c:	if (tspi->rx_dma_chan)
drivers/spi/spi-tegra20-slink.c:	tegra_slink_writel(tspi, tspi->command_reg, SLINK_COMMAND);
drivers/spi/spi-tegra20-slink.c:	tegra_slink_writel(tspi, tspi->command2_reg, SLINK_COMMAND2);
drivers/spi/spi-tegra20-slink.c:	clk_disable_unprepare(tspi->clk);
drivers/spi/spi-tegra20-slink.c:	ret = clk_prepare_enable(tspi->clk);
drivers/spi/spi-tegra20-slink.c:		dev_err(tspi->dev, "clk_prepare failed: %d\n", ret);
drivers/spi/spi-tegra20-slink.c:		.name		= "spi-tegra-slink",
drivers/spi/spi-tegra20-slink.c:MODULE_ALIAS("platform:spi-tegra-slink");
drivers/spi/spi-sirf.c:	writel(readl(sspi->base + sspi->regs->usp_mode1) &
drivers/spi/spi-sirf.c:		~SIRFSOC_USP_EN, sspi->base + sspi->regs->usp_mode1);
drivers/spi/spi-sirf.c:	writel(readl(sspi->base + sspi->regs->usp_mode1) |
drivers/spi/spi-sirf.c:		SIRFSOC_USP_EN, sspi->base + sspi->regs->usp_mode1);
drivers/spi/spi-sirf.c:	u8 *rx = sspi->rx;
drivers/spi/spi-sirf.c:	data = readl(sspi->base + sspi->regs->rxfifo_data);
drivers/spi/spi-sirf.c:		sspi->rx = rx;
drivers/spi/spi-sirf.c:	sspi->left_rx_word--;
drivers/spi/spi-sirf.c:	const u8 *tx = sspi->tx;
drivers/spi/spi-sirf.c:		sspi->tx = tx;
drivers/spi/spi-sirf.c:	writel(data, sspi->base + sspi->regs->txfifo_data);
drivers/spi/spi-sirf.c:	sspi->left_tx_word--;
drivers/spi/spi-sirf.c:	u16 *rx = sspi->rx;
drivers/spi/spi-sirf.c:	data = readl(sspi->base + sspi->regs->rxfifo_data);
drivers/spi/spi-sirf.c:		sspi->rx = rx;
drivers/spi/spi-sirf.c:	sspi->left_rx_word--;
drivers/spi/spi-sirf.c:	const u16 *tx = sspi->tx;
drivers/spi/spi-sirf.c:		sspi->tx = tx;
drivers/spi/spi-sirf.c:	writel(data, sspi->base + sspi->regs->txfifo_data);
drivers/spi/spi-sirf.c:	sspi->left_tx_word--;
drivers/spi/spi-sirf.c:	u32 *rx = sspi->rx;
drivers/spi/spi-sirf.c:	data = readl(sspi->base + sspi->regs->rxfifo_data);
drivers/spi/spi-sirf.c:		sspi->rx = rx;
drivers/spi/spi-sirf.c:	sspi->left_rx_word--;
drivers/spi/spi-sirf.c:	const u32 *tx = sspi->tx;
drivers/spi/spi-sirf.c:		sspi->tx = tx;
drivers/spi/spi-sirf.c:	writel(data, sspi->base + sspi->regs->txfifo_data);
drivers/spi/spi-sirf.c:	sspi->left_tx_word--;
drivers/spi/spi-sirf.c:	spi_stat = readl(sspi->base + sspi->regs->int_st);
drivers/spi/spi-sirf.c:	if (sspi->tx_by_cmd && sspi->type == SIRF_REAL_SPI
drivers/spi/spi-sirf.c:		complete(&sspi->tx_done);
drivers/spi/spi-sirf.c:		writel(0x0, sspi->base + sspi->regs->int_en);
drivers/spi/spi-sirf.c:		writel(readl(sspi->base + sspi->regs->int_st),
drivers/spi/spi-sirf.c:				sspi->base + sspi->regs->int_st);
drivers/spi/spi-sirf.c:		complete(&sspi->tx_done);
drivers/spi/spi-sirf.c:		complete(&sspi->rx_done);
drivers/spi/spi-sirf.c:		switch (sspi->type) {
drivers/spi/spi-sirf.c:			writel(0x0, sspi->base + sspi->regs->int_en);
drivers/spi/spi-sirf.c:			writel(~0UL, sspi->base + sspi->regs->usp_int_en_clr);
drivers/spi/spi-sirf.c:		writel(readl(sspi->base + sspi->regs->int_st),
drivers/spi/spi-sirf.c:				sspi->base + sspi->regs->int_st);
drivers/spi/spi-sirf.c:		complete(&sspi->tx_done);
drivers/spi/spi-sirf.c:	while (!(readl(sspi->base + sspi->regs->int_st) &
drivers/spi/spi-sirf.c:	complete(&sspi->rx_done);
drivers/spi/spi-sirf.c:	switch (sspi->type) {
drivers/spi/spi-sirf.c:		writel(0x0, sspi->base + sspi->regs->int_en);
drivers/spi/spi-sirf.c:		writel(~0UL, sspi->base + sspi->regs->usp_int_en_clr);
drivers/spi/spi-sirf.c:	writel(readl(sspi->base + sspi->regs->int_st),
drivers/spi/spi-sirf.c:			sspi->base + sspi->regs->int_st);
drivers/spi/spi-sirf.c:	sspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-sirf.c:	writel(SIRFSOC_SPI_FIFO_RESET, sspi->base + sspi->regs->txfifo_op);
drivers/spi/spi-sirf.c:	writel(SIRFSOC_SPI_FIFO_START, sspi->base + sspi->regs->txfifo_op);
drivers/spi/spi-sirf.c:	memcpy(&cmd, sspi->tx, t->len);
drivers/spi/spi-sirf.c:	if (sspi->word_width == 1 && !(spi->mode & SPI_LSB_FIRST))
drivers/spi/spi-sirf.c:	if (sspi->word_width == 2 && t->len == 4 &&
drivers/spi/spi-sirf.c:			(!(spi->mode & SPI_LSB_FIRST)))
drivers/spi/spi-sirf.c:	writel(cmd, sspi->base + sspi->regs->spi_cmd);
drivers/spi/spi-sirf.c:		sspi->base + sspi->regs->int_en);
drivers/spi/spi-sirf.c:		sspi->base + sspi->regs->tx_rx_en);
drivers/spi/spi-sirf.c:	if (wait_for_completion_timeout(&sspi->tx_done, timeout) == 0) {
drivers/spi/spi-sirf.c:		dev_err(&spi->dev, "cmd transfer timeout\n");
drivers/spi/spi-sirf.c:	sspi->left_rx_word -= t->len;
drivers/spi/spi-sirf.c:	sspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-sirf.c:	writel(SIRFSOC_SPI_FIFO_RESET, sspi->base + sspi->regs->rxfifo_op);
drivers/spi/spi-sirf.c:	writel(SIRFSOC_SPI_FIFO_RESET, sspi->base + sspi->regs->txfifo_op);
drivers/spi/spi-sirf.c:	switch (sspi->type) {
drivers/spi/spi-sirf.c:			sspi->base + sspi->regs->rxfifo_op);
drivers/spi/spi-sirf.c:			sspi->base + sspi->regs->txfifo_op);
drivers/spi/spi-sirf.c:		writel(0, sspi->base + sspi->regs->int_en);
drivers/spi/spi-sirf.c:		writel(0x0, sspi->base + sspi->regs->rxfifo_op);
drivers/spi/spi-sirf.c:		writel(0x0, sspi->base + sspi->regs->txfifo_op);
drivers/spi/spi-sirf.c:		writel(0, sspi->base + sspi->regs->int_en);
drivers/spi/spi-sirf.c:		writel(0x0, sspi->base + sspi->regs->rxfifo_op);
drivers/spi/spi-sirf.c:		writel(0x0, sspi->base + sspi->regs->txfifo_op);
drivers/spi/spi-sirf.c:		writel(~0UL, sspi->base + sspi->regs->usp_int_en_clr);
drivers/spi/spi-sirf.c:	writel(readl(sspi->base + sspi->regs->int_st),
drivers/spi/spi-sirf.c:		sspi->base + sspi->regs->int_st);
drivers/spi/spi-sirf.c:	if (sspi->left_tx_word < sspi->dat_max_frm_len) {
drivers/spi/spi-sirf.c:		switch (sspi->type) {
drivers/spi/spi-sirf.c:			writel(readl(sspi->base + sspi->regs->spi_ctrl) |
drivers/spi/spi-sirf.c:				sspi->base + sspi->regs->spi_ctrl);
drivers/spi/spi-sirf.c:			writel(sspi->left_tx_word - 1,
drivers/spi/spi-sirf.c:				sspi->base + sspi->regs->tx_dma_io_len);
drivers/spi/spi-sirf.c:			writel(sspi->left_tx_word - 1,
drivers/spi/spi-sirf.c:				sspi->base + sspi->regs->rx_dma_io_len);
drivers/spi/spi-sirf.c:			writel(sspi->left_tx_word * sspi->word_width,
drivers/spi/spi-sirf.c:				sspi->base + sspi->regs->tx_dma_io_len);
drivers/spi/spi-sirf.c:			writel(sspi->left_tx_word * sspi->word_width,
drivers/spi/spi-sirf.c:				sspi->base + sspi->regs->rx_dma_io_len);
drivers/spi/spi-sirf.c:		if (sspi->type == SIRF_REAL_SPI)
drivers/spi/spi-sirf.c:			writel(readl(sspi->base + sspi->regs->spi_ctrl),
drivers/spi/spi-sirf.c:				sspi->base + sspi->regs->spi_ctrl);
drivers/spi/spi-sirf.c:		writel(0, sspi->base + sspi->regs->tx_dma_io_len);
drivers/spi/spi-sirf.c:		writel(0, sspi->base + sspi->regs->rx_dma_io_len);
drivers/spi/spi-sirf.c:	sspi->dst_start = dma_map_single(&spi->dev, sspi->rx, t->len,
drivers/spi/spi-sirf.c:	rx_desc = dmaengine_prep_slave_single(sspi->rx_chan,
drivers/spi/spi-sirf.c:		sspi->dst_start, t->len, DMA_DEV_TO_MEM,
drivers/spi/spi-sirf.c:	rx_desc->callback_param = &sspi->rx_done;
drivers/spi/spi-sirf.c:	sspi->src_start = dma_map_single(&spi->dev, (void *)sspi->tx, t->len,
drivers/spi/spi-sirf.c:	tx_desc = dmaengine_prep_slave_single(sspi->tx_chan,
drivers/spi/spi-sirf.c:		sspi->src_start, t->len, DMA_MEM_TO_DEV,
drivers/spi/spi-sirf.c:	tx_desc->callback_param = &sspi->tx_done;
drivers/spi/spi-sirf.c:	dma_async_issue_pending(sspi->tx_chan);
drivers/spi/spi-sirf.c:	dma_async_issue_pending(sspi->rx_chan);
drivers/spi/spi-sirf.c:			sspi->base + sspi->regs->tx_rx_en);
drivers/spi/spi-sirf.c:	if (sspi->type == SIRF_USP_SPI_P2 ||
drivers/spi/spi-sirf.c:		sspi->type == SIRF_USP_SPI_A7) {
drivers/spi/spi-sirf.c:			sspi->base + sspi->regs->rxfifo_op);
drivers/spi/spi-sirf.c:			sspi->base + sspi->regs->txfifo_op);
drivers/spi/spi-sirf.c:	if (wait_for_completion_timeout(&sspi->rx_done, timeout) == 0) {
drivers/spi/spi-sirf.c:		dev_err(&spi->dev, "transfer timeout\n");
drivers/spi/spi-sirf.c:		dmaengine_terminate_all(sspi->rx_chan);
drivers/spi/spi-sirf.c:		sspi->left_rx_word = 0;
drivers/spi/spi-sirf.c:	if (wait_for_completion_timeout(&sspi->tx_done, timeout) == 0) {
drivers/spi/spi-sirf.c:		dev_err(&spi->dev, "transfer timeout\n");
drivers/spi/spi-sirf.c:		if (sspi->type == SIRF_USP_SPI_P2 ||
drivers/spi/spi-sirf.c:			sspi->type == SIRF_USP_SPI_A7)
drivers/spi/spi-sirf.c:			writel(0, sspi->base + sspi->regs->tx_rx_en);
drivers/spi/spi-sirf.c:		dmaengine_terminate_all(sspi->tx_chan);
drivers/spi/spi-sirf.c:	dma_unmap_single(&spi->dev, sspi->src_start, t->len, DMA_TO_DEVICE);
drivers/spi/spi-sirf.c:	dma_unmap_single(&spi->dev, sspi->dst_start, t->len, DMA_FROM_DEVICE);
drivers/spi/spi-sirf.c:	writel(0, sspi->base + sspi->regs->rxfifo_op);
drivers/spi/spi-sirf.c:	writel(0, sspi->base + sspi->regs->txfifo_op);
drivers/spi/spi-sirf.c:	if (sspi->left_tx_word >= sspi->dat_max_frm_len)
drivers/spi/spi-sirf.c:		writel(0, sspi->base + sspi->regs->tx_rx_en);
drivers/spi/spi-sirf.c:	if (sspi->type == SIRF_USP_SPI_P2 ||
drivers/spi/spi-sirf.c:		sspi->type == SIRF_USP_SPI_A7)
drivers/spi/spi-sirf.c:		writel(0, sspi->base + sspi->regs->tx_rx_en);
drivers/spi/spi-sirf.c:	sspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-sirf.c:			sspi->base + sspi->regs->rxfifo_op);
drivers/spi/spi-sirf.c:			sspi->base + sspi->regs->txfifo_op);
drivers/spi/spi-sirf.c:		switch (sspi->type) {
drivers/spi/spi-sirf.c:			writel(0x0, sspi->base + sspi->regs->rxfifo_op);
drivers/spi/spi-sirf.c:			writel(0x0, sspi->base + sspi->regs->txfifo_op);
drivers/spi/spi-sirf.c:			writel(0, sspi->base + sspi->regs->int_en);
drivers/spi/spi-sirf.c:			writel(readl(sspi->base + sspi->regs->int_st),
drivers/spi/spi-sirf.c:				sspi->base + sspi->regs->int_st);
drivers/spi/spi-sirf.c:			writel(min((sspi->left_tx_word * sspi->word_width),
drivers/spi/spi-sirf.c:				sspi->fifo_size),
drivers/spi/spi-sirf.c:				sspi->base + sspi->regs->tx_dma_io_len);
drivers/spi/spi-sirf.c:			writel(min((sspi->left_rx_word * sspi->word_width),
drivers/spi/spi-sirf.c:				sspi->fifo_size),
drivers/spi/spi-sirf.c:				sspi->base + sspi->regs->rx_dma_io_len);
drivers/spi/spi-sirf.c:			writel(0x0, sspi->base + sspi->regs->rxfifo_op);
drivers/spi/spi-sirf.c:			writel(0x0, sspi->base + sspi->regs->txfifo_op);
drivers/spi/spi-sirf.c:			writel(~0UL, sspi->base + sspi->regs->usp_int_en_clr);
drivers/spi/spi-sirf.c:			writel(readl(sspi->base + sspi->regs->int_st),
drivers/spi/spi-sirf.c:				sspi->base + sspi->regs->int_st);
drivers/spi/spi-sirf.c:			writel(min((sspi->left_tx_word * sspi->word_width),
drivers/spi/spi-sirf.c:				sspi->fifo_size),
drivers/spi/spi-sirf.c:				sspi->base + sspi->regs->tx_dma_io_len);
drivers/spi/spi-sirf.c:			writel(min((sspi->left_rx_word * sspi->word_width),
drivers/spi/spi-sirf.c:				sspi->fifo_size),
drivers/spi/spi-sirf.c:				sspi->base + sspi->regs->rx_dma_io_len);
drivers/spi/spi-sirf.c:				sspi->base + sspi->regs->rxfifo_op);
drivers/spi/spi-sirf.c:				sspi->base + sspi->regs->txfifo_op);
drivers/spi/spi-sirf.c:			writel(0, sspi->base + sspi->regs->int_en);
drivers/spi/spi-sirf.c:			writel(readl(sspi->base + sspi->regs->int_st),
drivers/spi/spi-sirf.c:				sspi->base + sspi->regs->int_st);
drivers/spi/spi-sirf.c:			writel(readl(sspi->base + sspi->regs->spi_ctrl) |
drivers/spi/spi-sirf.c:				sspi->base + sspi->regs->spi_ctrl);
drivers/spi/spi-sirf.c:			data_units = sspi->fifo_size / sspi->word_width;
drivers/spi/spi-sirf.c:			writel(min(sspi->left_tx_word, data_units) - 1,
drivers/spi/spi-sirf.c:				sspi->base + sspi->regs->tx_dma_io_len);
drivers/spi/spi-sirf.c:			writel(min(sspi->left_rx_word, data_units) - 1,
drivers/spi/spi-sirf.c:				sspi->base + sspi->regs->rx_dma_io_len);
drivers/spi/spi-sirf.c:		while (!((readl(sspi->base + sspi->regs->txfifo_st)
drivers/spi/spi-sirf.c:			sspi->left_tx_word)
drivers/spi/spi-sirf.c:			sspi->tx_word(sspi);
drivers/spi/spi-sirf.c:			sspi->base + sspi->regs->int_en);
drivers/spi/spi-sirf.c:			sspi->base + sspi->regs->tx_rx_en);
drivers/spi/spi-sirf.c:		if (sspi->type == SIRF_USP_SPI_P2 ||
drivers/spi/spi-sirf.c:			sspi->type == SIRF_USP_SPI_A7) {
drivers/spi/spi-sirf.c:				sspi->base + sspi->regs->rxfifo_op);
drivers/spi/spi-sirf.c:				sspi->base + sspi->regs->txfifo_op);
drivers/spi/spi-sirf.c:		if (!wait_for_completion_timeout(&sspi->tx_done, timeout) ||
drivers/spi/spi-sirf.c:			!wait_for_completion_timeout(&sspi->rx_done, timeout)) {
drivers/spi/spi-sirf.c:			dev_err(&spi->dev, "transfer timeout\n");
drivers/spi/spi-sirf.c:			if (sspi->type == SIRF_USP_SPI_P2 ||
drivers/spi/spi-sirf.c:				sspi->type == SIRF_USP_SPI_A7)
drivers/spi/spi-sirf.c:				writel(0, sspi->base + sspi->regs->tx_rx_en);
drivers/spi/spi-sirf.c:		while (!((readl(sspi->base + sspi->regs->rxfifo_st)
drivers/spi/spi-sirf.c:			sspi->left_rx_word)
drivers/spi/spi-sirf.c:			sspi->rx_word(sspi);
drivers/spi/spi-sirf.c:		if (sspi->type == SIRF_USP_SPI_P2 ||
drivers/spi/spi-sirf.c:			sspi->type == SIRF_USP_SPI_A7)
drivers/spi/spi-sirf.c:			writel(0, sspi->base + sspi->regs->tx_rx_en);
drivers/spi/spi-sirf.c:		writel(0, sspi->base + sspi->regs->rxfifo_op);
drivers/spi/spi-sirf.c:		writel(0, sspi->base + sspi->regs->txfifo_op);
drivers/spi/spi-sirf.c:	} while (sspi->left_tx_word != 0 || sspi->left_rx_word != 0);
drivers/spi/spi-sirf.c:	sspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-sirf.c:	sspi->tx = t->tx_buf;
drivers/spi/spi-sirf.c:	sspi->rx = t->rx_buf;
drivers/spi/spi-sirf.c:	sspi->left_tx_word = sspi->left_rx_word = t->len / sspi->word_width;
drivers/spi/spi-sirf.c:	reinit_completion(&sspi->rx_done);
drivers/spi/spi-sirf.c:	reinit_completion(&sspi->tx_done);
drivers/spi/spi-sirf.c:	if (sspi->type == SIRF_REAL_SPI && sspi->tx_by_cmd)
drivers/spi/spi-sirf.c:	return t->len - sspi->left_rx_word * sspi->word_width;
drivers/spi/spi-sirf.c:	struct sirfsoc_spi *sspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-sirf.c:	if (sspi->hw_cs) {
drivers/spi/spi-sirf.c:		switch (sspi->type) {
drivers/spi/spi-sirf.c:			regval = readl(sspi->base + sspi->regs->spi_ctrl);
drivers/spi/spi-sirf.c:				if (spi->mode & SPI_CS_HIGH)
drivers/spi/spi-sirf.c:				if (spi->mode & SPI_CS_HIGH)
drivers/spi/spi-sirf.c:			writel(regval, sspi->base + sspi->regs->spi_ctrl);
drivers/spi/spi-sirf.c:			regval = readl(sspi->base +
drivers/spi/spi-sirf.c:					sspi->regs->usp_pin_io_data);
drivers/spi/spi-sirf.c:				if (spi->mode & SPI_CS_HIGH)
drivers/spi/spi-sirf.c:				if (spi->mode & SPI_CS_HIGH)
drivers/spi/spi-sirf.c:				sspi->base + sspi->regs->usp_pin_io_data);
drivers/spi/spi-sirf.c:			gpio_direction_output(spi->cs_gpio,
drivers/spi/spi-sirf.c:					spi->mode & SPI_CS_HIGH ? 1 : 0);
drivers/spi/spi-sirf.c:			gpio_direction_output(spi->cs_gpio,
drivers/spi/spi-sirf.c:					spi->mode & SPI_CS_HIGH ? 0 : 1);
drivers/spi/spi-sirf.c:	sspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-sirf.c:	regval = readl(sspi->base + sspi->regs->spi_ctrl);
drivers/spi/spi-sirf.c:	usp_mode1 = readl(sspi->base + sspi->regs->usp_mode1);
drivers/spi/spi-sirf.c:	if (!(spi->mode & SPI_CS_HIGH)) {
drivers/spi/spi-sirf.c:	if (!(spi->mode & SPI_LSB_FIRST)) {
drivers/spi/spi-sirf.c:	if (spi->mode & SPI_CPOL) {
drivers/spi/spi-sirf.c:	if (((spi->mode & SPI_CPOL) && (spi->mode & SPI_CPHA)) ||
drivers/spi/spi-sirf.c:	    (!(spi->mode & SPI_CPOL) && !(spi->mode & SPI_CPHA))) {
drivers/spi/spi-sirf.c:	writel((SIRFSOC_SPI_FIFO_LEVEL_CHK_MASK(sspi, sspi->fifo_size - 2) <<
drivers/spi/spi-sirf.c:		(SIRFSOC_SPI_FIFO_LEVEL_CHK_MASK(sspi, sspi->fifo_size / 2) <<
drivers/spi/spi-sirf.c:		sspi->base + sspi->regs->txfifo_level_chk);
drivers/spi/spi-sirf.c:		(SIRFSOC_SPI_FIFO_LEVEL_CHK_MASK(sspi, sspi->fifo_size / 2) <<
drivers/spi/spi-sirf.c:		(SIRFSOC_SPI_FIFO_LEVEL_CHK_MASK(sspi, sspi->fifo_size - 2) <<
drivers/spi/spi-sirf.c:		sspi->base + sspi->regs->rxfifo_level_chk);
drivers/spi/spi-sirf.c:	switch (sspi->type) {
drivers/spi/spi-sirf.c:		writel(regval, sspi->base + sspi->regs->spi_ctrl);
drivers/spi/spi-sirf.c:		writel(usp_mode1, sspi->base + sspi->regs->usp_mode1);
drivers/spi/spi-sirf.c:	sspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-sirf.c:	bits_per_word = (t) ? t->bits_per_word : spi->bits_per_word;
drivers/spi/spi-sirf.c:	hz = t && t->speed_hz ? t->speed_hz : spi->max_speed_hz;
drivers/spi/spi-sirf.c:	usp_mode2 = regval = (sspi->ctrl_freq / (2 * hz)) - 1;
drivers/spi/spi-sirf.c:		dev_err(&spi->dev, "Speed %d not supported\n", hz);
drivers/spi/spi-sirf.c:		sspi->rx_word = spi_sirfsoc_rx_word_u8;
drivers/spi/spi-sirf.c:		sspi->tx_word = spi_sirfsoc_tx_word_u8;
drivers/spi/spi-sirf.c:		sspi->rx_word = spi_sirfsoc_rx_word_u16;
drivers/spi/spi-sirf.c:		sspi->tx_word = spi_sirfsoc_tx_word_u16;
drivers/spi/spi-sirf.c:		sspi->rx_word = spi_sirfsoc_rx_word_u32;
drivers/spi/spi-sirf.c:		sspi->tx_word = spi_sirfsoc_tx_word_u32;
drivers/spi/spi-sirf.c:		dev_err(&spi->dev, "bpw %d not supported\n", bits_per_word);
drivers/spi/spi-sirf.c:	sspi->word_width = DIV_ROUND_UP(bits_per_word, 8);
drivers/spi/spi-sirf.c:	txfifo_ctrl = (((sspi->fifo_size / 2) &
drivers/spi/spi-sirf.c:			(sspi->word_width >> 1);
drivers/spi/spi-sirf.c:	rxfifo_ctrl = (((sspi->fifo_size / 2) &
drivers/spi/spi-sirf.c:			(sspi->word_width >> 1);
drivers/spi/spi-sirf.c:	writel(txfifo_ctrl, sspi->base + sspi->regs->txfifo_ctrl);
drivers/spi/spi-sirf.c:	writel(rxfifo_ctrl, sspi->base + sspi->regs->rxfifo_ctrl);
drivers/spi/spi-sirf.c:	if (sspi->type == SIRF_USP_SPI_P2 ||
drivers/spi/spi-sirf.c:		sspi->type == SIRF_USP_SPI_A7) {
drivers/spi/spi-sirf.c:			sspi->base + sspi->regs->usp_tx_frame_ctrl);
drivers/spi/spi-sirf.c:			sspi->base + sspi->regs->usp_rx_frame_ctrl);
drivers/spi/spi-sirf.c:		writel(readl(sspi->base + sspi->regs->usp_mode2) |
drivers/spi/spi-sirf.c:			sspi->base + sspi->regs->usp_mode2);
drivers/spi/spi-sirf.c:	if (sspi->type == SIRF_REAL_SPI)
drivers/spi/spi-sirf.c:		writel(regval, sspi->base + sspi->regs->spi_ctrl);
drivers/spi/spi-sirf.c:	if (sspi->type == SIRF_REAL_SPI) {
drivers/spi/spi-sirf.c:			sspi->tx_by_cmd = true;
drivers/spi/spi-sirf.c:			writel(readl(sspi->base + sspi->regs->spi_ctrl) |
drivers/spi/spi-sirf.c:				sspi->base + sspi->regs->spi_ctrl);
drivers/spi/spi-sirf.c:			sspi->tx_by_cmd = false;
drivers/spi/spi-sirf.c:			writel(readl(sspi->base + sspi->regs->spi_ctrl) &
drivers/spi/spi-sirf.c:				sspi->base + sspi->regs->spi_ctrl);
drivers/spi/spi-sirf.c:		writel(0, sspi->base + sspi->regs->tx_dma_io_ctrl);
drivers/spi/spi-sirf.c:			sspi->base + sspi->regs->rx_dma_io_ctrl);
drivers/spi/spi-sirf.c:			sspi->base + sspi->regs->tx_dma_io_ctrl);
drivers/spi/spi-sirf.c:			sspi->base + sspi->regs->rx_dma_io_ctrl);
drivers/spi/spi-sirf.c:	sspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-sirf.c:	if (spi->cs_gpio == -ENOENT)
drivers/spi/spi-sirf.c:		sspi->hw_cs = true;
drivers/spi/spi-sirf.c:		sspi->hw_cs = false;
drivers/spi/spi-sirf.c:			ret = gpio_is_valid(spi->cs_gpio);
drivers/spi/spi-sirf.c:				dev_err(&spi->dev, "no valid gpio\n");
drivers/spi/spi-sirf.c:			ret = gpio_request(spi->cs_gpio, DRIVER_NAME);
drivers/spi/spi-sirf.c:				dev_err(&spi->dev, "failed to request gpio\n");
drivers/spi/spi-sirf.c:		gpio_free(spi->cs_gpio);
drivers/spi/spi-sirf.c:	sspi->fifo_full_offset = ilog2(sspi->fifo_size);
drivers/spi/spi-sirf.c:	sspi->regs = spi_comp_data->regs;
drivers/spi/spi-sirf.c:	sspi->type = spi_comp_data->type;
drivers/spi/spi-sirf.c:	sspi->fifo_level_chk_mask = (sspi->fifo_size / 4) - 1;
drivers/spi/spi-sirf.c:	sspi->dat_max_frm_len = spi_comp_data->dat_max_frm_len;
drivers/spi/spi-sirf.c:	sspi->fifo_size = spi_comp_data->fifo_size;
drivers/spi/spi-sirf.c:	sspi->base = devm_ioremap_resource(&pdev->dev, mem_res);
drivers/spi/spi-sirf.c:	if (IS_ERR(sspi->base)) {
drivers/spi/spi-sirf.c:		ret = PTR_ERR(sspi->base);
drivers/spi/spi-sirf.c:	sspi->bitbang.master = master;
drivers/spi/spi-sirf.c:	sspi->bitbang.chipselect = spi_sirfsoc_chipselect;
drivers/spi/spi-sirf.c:	sspi->bitbang.setup_transfer = spi_sirfsoc_setup_transfer;
drivers/spi/spi-sirf.c:	sspi->bitbang.txrx_bufs = spi_sirfsoc_transfer;
drivers/spi/spi-sirf.c:	sspi->bitbang.master->setup = spi_sirfsoc_setup;
drivers/spi/spi-sirf.c:	sspi->bitbang.master->cleanup = spi_sirfsoc_cleanup;
drivers/spi/spi-sirf.c:	sspi->bitbang.master->dev.of_node = pdev->dev.of_node;
drivers/spi/spi-sirf.c:	sspi->rx_chan = dma_request_slave_channel(&pdev->dev, "rx");
drivers/spi/spi-sirf.c:	if (!sspi->rx_chan) {
drivers/spi/spi-sirf.c:	sspi->tx_chan = dma_request_slave_channel(&pdev->dev, "tx");
drivers/spi/spi-sirf.c:	if (!sspi->tx_chan) {
drivers/spi/spi-sirf.c:	sspi->clk = clk_get(&pdev->dev, NULL);
drivers/spi/spi-sirf.c:	if (IS_ERR(sspi->clk)) {
drivers/spi/spi-sirf.c:		ret = PTR_ERR(sspi->clk);
drivers/spi/spi-sirf.c:	clk_prepare_enable(sspi->clk);
drivers/spi/spi-sirf.c:	sspi->ctrl_freq = clk_get_rate(sspi->clk);
drivers/spi/spi-sirf.c:	init_completion(&sspi->rx_done);
drivers/spi/spi-sirf.c:	init_completion(&sspi->tx_done);
drivers/spi/spi-sirf.c:	ret = spi_bitbang_start(&sspi->bitbang);
drivers/spi/spi-sirf.c:	clk_disable_unprepare(sspi->clk);
drivers/spi/spi-sirf.c:	clk_put(sspi->clk);
drivers/spi/spi-sirf.c:	dma_release_channel(sspi->tx_chan);
drivers/spi/spi-sirf.c:	dma_release_channel(sspi->rx_chan);
drivers/spi/spi-sirf.c:	spi_bitbang_stop(&sspi->bitbang);
drivers/spi/spi-sirf.c:	clk_disable_unprepare(sspi->clk);
drivers/spi/spi-sirf.c:	clk_put(sspi->clk);
drivers/spi/spi-sirf.c:	dma_release_channel(sspi->rx_chan);
drivers/spi/spi-sirf.c:	dma_release_channel(sspi->tx_chan);
drivers/spi/spi-sirf.c:	clk_disable(sspi->clk);
drivers/spi/spi-sirf.c:	clk_enable(sspi->clk);
drivers/spi/spi-sirf.c:	writel(SIRFSOC_SPI_FIFO_RESET, sspi->base + sspi->regs->txfifo_op);
drivers/spi/spi-sirf.c:	writel(SIRFSOC_SPI_FIFO_RESET, sspi->base + sspi->regs->rxfifo_op);
drivers/spi/spi-sirf.c:	writel(SIRFSOC_SPI_FIFO_START, sspi->base + sspi->regs->txfifo_op);
drivers/spi/spi-sirf.c:	writel(SIRFSOC_SPI_FIFO_START, sspi->base + sspi->regs->rxfifo_op);
drivers/spi/spi.c:	if (spi->controller->cleanup)
drivers/spi/spi.c:		spi->controller->cleanup(spi);
drivers/spi/spi.c:	spi_controller_put(spi->controller);
drivers/spi/spi.c:	return sprintf(buf, "%s%s\n", SPI_MODULE_PREFIX, spi->modalias);
drivers/spi/spi.c:	return spi_statistics_##field##_show(&spi->statistics, buf);	\
drivers/spi/spi.c:	return strcmp(spi->modalias, drv->name) == 0;
drivers/spi/spi.c:	return add_uevent_var(env, "MODALIAS=%s%s", SPI_MODULE_PREFIX, spi->modalias);
drivers/spi/spi.c:		spi->irq = of_irq_get(dev->of_node, 0);
drivers/spi/spi.c:		if (spi->irq == -EPROBE_DEFER)
drivers/spi/spi.c:		if (spi->irq < 0)
drivers/spi/spi.c:			spi->irq = 0;
drivers/spi/spi.c:	spi->master = spi->controller = ctlr;
drivers/spi/spi.c:	spi->dev.parent = &ctlr->dev;
drivers/spi/spi.c:	spi->dev.bus = &spi_bus_type;
drivers/spi/spi.c:	spi->dev.release = spidev_release;
drivers/spi/spi.c:	spi->cs_gpio = -ENOENT;
drivers/spi/spi.c:	spin_lock_init(&spi->statistics.lock);
drivers/spi/spi.c:	device_initialize(&spi->dev);
drivers/spi/spi.c:	struct acpi_device *adev = ACPI_COMPANION(&spi->dev);
drivers/spi/spi.c:		dev_set_name(&spi->dev, "spi-%s", acpi_dev_name(adev));
drivers/spi/spi.c:	dev_set_name(&spi->dev, "%s.%u", dev_name(&spi->controller->dev),
drivers/spi/spi.c:		     spi->chip_select);
drivers/spi/spi.c:	if (spi->controller == new_spi->controller &&
drivers/spi/spi.c:	    spi->chip_select == new_spi->chip_select)
drivers/spi/spi.c:	struct spi_controller *ctlr = spi->controller;
drivers/spi/spi.c:	if (spi->chip_select >= ctlr->num_chipselect) {
drivers/spi/spi.c:		dev_err(dev, "cs%d >= max %d\n", spi->chip_select,
drivers/spi/spi.c:				spi->chip_select);
drivers/spi/spi.c:		spi->cs_gpio = ctlr->cs_gpios[spi->chip_select];
drivers/spi/spi.c:				dev_name(&spi->dev), status);
drivers/spi/spi.c:	status = device_add(&spi->dev);
drivers/spi/spi.c:				dev_name(&spi->dev), status);
drivers/spi/spi.c:		dev_dbg(dev, "registered child %s\n", dev_name(&spi->dev));
drivers/spi/spi.c:	if (spi->dev.of_node) {
drivers/spi/spi.c:		of_node_clear_flag(spi->dev.of_node, OF_POPULATED);
drivers/spi/spi.c:		of_node_put(spi->dev.of_node);
drivers/spi/spi.c:	if (ACPI_COMPANION(&spi->dev))
drivers/spi/spi.c:		acpi_device_clear_enumerated(ACPI_COMPANION(&spi->dev));
drivers/spi/spi.c:	device_unregister(&spi->dev);
drivers/spi/spi.c:	if (spi->mode & SPI_CS_HIGH)
drivers/spi/spi.c:	if (gpio_is_valid(spi->cs_gpio)) {
drivers/spi/spi.c:		gpio_set_value(spi->cs_gpio, !enable);
drivers/spi/spi.c:		if ((spi->controller->flags & SPI_MASTER_GPIO_SS) &&
drivers/spi/spi.c:		    spi->controller->set_cs)
drivers/spi/spi.c:			spi->controller->set_cs(spi, !enable);
drivers/spi/spi.c:	} else if (spi->controller->set_cs) {
drivers/spi/spi.c:		spi->controller->set_cs(spi, !enable);
drivers/spi/spi.c:	struct spi_statistics *stats = &msg->spi->statistics;
drivers/spi/spi.c:				dev_err(&msg->spi->dev,
drivers/spi/spi.c:				dev_err(&msg->spi->dev,
drivers/spi/spi.c:				dev_err(&msg->spi->dev,
drivers/spi/spi.c:	struct spi_controller *ctlr = spi->controller;
drivers/spi/spi.c:	if (of_property_read_bool(nc, "spi-cpha"))
drivers/spi/spi.c:		spi->mode |= SPI_CPHA;
drivers/spi/spi.c:	if (of_property_read_bool(nc, "spi-cpol"))
drivers/spi/spi.c:		spi->mode |= SPI_CPOL;
drivers/spi/spi.c:	if (of_property_read_bool(nc, "spi-cs-high"))
drivers/spi/spi.c:		spi->mode |= SPI_CS_HIGH;
drivers/spi/spi.c:	if (of_property_read_bool(nc, "spi-3wire"))
drivers/spi/spi.c:		spi->mode |= SPI_3WIRE;
drivers/spi/spi.c:	if (of_property_read_bool(nc, "spi-lsb-first"))
drivers/spi/spi.c:		spi->mode |= SPI_LSB_FIRST;
drivers/spi/spi.c:	if (!of_property_read_u32(nc, "spi-tx-bus-width", &value)) {
drivers/spi/spi.c:			spi->mode |= SPI_TX_DUAL;
drivers/spi/spi.c:			spi->mode |= SPI_TX_QUAD;
drivers/spi/spi.c:				"spi-tx-bus-width %d not supported\n",
drivers/spi/spi.c:	if (!of_property_read_u32(nc, "spi-rx-bus-width", &value)) {
drivers/spi/spi.c:			spi->mode |= SPI_RX_DUAL;
drivers/spi/spi.c:			spi->mode |= SPI_RX_QUAD;
drivers/spi/spi.c:				"spi-rx-bus-width %d not supported\n",
drivers/spi/spi.c:	spi->chip_select = value;
drivers/spi/spi.c:	rc = of_property_read_u32(nc, "spi-max-frequency", &value);
drivers/spi/spi.c:			"%pOF has no valid 'spi-max-frequency' property (%d)\n", nc, rc);
drivers/spi/spi.c:	spi->max_speed_hz = value;
drivers/spi/spi.c:	rc = of_modalias_node(nc, spi->modalias,
drivers/spi/spi.c:				sizeof(spi->modalias));
drivers/spi/spi.c:	spi->dev.of_node = nc;
drivers/spi/spi.c:	struct acpi_device *dev = ACPI_COMPANION(&spi->dev);
drivers/spi/spi.c:		spi->max_speed_hz  = NSEC_PER_SEC / *(u32 *)obj->buffer.pointer;
drivers/spi/spi.c:		spi->bits_per_word = *(u64 *)obj->buffer.pointer;
drivers/spi/spi.c:		spi->mode |= SPI_LSB_FIRST;
drivers/spi/spi.c:		spi->mode |= SPI_CPOL;
drivers/spi/spi.c:		spi->mode |= SPI_CPHA;
drivers/spi/spi.c:	struct spi_controller *ctlr = spi->controller;
drivers/spi/spi.c:				spi->chip_select = cs;
drivers/spi/spi.c:				spi->chip_select = sb->device_selection;
drivers/spi/spi.c:			spi->max_speed_hz = sb->connection_speed;
drivers/spi/spi.c:				spi->mode |= SPI_CPHA;
drivers/spi/spi.c:				spi->mode |= SPI_CPOL;
drivers/spi/spi.c:				spi->mode |= SPI_CS_HIGH;
drivers/spi/spi.c:	} else if (spi->irq < 0) {
drivers/spi/spi.c:			spi->irq = r.start;
drivers/spi/spi.c:	ACPI_COMPANION_SET(&spi->dev, adev);
drivers/spi/spi.c:	spi->irq = -1;
drivers/spi/spi.c:	if (ret < 0 || !spi->max_speed_hz) {
drivers/spi/spi.c:	acpi_set_modalias(adev, acpi_device_hid(adev), spi->modalias,
drivers/spi/spi.c:			  sizeof(spi->modalias));
drivers/spi/spi.c:	if (spi->irq < 0)
drivers/spi/spi.c:		spi->irq = acpi_dev_gpio_irq_get(adev, 0);
drivers/spi/spi.c:	struct spi_controller *ctlr = spi->controller;
drivers/spi/spi.c:		strlcpy(spi->modalias, name, sizeof(spi->modalias));
drivers/spi/spi.c:			dev_err(&msg->spi->dev,
drivers/spi/spi.c:	dev_warn_once(&msg->spi->dev,
drivers/spi/spi.c:	SPI_STATISTICS_INCREMENT_FIELD(&msg->spi->statistics,
drivers/spi/spi.c:	if (((spi->mode & SPI_TX_DUAL) && (spi->mode & SPI_TX_QUAD)) ||
drivers/spi/spi.c:		((spi->mode & SPI_RX_DUAL) && (spi->mode & SPI_RX_QUAD))) {
drivers/spi/spi.c:		dev_err(&spi->dev,
drivers/spi/spi.c:	if ((spi->mode & SPI_3WIRE) && (spi->mode &
drivers/spi/spi.c:	bad_bits = spi->mode & ~spi->controller->mode_bits;
drivers/spi/spi.c:		dev_warn(&spi->dev,
drivers/spi/spi.c:		spi->mode &= ~ugly_bits;
drivers/spi/spi.c:		dev_err(&spi->dev, "setup: unsupported mode bits %x\n",
drivers/spi/spi.c:	if (!spi->bits_per_word)
drivers/spi/spi.c:		spi->bits_per_word = 8;
drivers/spi/spi.c:	status = __spi_validate_bits_per_word(spi->controller,
drivers/spi/spi.c:					      spi->bits_per_word);
drivers/spi/spi.c:	if (!spi->max_speed_hz)
drivers/spi/spi.c:		spi->max_speed_hz = spi->controller->max_speed_hz;
drivers/spi/spi.c:	if (spi->controller->setup)
drivers/spi/spi.c:		status = spi->controller->setup(spi);
drivers/spi/spi.c:	dev_dbg(&spi->dev, "setup mode %d, %s%s%s%s%u bits/w, %u Hz max --> %d\n",
drivers/spi/spi.c:			(int) (spi->mode & (SPI_CPOL | SPI_CPHA)),
drivers/spi/spi.c:			(spi->mode & SPI_CS_HIGH) ? "cs_high, " : "",
drivers/spi/spi.c:			(spi->mode & SPI_LSB_FIRST) ? "lsb, " : "",
drivers/spi/spi.c:			(spi->mode & SPI_3WIRE) ? "3wire, " : "",
drivers/spi/spi.c:			(spi->mode & SPI_LOOP) ? "loopback, " : "",
drivers/spi/spi.c:			spi->bits_per_word, spi->max_speed_hz,
drivers/spi/spi.c:	struct spi_controller *ctlr = spi->controller;
drivers/spi/spi.c:	    (spi->mode & SPI_3WIRE)) {
drivers/spi/spi.c:			xfer->bits_per_word = spi->bits_per_word;
drivers/spi/spi.c:			xfer->speed_hz = spi->max_speed_hz;
drivers/spi/spi.c:				!(spi->mode & (SPI_TX_DUAL | SPI_TX_QUAD)))
drivers/spi/spi.c:				!(spi->mode & SPI_TX_QUAD))
drivers/spi/spi.c:				!(spi->mode & (SPI_RX_DUAL | SPI_RX_QUAD)))
drivers/spi/spi.c:				!(spi->mode & SPI_RX_QUAD))
drivers/spi/spi.c:	struct spi_controller *ctlr = spi->controller;
drivers/spi/spi.c:	SPI_STATISTICS_INCREMENT_FIELD(&spi->statistics, spi_async);
drivers/spi/spi.c:	struct spi_controller *ctlr = spi->controller;
drivers/spi/spi.c:	struct spi_controller *ctlr = spi->controller;
drivers/spi/spi.c:	struct spi_controller *master = spi->controller;
drivers/spi/spi.c:	    !(spi->mode & (SPI_TX_DUAL | SPI_TX_QUAD)))
drivers/spi/spi.c:	    !(spi->mode & SPI_TX_QUAD))
drivers/spi/spi.c:	    !(spi->mode & (SPI_RX_DUAL | SPI_RX_QUAD)))
drivers/spi/spi.c:	    !(spi->mode &  SPI_RX_QUAD))
drivers/spi/spi.c:	struct spi_controller *ctlr = spi->controller;
drivers/spi/spi.c:	SPI_STATISTICS_INCREMENT_FIELD(&spi->statistics, spi_sync);
drivers/spi/spi.c:			SPI_STATISTICS_INCREMENT_FIELD(&spi->statistics,
drivers/spi/spi.c:	mutex_lock(&spi->controller->bus_lock_mutex);
drivers/spi/spi.c:	mutex_unlock(&spi->controller->bus_lock_mutex);
drivers/spi/spi.c:		put_device(&spi->dev);
drivers/spi/spi.c:		put_device(&spi->dev);
drivers/spi/spi-txx9.c:	int val = (spi->mode & SPI_CS_HIGH) ? on : !on;
drivers/spi/spi-txx9.c:		c->last_chipselect = spi->chip_select;
drivers/spi/spi-txx9.c:	gpio_set_value(spi->chip_select, val);
drivers/spi/spi-txx9.c:	struct txx9spi *c = spi_master_get_devdata(spi->master);
drivers/spi/spi-txx9.c:	if (!spi->max_speed_hz)
drivers/spi/spi-txx9.c:	if (gpio_direction_output(spi->chip_select,
drivers/spi/spi-txx9.c:			!(spi->mode & SPI_CS_HIGH))) {
drivers/spi/spi-txx9.c:		dev_err(&spi->dev, "Cannot setup GPIO for chipselect.\n");
drivers/spi/spi-txx9.c:	txx9spi_cs_func(spi, c, 0, (NSEC_PER_SEC / 2) / spi->max_speed_hz);
drivers/spi/spi-txx9.c:	cs_delay = 100 + (NSEC_PER_SEC / 2) / spi->max_speed_hz;
drivers/spi/spi-txx9.c:		dev_err(&spi->dev, "Bad mode.\n");
drivers/spi/spi-txx9.c:			| ((spi->mode & SPI_CPOL) ? TXx9_SPCR0_SPOL : 0)
drivers/spi/spi-txx9.c:			| ((spi->mode & SPI_CPHA) ? TXx9_SPCR0_SPHA : 0)
drivers/spi/spi-txx9.c:	struct spi_master *master = spi->master;
drivers/spi/spi-txx9.c:	c->clk = devm_clk_get(&dev->dev, "spi-baseclk");
drivers/spi/spi-txx9.c:	/* the spi->mode bits understood by this driver: */
drivers/spi/spi-sun4i.c:	return readl(sspi->base_addr + reg);
drivers/spi/spi-sun4i.c:	writel(value, sspi->base_addr + reg);
drivers/spi/spi-sun4i.c:		byte = readb(sspi->base_addr + SUN4I_RXDATA_REG);
drivers/spi/spi-sun4i.c:		if (sspi->rx_buf)
drivers/spi/spi-sun4i.c:			*sspi->rx_buf++ = byte;
drivers/spi/spi-sun4i.c:	len = min3(len, (int)cnt, sspi->len);
drivers/spi/spi-sun4i.c:		byte = sspi->tx_buf ? *sspi->tx_buf++ : 0;
drivers/spi/spi-sun4i.c:		writeb(byte, sspi->base_addr + SUN4I_TXDATA_REG);
drivers/spi/spi-sun4i.c:		sspi->len--;
drivers/spi/spi-sun4i.c:	struct sun4i_spi *sspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-sun4i.c:	reg |= SUN4I_CTL_CS(spi->chip_select);
drivers/spi/spi-sun4i.c:	if (spi->mode & SPI_CS_HIGH)
drivers/spi/spi-sun4i.c:	reinit_completion(&sspi->done);
drivers/spi/spi-sun4i.c:	sspi->tx_buf = tfr->tx_buf;
drivers/spi/spi-sun4i.c:	sspi->rx_buf = tfr->rx_buf;
drivers/spi/spi-sun4i.c:	sspi->len = tfr->len;
drivers/spi/spi-sun4i.c:	if (spi->mode & SPI_CPOL)
drivers/spi/spi-sun4i.c:	if (spi->mode & SPI_CPHA)
drivers/spi/spi-sun4i.c:	if (spi->mode & SPI_LSB_FIRST)
drivers/spi/spi-sun4i.c:	if (sspi->rx_buf)
drivers/spi/spi-sun4i.c:	mclk_rate = clk_get_rate(sspi->mclk);
drivers/spi/spi-sun4i.c:		clk_set_rate(sspi->mclk, 2 * tfr->speed_hz);
drivers/spi/spi-sun4i.c:		mclk_rate = clk_get_rate(sspi->mclk);
drivers/spi/spi-sun4i.c:	if (sspi->tx_buf)
drivers/spi/spi-sun4i.c:	timeout = wait_for_completion_timeout(&sspi->done,
drivers/spi/spi-sun4i.c:			 dev_name(&spi->dev), tfr->len, tfr->speed_hz,
drivers/spi/spi-sun4i.c:		complete(&sspi->done);
drivers/spi/spi-sun4i.c:		if (!sspi->len)
drivers/spi/spi-sun4i.c:	ret = clk_prepare_enable(sspi->hclk);
drivers/spi/spi-sun4i.c:	ret = clk_prepare_enable(sspi->mclk);
drivers/spi/spi-sun4i.c:	clk_disable_unprepare(sspi->hclk);
drivers/spi/spi-sun4i.c:	clk_disable_unprepare(sspi->mclk);
drivers/spi/spi-sun4i.c:	clk_disable_unprepare(sspi->hclk);
drivers/spi/spi-sun4i.c:	sspi->base_addr = devm_ioremap_resource(&pdev->dev, res);
drivers/spi/spi-sun4i.c:	if (IS_ERR(sspi->base_addr)) {
drivers/spi/spi-sun4i.c:		ret = PTR_ERR(sspi->base_addr);
drivers/spi/spi-sun4i.c:	sspi->master = master;
drivers/spi/spi-sun4i.c:	sspi->hclk = devm_clk_get(&pdev->dev, "ahb");
drivers/spi/spi-sun4i.c:	if (IS_ERR(sspi->hclk)) {
drivers/spi/spi-sun4i.c:		ret = PTR_ERR(sspi->hclk);
drivers/spi/spi-sun4i.c:	sspi->mclk = devm_clk_get(&pdev->dev, "mod");
drivers/spi/spi-sun4i.c:	if (IS_ERR(sspi->mclk)) {
drivers/spi/spi-sun4i.c:		ret = PTR_ERR(sspi->mclk);
drivers/spi/spi-sun4i.c:	init_completion(&sspi->done);
drivers/spi/spi-falcon.c:	struct device *dev = &spi->dev;
drivers/spi/spi-falcon.c:	struct falcon_sflash *priv = spi_master_get_devdata(spi->master);
drivers/spi/spi-falcon.c:				priv->sfcmd = ((spi->chip_select
drivers/spi/spi-falcon.c:	if (spi->max_speed_hz >= CLOCK_100M) {
drivers/spi/spi-falcon.c:			if (CLOCK_50M / i <= spi->max_speed_hz)
drivers/spi/spi-bcm2835.c: * spi-ath79.c, Copyright (C) 2009-2011 Gabor Juhos <juhosg@openwrt.org>
drivers/spi/spi-bcm2835.c: * spi-atmel.c, Copyright (C) 2006 Atmel Corporation
drivers/spi/spi-bcm2835.c:#define DRV_NAME	"spi-bcm2835"
drivers/spi/spi-bcm2835.c:	if (gpio_is_valid(spi->cs_gpio)) {
drivers/spi/spi-bcm2835.c:		dev_warn_once(&spi->dev,
drivers/spi/spi-bcm2835.c:	if (!gpio_is_valid(spi->cs_gpio))
drivers/spi/spi-bcm2835.c:		dev_warn_once(&spi->dev,
drivers/spi/spi-bcm2835.c:		dev_warn_once(&spi->dev,
drivers/spi/spi-bcm2835.c:		dev_warn_once(&spi->dev,
drivers/spi/spi-bcm2835.c:			dev_dbg_ratelimited(&spi->dev,
drivers/spi/spi-bcm2835.c:	if ((spi->mode & SPI_3WIRE) && (tfr->rx_buf))
drivers/spi/spi-bcm2835.c:	if (gpio_is_valid(spi->cs_gpio) || (spi->mode & SPI_NO_CS))
drivers/spi/spi-bcm2835.c:	if (spi->mode & SPI_CPOL)
drivers/spi/spi-bcm2835.c:	if (spi->mode & SPI_CPHA)
drivers/spi/spi-bcm2835.c:	struct spi_master *master = spi->master;
drivers/spi/spi-bcm2835.c:	enable = (spi->mode & SPI_CS_HIGH) ? gpio_level : !gpio_level;
drivers/spi/spi-bcm2835.c:	if (spi->mode & SPI_CS_HIGH) {
drivers/spi/spi-bcm2835.c:		cs |= BCM2835_SPI_CS_CSPOL0 << spi->chip_select;
drivers/spi/spi-bcm2835.c:		cs &= ~(BCM2835_SPI_CS_CSPOL0 << spi->chip_select);
drivers/spi/spi-bcm2835.c:		if (spi->mode & SPI_NO_CS) {
drivers/spi/spi-bcm2835.c:			cs |= spi->chip_select;
drivers/spi/spi-bcm2835.c:	if (spi->mode & SPI_NO_CS)
drivers/spi/spi-bcm2835.c:	if (gpio_is_valid(spi->cs_gpio))
drivers/spi/spi-bcm2835.c:	if (spi->chip_select > 1) {
drivers/spi/spi-bcm2835.c:		dev_err(&spi->dev,
drivers/spi/spi-bcm2835.c:	spi->cs_gpio = chip->base + 8 - spi->chip_select;
drivers/spi/spi-bcm2835.c:	dev_info(&spi->dev, "setting up native-CS%i as GPIO %i\n",
drivers/spi/spi-bcm2835.c:		 spi->chip_select, spi->cs_gpio);
drivers/spi/spi-bcm2835.c:	err = gpio_direction_output(spi->cs_gpio,
drivers/spi/spi-bcm2835.c:				    (spi->mode & SPI_CS_HIGH) ? 0 : 1);
drivers/spi/spi-bcm2835.c:		dev_err(&spi->dev,
drivers/spi/spi-bcm2835.c:			spi->chip_select, spi->cs_gpio, err);
drivers/spi/spi-mxs.c: * Based on spi-stmp.c, which is:
drivers/spi/spi-mxs.c:	struct mxs_ssp *ssp = &spi->ssp;
drivers/spi/spi-mxs.c:	if (hz != spi->sck) {
drivers/spi/spi-mxs.c:		spi->sck = hz;
drivers/spi/spi-mxs.c:	struct mxs_ssp *ssp = &spi->ssp;
drivers/spi/spi-mxs.c:	complete(&spi->c);
drivers/spi/spi-mxs.c:	struct mxs_ssp *ssp = &spi->ssp;
drivers/spi/spi-mxs.c:	reinit_completion(&spi->c);
drivers/spi/spi-mxs.c:	if (!wait_for_completion_timeout(&spi->c,
drivers/spi/spi-mxs.c:	struct mxs_ssp *ssp = &spi->ssp;
drivers/spi/spi-mxs.c:	struct mxs_ssp *ssp = &spi->ssp;
drivers/spi/spi-mxs.c:	writel(mxs_spi_cs_to_reg(m->spi->chip_select),
drivers/spi/spi-mxs.c:	struct mxs_ssp *ssp = &spi->ssp;
drivers/spi/spi-mxs.c:	struct mxs_ssp *ssp = &spi->ssp;
drivers/spi/spi-mxs.c:	ssp = &spi->ssp;
drivers/spi/spi-mxs.c:	init_completion(&spi->c);
drivers/spi/spi-mxs.c:	ssp = &spi->ssp;
drivers/spi/spi-zynqmp-gqspi.c:	return readl_relaxed(xqspi->regs + offset);
drivers/spi/spi-zynqmp-gqspi.c:	writel_relaxed(val, (xqspi->regs + offset));
drivers/spi/spi-zynqmp-gqspi.c:	memcpy(xqspi->rxbuf, &data, size);
drivers/spi/spi-zynqmp-gqspi.c:	xqspi->rxbuf += size;
drivers/spi/spi-zynqmp-gqspi.c:	xqspi->bytes_to_receive -= size;
drivers/spi/spi-zynqmp-gqspi.c:	ret = clk_enable(xqspi->refclk);
drivers/spi/spi-zynqmp-gqspi.c:	ret = clk_enable(xqspi->pclk);
drivers/spi/spi-zynqmp-gqspi.c:	clk_disable(xqspi->refclk);
drivers/spi/spi-zynqmp-gqspi.c:	clk_disable(xqspi->refclk);
drivers/spi/spi-zynqmp-gqspi.c:	clk_disable(xqspi->pclk);
drivers/spi/spi-zynqmp-gqspi.c:	struct zynqmp_qspi *xqspi = spi_master_get_devdata(qspi->master);
drivers/spi/spi-zynqmp-gqspi.c:	genfifoentry |= xqspi->genfifobus;
drivers/spi/spi-zynqmp-gqspi.c:		genfifoentry |= xqspi->genfifocs;
drivers/spi/spi-zynqmp-gqspi.c:		dev_err(xqspi->dev, "Chip select timed out\n");
drivers/spi/spi-zynqmp-gqspi.c:	struct zynqmp_qspi *xqspi = spi_master_get_devdata(qspi->master);
drivers/spi/spi-zynqmp-gqspi.c:		req_hz = qspi->max_speed_hz;
drivers/spi/spi-zynqmp-gqspi.c:	clk_rate = clk_get_rate(xqspi->refclk);
drivers/spi/spi-zynqmp-gqspi.c:	if (qspi->mode & SPI_CPHA)
drivers/spi/spi-zynqmp-gqspi.c:	if (qspi->mode & SPI_CPOL)
drivers/spi/spi-zynqmp-gqspi.c:	if (qspi->master->busy)
drivers/spi/spi-zynqmp-gqspi.c:	while ((xqspi->bytes_to_transfer > 0) && (count < size)) {
drivers/spi/spi-zynqmp-gqspi.c:		memcpy(&intermediate, xqspi->txbuf, 4);
drivers/spi/spi-zynqmp-gqspi.c:		if (xqspi->bytes_to_transfer >= 4) {
drivers/spi/spi-zynqmp-gqspi.c:			xqspi->txbuf += 4;
drivers/spi/spi-zynqmp-gqspi.c:			xqspi->bytes_to_transfer -= 4;
drivers/spi/spi-zynqmp-gqspi.c:			xqspi->txbuf += xqspi->bytes_to_transfer;
drivers/spi/spi-zynqmp-gqspi.c:			xqspi->bytes_to_transfer = 0;
drivers/spi/spi-zynqmp-gqspi.c:	while ((count < size) && (xqspi->bytes_to_receive > 0)) {
drivers/spi/spi-zynqmp-gqspi.c:		if (xqspi->bytes_to_receive >= 4) {
drivers/spi/spi-zynqmp-gqspi.c:			(*(u32 *) xqspi->rxbuf) =
drivers/spi/spi-zynqmp-gqspi.c:			xqspi->rxbuf += 4;
drivers/spi/spi-zynqmp-gqspi.c:			xqspi->bytes_to_receive -= 4;
drivers/spi/spi-zynqmp-gqspi.c:			count += xqspi->bytes_to_receive;
drivers/spi/spi-zynqmp-gqspi.c:						   xqspi->bytes_to_receive);
drivers/spi/spi-zynqmp-gqspi.c:			xqspi->bytes_to_receive = 0;
drivers/spi/spi-zynqmp-gqspi.c:	dma_unmap_single(xqspi->dev, xqspi->dma_addr,
drivers/spi/spi-zynqmp-gqspi.c:				xqspi->dma_rx_bytes, DMA_FROM_DEVICE);
drivers/spi/spi-zynqmp-gqspi.c:	xqspi->rxbuf += xqspi->dma_rx_bytes;
drivers/spi/spi-zynqmp-gqspi.c:	xqspi->bytes_to_receive -= xqspi->dma_rx_bytes;
drivers/spi/spi-zynqmp-gqspi.c:	xqspi->dma_rx_bytes = 0;
drivers/spi/spi-zynqmp-gqspi.c:	if (xqspi->bytes_to_receive > 0) {
drivers/spi/spi-zynqmp-gqspi.c:		genfifoentry = xqspi->genfifoentry;
drivers/spi/spi-zynqmp-gqspi.c:		genfifoentry |= xqspi->bytes_to_receive;
drivers/spi/spi-zynqmp-gqspi.c:	if (xqspi->mode == GQSPI_MODE_DMA) {
drivers/spi/spi-zynqmp-gqspi.c:	if ((xqspi->bytes_to_receive == 0) && (xqspi->bytes_to_transfer == 0)
drivers/spi/spi-zynqmp-gqspi.c:		dev_warn(xqspi->dev, "Invalid SPI mode\n");
drivers/spi/spi-zynqmp-gqspi.c:	u64 dma_align =  (u64)(uintptr_t)xqspi->rxbuf;
drivers/spi/spi-zynqmp-gqspi.c:	if ((xqspi->bytes_to_receive < 8) ||
drivers/spi/spi-zynqmp-gqspi.c:		xqspi->mode = GQSPI_MODE_IO;
drivers/spi/spi-zynqmp-gqspi.c:		xqspi->dma_rx_bytes = 0;
drivers/spi/spi-zynqmp-gqspi.c:	rx_rem = xqspi->bytes_to_receive % 4;
drivers/spi/spi-zynqmp-gqspi.c:	rx_bytes = (xqspi->bytes_to_receive - rx_rem);
drivers/spi/spi-zynqmp-gqspi.c:	addr = dma_map_single(xqspi->dev, (void *)xqspi->rxbuf,
drivers/spi/spi-zynqmp-gqspi.c:	if (dma_mapping_error(xqspi->dev, addr))
drivers/spi/spi-zynqmp-gqspi.c:		dev_err(xqspi->dev, "ERR:rxdma:memory not mapped\n");
drivers/spi/spi-zynqmp-gqspi.c:	xqspi->dma_rx_bytes = rx_bytes;
drivers/spi/spi-zynqmp-gqspi.c:	xqspi->dma_addr = addr;
drivers/spi/spi-zynqmp-gqspi.c:	xqspi->mode = GQSPI_MODE_DMA;
drivers/spi/spi-zynqmp-gqspi.c:	if ((xqspi->txbuf != NULL) && (xqspi->rxbuf == NULL)) {
drivers/spi/spi-zynqmp-gqspi.c:		xqspi->bytes_to_transfer = transfer->len;
drivers/spi/spi-zynqmp-gqspi.c:		if (xqspi->mode == GQSPI_MODE_DMA) {
drivers/spi/spi-zynqmp-gqspi.c:			xqspi->mode = GQSPI_MODE_IO;
drivers/spi/spi-zynqmp-gqspi.c:		xqspi->bytes_to_receive = 0;
drivers/spi/spi-zynqmp-gqspi.c:	} else if ((xqspi->txbuf == NULL) && (xqspi->rxbuf != NULL)) {
drivers/spi/spi-zynqmp-gqspi.c:		xqspi->bytes_to_transfer = 0;
drivers/spi/spi-zynqmp-gqspi.c:		xqspi->bytes_to_receive = transfer->len;
drivers/spi/spi-zynqmp-gqspi.c:	xqspi->txbuf = transfer->tx_buf;
drivers/spi/spi-zynqmp-gqspi.c:	xqspi->rxbuf = transfer->rx_buf;
drivers/spi/spi-zynqmp-gqspi.c:	genfifoentry |= xqspi->genfifocs;
drivers/spi/spi-zynqmp-gqspi.c:	genfifoentry |= xqspi->genfifobus;
drivers/spi/spi-zynqmp-gqspi.c:	if (xqspi->mode == GQSPI_MODE_DMA)
drivers/spi/spi-zynqmp-gqspi.c:		transfer_len = xqspi->dma_rx_bytes;
drivers/spi/spi-zynqmp-gqspi.c:	xqspi->genfifoentry = genfifoentry;
drivers/spi/spi-zynqmp-gqspi.c:	if ((xqspi->mode == GQSPI_MODE_IO) &&
drivers/spi/spi-zynqmp-gqspi.c:			(xqspi->rxbuf != NULL)) {
drivers/spi/spi-zynqmp-gqspi.c:	if (xqspi->txbuf != NULL)
drivers/spi/spi-zynqmp-gqspi.c:	if (xqspi->rxbuf != NULL) {
drivers/spi/spi-zynqmp-gqspi.c:		if (xqspi->mode == GQSPI_MODE_DMA) {
drivers/spi/spi-zynqmp-gqspi.c:	ret = clk_enable(xqspi->pclk);
drivers/spi/spi-zynqmp-gqspi.c:	ret = clk_enable(xqspi->refclk);
drivers/spi/spi-zynqmp-gqspi.c:		clk_disable(xqspi->pclk);
drivers/spi/spi-zynqmp-gqspi.c:	xqspi->regs = devm_ioremap_resource(&pdev->dev, res);
drivers/spi/spi-zynqmp-gqspi.c:	if (IS_ERR(xqspi->regs)) {
drivers/spi/spi-zynqmp-gqspi.c:		ret = PTR_ERR(xqspi->regs);
drivers/spi/spi-zynqmp-gqspi.c:	xqspi->dev = dev;
drivers/spi/spi-zynqmp-gqspi.c:	xqspi->pclk = devm_clk_get(&pdev->dev, "pclk");
drivers/spi/spi-zynqmp-gqspi.c:	if (IS_ERR(xqspi->pclk)) {
drivers/spi/spi-zynqmp-gqspi.c:		ret = PTR_ERR(xqspi->pclk);
drivers/spi/spi-zynqmp-gqspi.c:	ret = clk_prepare_enable(xqspi->pclk);
drivers/spi/spi-zynqmp-gqspi.c:	xqspi->refclk = devm_clk_get(&pdev->dev, "ref_clk");
drivers/spi/spi-zynqmp-gqspi.c:	if (IS_ERR(xqspi->refclk)) {
drivers/spi/spi-zynqmp-gqspi.c:		ret = PTR_ERR(xqspi->refclk);
drivers/spi/spi-zynqmp-gqspi.c:	ret = clk_prepare_enable(xqspi->refclk);
drivers/spi/spi-zynqmp-gqspi.c:	xqspi->irq = platform_get_irq(pdev, 0);
drivers/spi/spi-zynqmp-gqspi.c:	if (xqspi->irq <= 0) {
drivers/spi/spi-zynqmp-gqspi.c:	ret = devm_request_irq(&pdev->dev, xqspi->irq, zynqmp_qspi_irq,
drivers/spi/spi-zynqmp-gqspi.c:	master->max_speed_hz = clk_get_rate(xqspi->refclk) / 2;
drivers/spi/spi-zynqmp-gqspi.c:	clk_disable_unprepare(xqspi->refclk);
drivers/spi/spi-zynqmp-gqspi.c:	clk_disable_unprepare(xqspi->pclk);
drivers/spi/spi-zynqmp-gqspi.c:	clk_disable_unprepare(xqspi->refclk);
drivers/spi/spi-zynqmp-gqspi.c:	clk_disable_unprepare(xqspi->pclk);
drivers/spi/spi-zynqmp-gqspi.c:	{ .compatible = "xlnx,zynqmp-qspi-1.0", },
drivers/spi/.spi-bitbang.o.cmd:cmd_drivers/spi/spi-bitbang.o := arm-linux-gnueabi-gcc -Wp,-MD,drivers/spi/.spi-bitbang.o.d  -nostdinc -isystem /usr/lib/gcc-cross/arm-linux-gnueabi/7/include -I./arch/arm/include -I./arch/arm/include/generated  -I./include -I./arch/arm/include/uapi -I./arch/arm/include/generated/uapi -I./include/uapi -I./include/generated/uapi -include ./include/linux/kconfig.h -D__KERNEL__ -mlittle-endian -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -fshort-wchar -Werror-implicit-function-declaration -Wno-format-security -std=gnu89 -fno-PIE -fno-dwarf2-cfi-asm -fno-ipa-sra -mabi=aapcs-linux -mno-thumb-interwork -mfpu=vfp -funwind-tables -marm -Wa,-mno-warn-deprecated -D__LINUX_ARM_ARCH__=5 -march=armv5te -mtune=arm9tdmi -msoft-float -Uarm -fno-delete-null-pointer-checks -Wno-frame-address -Wno-format-truncation -Wno-format-overflow -Wno-int-in-bool-context -O2 --param=allow-store-data-races=0 -DCC_HAVE_ASM_GOTO -Wframe-larger-than=1024 -fno-stack-protector -Wno-unused-but-set-variable -Wno-unused-const-variable -fomit-frame-pointer -fno-var-tracking-assignments -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fno-stack-check -fconserve-stack -Werror=implicit-int -Werror=strict-prototypes -Werror=date-time -Werror=incompatible-pointer-types -Werror=designated-init    -DKBUILD_BASENAME='"spi_bitbang"'  -DKBUILD_MODNAME='"spi_bitbang"' -c -o drivers/spi/spi-bitbang.o drivers/spi/spi-bitbang.c
drivers/spi/.spi-bitbang.o.cmd:source_drivers/spi/spi-bitbang.o := drivers/spi/spi-bitbang.c
drivers/spi/.spi-bitbang.o.cmd:deps_drivers/spi/spi-bitbang.o := \
drivers/spi/.spi-bitbang.o.cmd:drivers/spi/spi-bitbang.o: $(deps_drivers/spi/spi-bitbang.o)
drivers/spi/.spi-bitbang.o.cmd:$(deps_drivers/spi/spi-bitbang.o):
drivers/spi/spi-slave-time.c:	dev_info(&priv->spi->dev, "Terminating\n");
drivers/spi/spi-slave-time.c:		dev_err(&priv->spi->dev, "spi_async() failed %d\n", ret);
drivers/spi/spi-slave-time.c:	priv = devm_kzalloc(&spi->dev, sizeof(*priv), GFP_KERNEL);
drivers/spi/spi-slave-time.c:		.name	= "spi-slave-time",
drivers/spi/spi-omap-uwire.c:	struct	uwire_state *ust = spi->controller_state;
drivers/spi/spi-omap-uwire.c:	if (value == BITBANG_CS_INACTIVE || old_cs != spi->chip_select) {
drivers/spi/spi-omap-uwire.c:		if (spi->mode & SPI_CPOL)
drivers/spi/spi-omap-uwire.c:		w = spi->chip_select << 10;
drivers/spi/spi-omap-uwire.c:	w = spi->chip_select << 10;
drivers/spi/spi-omap-uwire.c:					dev_name(&spi->dev), bits, val);
drivers/spi/spi-omap-uwire.c:					dev_name(&spi->dev), bits, val);
drivers/spi/spi-omap-uwire.c:	struct uwire_state	*ust = spi->controller_state;
drivers/spi/spi-omap-uwire.c:	uwire = spi_master_get_devdata(spi->master);
drivers/spi/spi-omap-uwire.c:	if (spi->mode & SPI_CS_HIGH)
drivers/spi/spi-omap-uwire.c:	if (spi->mode & SPI_CPOL)
drivers/spi/spi-omap-uwire.c:	switch (spi->mode & (SPI_CPOL | SPI_CPHA)) {
drivers/spi/spi-omap-uwire.c:		hz = spi->max_speed_hz;
drivers/spi/spi-omap-uwire.c:		pr_debug("%s: zero speed?\n", dev_name(&spi->dev));
drivers/spi/spi-omap-uwire.c:			dev_name(&spi->dev), rate / 10 / 8, hz);
drivers/spi/spi-omap-uwire.c:	omap_uwire_configure_mode(spi->chip_select, flags);
drivers/spi/spi-omap-uwire.c:	struct uwire_state *ust = spi->controller_state;
drivers/spi/spi-omap-uwire.c:		spi->controller_state = ust;
drivers/spi/spi-omap-uwire.c:	kfree(spi->controller_state);
drivers/spi/spi-omap-uwire.c:	/* the spi->mode bits understood by this driver: */
drivers/spi/.spi-sun4i.o.cmd:cmd_drivers/spi/spi-sun4i.o := arm-linux-gnueabi-gcc -Wp,-MD,drivers/spi/.spi-sun4i.o.d  -nostdinc -isystem /usr/lib/gcc-cross/arm-linux-gnueabi/7/include -I./arch/arm/include -I./arch/arm/include/generated  -I./include -I./arch/arm/include/uapi -I./arch/arm/include/generated/uapi -I./include/uapi -I./include/generated/uapi -include ./include/linux/kconfig.h -D__KERNEL__ -mlittle-endian -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -fshort-wchar -Werror-implicit-function-declaration -Wno-format-security -std=gnu89 -fno-PIE -fno-dwarf2-cfi-asm -fno-ipa-sra -mabi=aapcs-linux -mno-thumb-interwork -mfpu=vfp -funwind-tables -marm -Wa,-mno-warn-deprecated -D__LINUX_ARM_ARCH__=5 -march=armv5te -mtune=arm9tdmi -msoft-float -Uarm -fno-delete-null-pointer-checks -Wno-frame-address -Wno-format-truncation -Wno-format-overflow -Wno-int-in-bool-context -O2 --param=allow-store-data-races=0 -DCC_HAVE_ASM_GOTO -Wframe-larger-than=1024 -fno-stack-protector -Wno-unused-but-set-variable -Wno-unused-const-variable -fomit-frame-pointer -fno-var-tracking-assignments -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fno-stack-check -fconserve-stack -Werror=implicit-int -Werror=strict-prototypes -Werror=date-time -Werror=incompatible-pointer-types -Werror=designated-init    -DKBUILD_BASENAME='"spi_sun4i"'  -DKBUILD_MODNAME='"spi_sun4i"' -c -o drivers/spi/spi-sun4i.o drivers/spi/spi-sun4i.c
drivers/spi/.spi-sun4i.o.cmd:source_drivers/spi/spi-sun4i.o := drivers/spi/spi-sun4i.c
drivers/spi/.spi-sun4i.o.cmd:deps_drivers/spi/spi-sun4i.o := \
drivers/spi/.spi-sun4i.o.cmd:drivers/spi/spi-sun4i.o: $(deps_drivers/spi/spi-sun4i.o)
drivers/spi/.spi-sun4i.o.cmd:$(deps_drivers/spi/spi-sun4i.o):
drivers/spi/spi-lm70llp.c: * Also see Documentation/spi/spi-lm70llp.  The SPI<->parport code here is
drivers/spi/spi-lm70llp.c: * (heavily) based on spi-butterfly by David Brownell.
drivers/spi/spi-lm70llp.c:#define DRVNAME		"spi-lm70llp"
drivers/spi/spi-lm70llp.c:	return spi->controller_data;
drivers/spi/spi-lm70llp.c:#include "spi-bitbang-txrx.h"
drivers/spi/spi-test.h: *  linux/drivers/spi/spi-test.h
drivers/spi/spi-au1550.c:	struct au1550_spi *hw = spi_master_get_devdata(spi->master);
drivers/spi/spi-au1550.c:	unsigned cspol = spi->mode & SPI_CS_HIGH ? 1 : 0;
drivers/spi/spi-au1550.c:			hw->pdata->deactivate_cs(hw->pdata, spi->chip_select,
drivers/spi/spi-au1550.c:		au1550_spi_bits_handlers_set(hw, spi->bits_per_word);
drivers/spi/spi-au1550.c:		if (spi->mode & SPI_CPOL)
drivers/spi/spi-au1550.c:		if (spi->mode & SPI_CPHA)
drivers/spi/spi-au1550.c:		if (spi->mode & SPI_LSB_FIRST)
drivers/spi/spi-au1550.c:		if (hw->usedma && spi->bits_per_word <= 8)
drivers/spi/spi-au1550.c:		cfg |= PSC_SPICFG_SET_LEN(spi->bits_per_word);
drivers/spi/spi-au1550.c:		cfg |= au1550_spi_baudcfg(hw, spi->max_speed_hz);
drivers/spi/spi-au1550.c:			hw->pdata->activate_cs(hw->pdata, spi->chip_select,
drivers/spi/spi-au1550.c:	struct au1550_spi *hw = spi_master_get_devdata(spi->master);
drivers/spi/spi-au1550.c:		bpw = spi->bits_per_word;
drivers/spi/spi-au1550.c:		hz = spi->max_speed_hz;
drivers/spi/spi-au1550.c:	au1550_spi_bits_handlers_set(hw, spi->bits_per_word);
drivers/spi/spi-au1550.c:	struct au1550_spi *hw = spi_master_get_devdata(spi->master);
drivers/spi/spi-au1550.c:	struct au1550_spi *hw = spi_master_get_devdata(spi->master);
drivers/spi/spi-au1550.c:	struct au1550_spi *hw = spi_master_get_devdata(spi->master);
drivers/spi/spi-au1550.c:	/* the spi->mode bits understood by this driver: */
drivers/spi/spi-bcm-qspi.c:#include "spi-bcm-qspi.h"
drivers/spi/spi-bcm-qspi.c:	return qspi->bspi_mode;
drivers/spi/spi-bcm-qspi.c:	return bcm_qspi_readl(qspi->big_endian, qspi->base[type] + offset);
drivers/spi/spi-bcm-qspi.c:	bcm_qspi_writel(qspi->big_endian, data, qspi->base[type] + offset);
drivers/spi/spi-bcm-qspi.c:	dev_warn(&qspi->pdev->dev, "timeout waiting for !busy_status\n");
drivers/spi/spi-bcm-qspi.c:	if (qspi->bspi_maj_rev < 4)
drivers/spi/spi-bcm-qspi.c:	u32 *buf = (u32 *)qspi->bspi_rf_msg->buf;
drivers/spi/spi-bcm-qspi.c:	dev_dbg(&qspi->pdev->dev, "xfer %p rx %p rxlen %d\n", qspi->bspi_rf_msg,
drivers/spi/spi-bcm-qspi.c:		qspi->bspi_rf_msg->buf, qspi->bspi_rf_msg_len);
drivers/spi/spi-bcm-qspi.c:		if (likely(qspi->bspi_rf_msg_len >= 4) &&
drivers/spi/spi-bcm-qspi.c:			buf[qspi->bspi_rf_msg_idx++] = data;
drivers/spi/spi-bcm-qspi.c:			qspi->bspi_rf_msg_len -= 4;
drivers/spi/spi-bcm-qspi.c:			u8 *cbuf = (u8 *)&buf[qspi->bspi_rf_msg_idx];
drivers/spi/spi-bcm-qspi.c:			while (qspi->bspi_rf_msg_len) {
drivers/spi/spi-bcm-qspi.c:				qspi->bspi_rf_msg_len--;
drivers/spi/spi-bcm-qspi.c:	dev_dbg(&qspi->pdev->dev, "set flex mode w %x addrlen %x hp %d\n",
drivers/spi/spi-bcm-qspi.c:	dev_dbg(&qspi->pdev->dev, "set override mode w %x addrlen %x hp %d\n",
drivers/spi/spi-bcm-qspi.c:	qspi->xfer_mode.flex_mode = true;
drivers/spi/spi-bcm-qspi.c:		if (val & mask || qspi->s3_strap_override_ctrl & mask) {
drivers/spi/spi-bcm-qspi.c:			qspi->xfer_mode.flex_mode = false;
drivers/spi/spi-bcm-qspi.c:	if (qspi->xfer_mode.flex_mode)
drivers/spi/spi-bcm-qspi.c:		dev_warn(&qspi->pdev->dev,
drivers/spi/spi-bcm-qspi.c:	} else if (qspi->xfer_mode.width != width ||
drivers/spi/spi-bcm-qspi.c:		   qspi->xfer_mode.addrlen != addrlen ||
drivers/spi/spi-bcm-qspi.c:		   qspi->xfer_mode.hp != hp) {
drivers/spi/spi-bcm-qspi.c:		qspi->xfer_mode.width = width;
drivers/spi/spi-bcm-qspi.c:		qspi->xfer_mode.addrlen = addrlen;
drivers/spi/spi-bcm-qspi.c:		qspi->xfer_mode.hp = hp;
drivers/spi/spi-bcm-qspi.c:		dev_dbg(&qspi->pdev->dev,
drivers/spi/spi-bcm-qspi.c:			qspi->curr_cs,
drivers/spi/spi-bcm-qspi.c:			qspi->xfer_mode.width,
drivers/spi/spi-bcm-qspi.c:			qspi->xfer_mode.addrlen,
drivers/spi/spi-bcm-qspi.c:			qspi->xfer_mode.hp != -1 ? ", hp mode" : "");
drivers/spi/spi-bcm-qspi.c:	if (!has_bspi(qspi) || (qspi->bspi_enabled))
drivers/spi/spi-bcm-qspi.c:	qspi->bspi_enabled = 1;
drivers/spi/spi-bcm-qspi.c:	if (!has_bspi(qspi) || (!qspi->bspi_enabled))
drivers/spi/spi-bcm-qspi.c:	qspi->bspi_enabled = 0;
drivers/spi/spi-bcm-qspi.c:	if (qspi->curr_cs == cs)
drivers/spi/spi-bcm-qspi.c:	if (qspi->base[CHIP_SELECT]) {
drivers/spi/spi-bcm-qspi.c:	qspi->curr_cs = cs;
drivers/spi/spi-bcm-qspi.c:		spbr = qspi->base_clk / (2 * xp->speed_hz);
drivers/spi/spi-bcm-qspi.c:	qspi->last_parms = *xp;
drivers/spi/spi-bcm-qspi.c:	xp.mode = spi->mode;
drivers/spi/spi-bcm-qspi.c:	if (spi->bits_per_word > 16)
drivers/spi/spi-bcm-qspi.c:	xp->speed_hz = spi->max_speed_hz;
drivers/spi/spi-bcm-qspi.c:	xp->mode = spi->mode;
drivers/spi/spi-bcm-qspi.c:	if (spi->bits_per_word)
drivers/spi/spi-bcm-qspi.c:		xp->bits_per_word = spi->bits_per_word;
drivers/spi/spi-bcm-qspi.c:	    spi_transfer_is_last(qspi->master, qt->trans))
drivers/spi/spi-bcm-qspi.c:		dev_dbg(&qspi->pdev->dev, "advance msg exit\n");
drivers/spi/spi-bcm-qspi.c:	dev_dbg(&qspi->pdev->dev, "trans %p len %d byte %d ret %x\n",
drivers/spi/spi-bcm-qspi.c:		dev_err(&qspi->pdev->dev, "%s: too many slots!\n", __func__);
drivers/spi/spi-bcm-qspi.c:	tp = qspi->trans_pos;
drivers/spi/spi-bcm-qspi.c:			dev_dbg(&qspi->pdev->dev, "RD %02x\n",
drivers/spi/spi-bcm-qspi.c:			dev_dbg(&qspi->pdev->dev, "RD %04x\n",
drivers/spi/spi-bcm-qspi.c:	qspi->trans_pos = tp;
drivers/spi/spi-bcm-qspi.c:	tp = qspi->trans_pos;
drivers/spi/spi-bcm-qspi.c:			dev_dbg(&qspi->pdev->dev, "WR %02x\n", val);
drivers/spi/spi-bcm-qspi.c:			dev_dbg(&qspi->pdev->dev, "WR %04x\n", val);
drivers/spi/spi-bcm-qspi.c:		mspi_cdram |= (~(1 << spi->chip_select) &
drivers/spi/spi-bcm-qspi.c:		dev_err(&qspi->pdev->dev, "%s: no data to send?", __func__);
drivers/spi/spi-bcm-qspi.c:	dev_dbg(&qspi->pdev->dev, "submitting %d slots\n", slot);
drivers/spi/spi-bcm-qspi.c:	struct bcm_qspi *qspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-bcm-qspi.c:	struct bcm_qspi_soc_intc *soc_intc = qspi->soc_intc;
drivers/spi/spi-bcm-qspi.c:	bcm_qspi_chip_select(qspi, spi->chip_select);
drivers/spi/spi-bcm-qspi.c:	if (!qspi->xfer_mode.flex_mode)
drivers/spi/spi-bcm-qspi.c:	qspi->bspi_rf_msg_idx = 0;
drivers/spi/spi-bcm-qspi.c:		reinit_completion(&qspi->bspi_done);
drivers/spi/spi-bcm-qspi.c:		qspi->bspi_rf_msg = msg;
drivers/spi/spi-bcm-qspi.c:		qspi->bspi_rf_msg_status = 0;
drivers/spi/spi-bcm-qspi.c:		qspi->bspi_rf_msg_len = rdlen;
drivers/spi/spi-bcm-qspi.c:		dev_dbg(&qspi->pdev->dev,
drivers/spi/spi-bcm-qspi.c:		if (qspi->soc_intc) {
drivers/spi/spi-bcm-qspi.c:		if (!wait_for_completion_timeout(&qspi->bspi_done, timeo)) {
drivers/spi/spi-bcm-qspi.c:			dev_err(&qspi->pdev->dev, "timeout waiting for BSPI\n");
drivers/spi/spi-bcm-qspi.c:	bcm_qspi_chip_select(qspi, spi->chip_select);
drivers/spi/spi-bcm-qspi.c:	qspi->trans_pos.trans = trans;
drivers/spi/spi-bcm-qspi.c:	qspi->trans_pos.byte = 0;
drivers/spi/spi-bcm-qspi.c:	while (qspi->trans_pos.byte < trans->len) {
drivers/spi/spi-bcm-qspi.c:		reinit_completion(&qspi->mspi_done);
drivers/spi/spi-bcm-qspi.c:		if (!wait_for_completion_timeout(&qspi->mspi_done, timeo)) {
drivers/spi/spi-bcm-qspi.c:			dev_err(&qspi->pdev->dev, "timeout waiting for MSPI\n");
drivers/spi/spi-bcm-qspi.c:	struct bcm_qspi *qspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-bcm-qspi.c:	t[0].bits_per_word = spi->bits_per_word;
drivers/spi/spi-bcm-qspi.c:	qspi->trans_pos.mspi_last_trans = false;
drivers/spi/spi-bcm-qspi.c:	ret = bcm_qspi_transfer_one(spi->master, spi, &t[0]);
drivers/spi/spi-bcm-qspi.c:	qspi->trans_pos.mspi_last_trans = true;
drivers/spi/spi-bcm-qspi.c:		t[1].bits_per_word = spi->bits_per_word;
drivers/spi/spi-bcm-qspi.c:		ret = bcm_qspi_transfer_one(spi->master, spi, &t[1]);
drivers/spi/spi-bcm-qspi.c:	struct bcm_qspi *qspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-bcm-qspi.c:		struct bcm_qspi_soc_intc *soc_intc = qspi->soc_intc;
drivers/spi/spi-bcm-qspi.c:		if (qspi->soc_intc)
drivers/spi/spi-bcm-qspi.c:		complete(&qspi->mspi_done);
drivers/spi/spi-bcm-qspi.c:	struct bcm_qspi_soc_intc *soc_intc = qspi->soc_intc;
drivers/spi/spi-bcm-qspi.c:	if (qspi->bspi_enabled && qspi->bspi_rf_msg) {
drivers/spi/spi-bcm-qspi.c:		if (qspi->bspi_rf_msg_len == 0) {
drivers/spi/spi-bcm-qspi.c:			qspi->bspi_rf_msg = NULL;
drivers/spi/spi-bcm-qspi.c:			if (qspi->soc_intc) {
drivers/spi/spi-bcm-qspi.c:			if (qspi->bspi_rf_msg_status)
drivers/spi/spi-bcm-qspi.c:		if (qspi->soc_intc)
drivers/spi/spi-bcm-qspi.c:	if (qspi->bspi_enabled && status && qspi->bspi_rf_msg_len == 0)
drivers/spi/spi-bcm-qspi.c:		complete(&qspi->bspi_done);
drivers/spi/spi-bcm-qspi.c:	struct bcm_qspi_soc_intc *soc_intc = qspi->soc_intc;
drivers/spi/spi-bcm-qspi.c:	dev_err(&qspi->pdev->dev, "BSPI INT error\n");
drivers/spi/spi-bcm-qspi.c:	qspi->bspi_rf_msg_status = -EIO;
drivers/spi/spi-bcm-qspi.c:	if (qspi->soc_intc)
drivers/spi/spi-bcm-qspi.c:	complete(&qspi->bspi_done);
drivers/spi/spi-bcm-qspi.c:	struct bcm_qspi_soc_intc *soc_intc = qspi->soc_intc;
drivers/spi/spi-bcm-qspi.c:	qspi->bspi_maj_rev = (val >> 8) & 0xff;
drivers/spi/spi-bcm-qspi.c:	qspi->bspi_min_rev = val & 0xff;
drivers/spi/spi-bcm-qspi.c:	qspi->bspi_enabled = 1;
drivers/spi/spi-bcm-qspi.c:	parms.speed_hz = qspi->max_speed_hz;
drivers/spi/spi-bcm-qspi.c:	{ .compatible = "brcm,spi-bcm-qspi" },
drivers/spi/spi-bcm-qspi.c:	qspi->pdev = pdev;
drivers/spi/spi-bcm-qspi.c:	qspi->trans_pos.trans = NULL;
drivers/spi/spi-bcm-qspi.c:	qspi->trans_pos.byte = 0;
drivers/spi/spi-bcm-qspi.c:	qspi->trans_pos.mspi_last_trans = true;
drivers/spi/spi-bcm-qspi.c:	qspi->master = master;
drivers/spi/spi-bcm-qspi.c:	qspi->big_endian = of_device_is_big_endian(dev->of_node);
drivers/spi/spi-bcm-qspi.c:		qspi->base[MSPI]  = devm_ioremap_resource(dev, res);
drivers/spi/spi-bcm-qspi.c:		if (IS_ERR(qspi->base[MSPI])) {
drivers/spi/spi-bcm-qspi.c:			ret = PTR_ERR(qspi->base[MSPI]);
drivers/spi/spi-bcm-qspi.c:		qspi->base[BSPI]  = devm_ioremap_resource(dev, res);
drivers/spi/spi-bcm-qspi.c:		if (IS_ERR(qspi->base[BSPI])) {
drivers/spi/spi-bcm-qspi.c:			ret = PTR_ERR(qspi->base[BSPI]);
drivers/spi/spi-bcm-qspi.c:		qspi->bspi_mode = true;
drivers/spi/spi-bcm-qspi.c:		qspi->bspi_mode = false;
drivers/spi/spi-bcm-qspi.c:	dev_info(dev, "using %smspi mode\n", qspi->bspi_mode ? "bspi-" : "");
drivers/spi/spi-bcm-qspi.c:		qspi->base[CHIP_SELECT]  = devm_ioremap_resource(dev, res);
drivers/spi/spi-bcm-qspi.c:		if (IS_ERR(qspi->base[CHIP_SELECT])) {
drivers/spi/spi-bcm-qspi.c:			ret = PTR_ERR(qspi->base[CHIP_SELECT]);
drivers/spi/spi-bcm-qspi.c:	qspi->dev_ids = kcalloc(num_irqs, sizeof(struct bcm_qspi_dev_id),
drivers/spi/spi-bcm-qspi.c:	if (!qspi->dev_ids) {
drivers/spi/spi-bcm-qspi.c:					       &qspi->dev_ids[val]);
drivers/spi/spi-bcm-qspi.c:			qspi->dev_ids[val].dev = qspi;
drivers/spi/spi-bcm-qspi.c:			qspi->dev_ids[val].irqp = &qspi_irq_tab[val];
drivers/spi/spi-bcm-qspi.c:		qspi->soc_intc = soc_intc;
drivers/spi/spi-bcm-qspi.c:		qspi->soc_intc = NULL;
drivers/spi/spi-bcm-qspi.c:	qspi->clk = devm_clk_get(&pdev->dev, NULL);
drivers/spi/spi-bcm-qspi.c:	if (IS_ERR(qspi->clk)) {
drivers/spi/spi-bcm-qspi.c:		ret = PTR_ERR(qspi->clk);
drivers/spi/spi-bcm-qspi.c:	ret = clk_prepare_enable(qspi->clk);
drivers/spi/spi-bcm-qspi.c:	qspi->base_clk = clk_get_rate(qspi->clk);
drivers/spi/spi-bcm-qspi.c:	qspi->max_speed_hz = qspi->base_clk / (QSPI_SPBR_MIN * 2);
drivers/spi/spi-bcm-qspi.c:	init_completion(&qspi->mspi_done);
drivers/spi/spi-bcm-qspi.c:	init_completion(&qspi->bspi_done);
drivers/spi/spi-bcm-qspi.c:	qspi->curr_cs = -1;
drivers/spi/spi-bcm-qspi.c:	qspi->xfer_mode.width = -1;
drivers/spi/spi-bcm-qspi.c:	qspi->xfer_mode.addrlen = -1;
drivers/spi/spi-bcm-qspi.c:	qspi->xfer_mode.hp = -1;
drivers/spi/spi-bcm-qspi.c:	clk_disable_unprepare(qspi->clk);
drivers/spi/spi-bcm-qspi.c:	kfree(qspi->dev_ids);
drivers/spi/spi-bcm-qspi.c:	clk_disable_unprepare(qspi->clk);
drivers/spi/spi-bcm-qspi.c:	kfree(qspi->dev_ids);
drivers/spi/spi-bcm-qspi.c:	spi_unregister_master(qspi->master);
drivers/spi/spi-bcm-qspi.c:		qspi->s3_strap_override_ctrl =
drivers/spi/spi-bcm-qspi.c:	spi_master_suspend(qspi->master);
drivers/spi/spi-bcm-qspi.c:	clk_disable(qspi->clk);
drivers/spi/spi-bcm-qspi.c:	bcm_qspi_chip_select(qspi, qspi->curr_cs);
drivers/spi/spi-bcm-qspi.c:	if (qspi->soc_intc)
drivers/spi/spi-bcm-qspi.c:		qspi->soc_intc->bcm_qspi_int_set(qspi->soc_intc, MSPI_DONE,
drivers/spi/spi-bcm-qspi.c:	ret = clk_enable(qspi->clk);
drivers/spi/spi-bcm-qspi.c:		spi_master_resume(qspi->master);
drivers/spi/spi-armada-3700.c:	return readl(a3700_spi->base + offset);
drivers/spi/spi-armada-3700.c:	writel(data, a3700_spi->base + offset);
drivers/spi/spi-armada-3700.c:		dev_err(&a3700_spi->master->dev, "wrong pin mode %u", pin_mode);
drivers/spi/spi-armada-3700.c:	prescale = DIV_ROUND_UP(clk_get_rate(a3700_spi->clk), speed_hz);
drivers/spi/spi-armada-3700.c:	a3700_spi->byte_len = len;
drivers/spi/spi-armada-3700.c:	struct spi_master *master = a3700_spi->master;
drivers/spi/spi-armada-3700.c:	if (!cause || !(a3700_spi->wait_mask & cause))
drivers/spi/spi-armada-3700.c:	complete(&a3700_spi->done);
drivers/spi/spi-armada-3700.c:	a3700_spi = spi_master_get_devdata(spi->master);
drivers/spi/spi-armada-3700.c:	if (a3700_spi->wait_mask & ctrl_reg)
drivers/spi/spi-armada-3700.c:	reinit_completion(&a3700_spi->done);
drivers/spi/spi-armada-3700.c:		     a3700_spi->wait_mask);
drivers/spi/spi-armada-3700.c:	timeout = wait_for_completion_timeout(&a3700_spi->done,
drivers/spi/spi-armada-3700.c:	a3700_spi->wait_mask = 0;
drivers/spi/spi-armada-3700.c:	if (a3700_spi->wait_mask & ctrl_reg)
drivers/spi/spi-armada-3700.c:	a3700_spi = spi_master_get_devdata(spi->master);
drivers/spi/spi-armada-3700.c:	a3700_spi->wait_mask = bit_mask;
drivers/spi/spi-armada-3700.c:	a3700_spi = spi_master_get_devdata(spi->master);
drivers/spi/spi-armada-3700.c:	a3700_spi->tx_buf  = xfer->tx_buf;
drivers/spi/spi-armada-3700.c:	a3700_spi->rx_buf  = xfer->rx_buf;
drivers/spi/spi-armada-3700.c:	a3700_spi->buf_len = xfer->len;
drivers/spi/spi-armada-3700.c:	struct a3700_spi *a3700_spi = spi_master_get_devdata(spi->master);
drivers/spi/spi-armada-3700.c:		a3700_spi_activate_cs(a3700_spi, spi->chip_select);
drivers/spi/spi-armada-3700.c:		a3700_spi_deactivate_cs(a3700_spi, spi->chip_select);
drivers/spi/spi-armada-3700.c:	if (a3700_spi->tx_buf) {
drivers/spi/spi-armada-3700.c:		addr_cnt = a3700_spi->buf_len % 4;
drivers/spi/spi-armada-3700.c:			a3700_spi->buf_len -= addr_cnt;
drivers/spi/spi-armada-3700.c:				val = (val << 8) | a3700_spi->tx_buf[0];
drivers/spi/spi-armada-3700.c:				a3700_spi->tx_buf++;
drivers/spi/spi-armada-3700.c:	while (!a3700_is_wfifo_full(a3700_spi) && a3700_spi->buf_len) {
drivers/spi/spi-armada-3700.c:		val = *(u32 *)a3700_spi->tx_buf;
drivers/spi/spi-armada-3700.c:		a3700_spi->buf_len -= 4;
drivers/spi/spi-armada-3700.c:		a3700_spi->tx_buf += 4;
drivers/spi/spi-armada-3700.c:	while (!a3700_is_rfifo_empty(a3700_spi) && a3700_spi->buf_len) {
drivers/spi/spi-armada-3700.c:		if (a3700_spi->buf_len >= 4) {
drivers/spi/spi-armada-3700.c:			memcpy(a3700_spi->rx_buf, &val, 4);
drivers/spi/spi-armada-3700.c:			a3700_spi->buf_len -= 4;
drivers/spi/spi-armada-3700.c:			a3700_spi->rx_buf += 4;
drivers/spi/spi-armada-3700.c:			while (a3700_spi->buf_len) {
drivers/spi/spi-armada-3700.c:				*a3700_spi->rx_buf = val & 0xff;
drivers/spi/spi-armada-3700.c:				a3700_spi->buf_len--;
drivers/spi/spi-armada-3700.c:				a3700_spi->rx_buf++;
drivers/spi/spi-armada-3700.c:	ret = clk_enable(a3700_spi->clk);
drivers/spi/spi-armada-3700.c:		dev_err(&spi->dev, "failed to enable clk with error %d\n", ret);
drivers/spi/spi-armada-3700.c:	a3700_spi_mode_set(a3700_spi, spi->mode);
drivers/spi/spi-armada-3700.c:			     a3700_spi->buf_len);
drivers/spi/spi-armada-3700.c:		a3700_spi->xmit_data = (a3700_spi->buf_len != 0);
drivers/spi/spi-armada-3700.c:	while (a3700_spi->buf_len) {
drivers/spi/spi-armada-3700.c:		if (a3700_spi->tx_buf) {
drivers/spi/spi-armada-3700.c:				dev_err(&spi->dev,
drivers/spi/spi-armada-3700.c:		} else if (a3700_spi->rx_buf) {
drivers/spi/spi-armada-3700.c:				dev_err(&spi->dev,
drivers/spi/spi-armada-3700.c:	if (a3700_spi->tx_buf) {
drivers/spi/spi-armada-3700.c:		if (a3700_spi->xmit_data) {
drivers/spi/spi-armada-3700.c:				dev_err(&spi->dev, "wait wfifo empty timed out\n");
drivers/spi/spi-armada-3700.c:			dev_err(&spi->dev, "wait xfer ready timed out\n");
drivers/spi/spi-armada-3700.c:		dev_err(&spi->dev, "wait transfer start clear timed out\n");
drivers/spi/spi-armada-3700.c:	while (a3700_spi->buf_len) {
drivers/spi/spi-armada-3700.c:		if (a3700_spi->buf_len < 4)
drivers/spi/spi-armada-3700.c:		if (a3700_spi->byte_len == 1)
drivers/spi/spi-armada-3700.c:			val = *a3700_spi->tx_buf;
drivers/spi/spi-armada-3700.c:			val = *(u32 *)a3700_spi->tx_buf;
drivers/spi/spi-armada-3700.c:		memcpy(a3700_spi->rx_buf, &val, a3700_spi->byte_len);
drivers/spi/spi-armada-3700.c:		a3700_spi->buf_len -= a3700_spi->byte_len;
drivers/spi/spi-armada-3700.c:		a3700_spi->tx_buf += a3700_spi->byte_len;
drivers/spi/spi-armada-3700.c:		a3700_spi->rx_buf += a3700_spi->byte_len;
drivers/spi/spi-armada-3700.c:	clk_disable(a3700_spi->clk);
drivers/spi/spi-armada-3700.c:	spi->master = master;
drivers/spi/spi-armada-3700.c:	spi->base = devm_ioremap_resource(dev, res);
drivers/spi/spi-armada-3700.c:	if (IS_ERR(spi->base)) {
drivers/spi/spi-armada-3700.c:		ret = PTR_ERR(spi->base);
drivers/spi/spi-armada-3700.c:	spi->irq = irq;
drivers/spi/spi-armada-3700.c:	init_completion(&spi->done);
drivers/spi/spi-armada-3700.c:	spi->clk = devm_clk_get(dev, NULL);
drivers/spi/spi-armada-3700.c:	if (IS_ERR(spi->clk)) {
drivers/spi/spi-armada-3700.c:		dev_err(dev, "could not find clk: %ld\n", PTR_ERR(spi->clk));
drivers/spi/spi-armada-3700.c:	ret = clk_prepare(spi->clk);
drivers/spi/spi-armada-3700.c:					clk_get_rate(spi->clk));
drivers/spi/spi-armada-3700.c:	master->min_speed_hz = DIV_ROUND_UP(clk_get_rate(spi->clk),
drivers/spi/spi-armada-3700.c:	ret = devm_request_irq(dev, spi->irq, a3700_spi_interrupt, 0,
drivers/spi/spi-armada-3700.c:	clk_disable_unprepare(spi->clk);
drivers/spi/spi-armada-3700.c:	clk_unprepare(spi->clk);
drivers/spi/spi-mpc52xx.c:		cs = ms->message->spi->chip_select;
drivers/spi/spi-mpc52xx.c:	if (spi->mode & SPI_CPHA)
drivers/spi/spi-mpc52xx.c:	if (spi->mode & SPI_CPOL)
drivers/spi/spi-mpc52xx.c:	if (spi->mode & SPI_LSB_FIRST)
drivers/spi/spi-mpc52xx.c:	sppr = ((ms->ipb_freq / ms->message->spi->max_speed_hz) + 1) >> 1;
drivers/spi/spi-mpc52xx.c:	struct mpc52xx_spi *ms = spi_master_get_devdata(spi->master);
drivers/spi/spi-mpc52xx.c:				  "mpc5200-spi-modf", ms);
drivers/spi/spi-mpc52xx.c:				  "mpc5200-spi-spif", ms);
drivers/spi/spi-topcliff-pch.c:	dev_dbg(&spi->dev, "%s SPBRR content =%x setting baud rate=%d\n",
drivers/spi/spi-topcliff-pch.c:		__func__, pch_spi_readreg(spi->master, PCH_SPBRR),
drivers/spi/spi-topcliff-pch.c:		spi->max_speed_hz);
drivers/spi/spi-topcliff-pch.c:	pch_spi_set_baud_rate(spi->master, spi->max_speed_hz);
drivers/spi/spi-topcliff-pch.c:	pch_spi_set_bits_per_word(spi->master, spi->bits_per_word);
drivers/spi/spi-topcliff-pch.c:	if (!(spi->mode & SPI_LSB_FIRST))
drivers/spi/spi-topcliff-pch.c:	if (spi->mode & SPI_CPOL)
drivers/spi/spi-topcliff-pch.c:	if (spi->mode & SPI_CPHA)
drivers/spi/spi-topcliff-pch.c:	pch_spi_setclr_reg(spi->master, PCH_SPCR, flags,
drivers/spi/spi-topcliff-pch.c:	pch_spi_clear_fifo(spi->master);
drivers/spi/spi-topcliff-pch.c:	struct pch_spi_data *data = spi_master_get_devdata(pspi->master);
drivers/spi/spi-topcliff-pch.c:			dev_err(&pspi->dev,
drivers/spi/spi-topcliff-pch.c:			dev_err(&pspi->dev, "%s Transfer length invalid\n",
drivers/spi/spi-topcliff-pch.c:		dev_dbg(&pspi->dev,
drivers/spi/spi-topcliff-pch.c:		dev_err(&pspi->dev, "%s status = STATUS_EXITING.\n", __func__);
drivers/spi/spi-topcliff-pch.c:		dev_err(&pspi->dev, "%s suspend; returning EINVAL\n", __func__);
drivers/spi/spi-topcliff-pch.c:	dev_dbg(&pspi->dev, "%s - pmsg->status =%d\n", __func__, pmsg->status);
drivers/spi/spi-topcliff-pch.c:	dev_dbg(&pspi->dev, "%s - Invoked list_add_tail\n", __func__);
drivers/spi/spi-topcliff-pch.c:	dev_dbg(&pspi->dev, "%s - Invoked queue work\n", __func__);
drivers/spi/spi-topcliff-pch.c:	dev_dbg(&pspi->dev, "%s RETURN=%d\n", __func__, retval);
drivers/spi/spi-topcliff-pch.c:	dev_dbg(&pspi->dev, "%s RETURN=%d\n", __func__, retval);
drivers/spi/spi-topcliff-pch.c:		if (pspi->chip_select != data->n_curnt_chip) {
drivers/spi/spi-topcliff-pch.c:			dev_dbg(&pspi->dev, "%s : different slave\n", __func__);
drivers/spi/spi-topcliff-pch.c:	dev_dbg(&pspi->dev, "%s :Invoking pch_spi_setup_transfer\n", __func__);
drivers/spi/spi-topcliff-pch.c:	    (data->current_msg->spi->bits_per_word != data->cur_trans->bits_per_word)) {
drivers/spi/spi-topcliff-pch.c:		*bpw = data->current_msg->spi->bits_per_word;
drivers/spi/spi-topcliff-pch.c:	    (data->current_msg->spi->bits_per_word !=
drivers/spi/spi-topcliff-pch.c:		*bpw = data->current_msg->spi->bits_per_word;
drivers/spi/spi-topcliff-pch.c:				    data->current_msg->spi->bits_per_word);
drivers/spi/spi-fsl-cpm.c:#include "spi-fsl-cpm.h"
drivers/spi/spi-fsl-cpm.c:#include "spi-fsl-lib.h"
drivers/spi/spi-fsl-cpm.c:#include "spi-fsl-spi.h"
drivers/spi/spi-fsl-cpm.c:	if (mspi->flags & SPI_QE) {
drivers/spi/spi-fsl-cpm.c:		qe_issue_cmd(QE_INIT_TX_RX, mspi->subblock,
drivers/spi/spi-fsl-cpm.c:		if (mspi->flags & SPI_CPM1) {
drivers/spi/spi-fsl-cpm.c:			out_be32(&mspi->pram->rstate, 0);
drivers/spi/spi-fsl-cpm.c:			out_be16(&mspi->pram->rbptr,
drivers/spi/spi-fsl-cpm.c:				 in_be16(&mspi->pram->rbase));
drivers/spi/spi-fsl-cpm.c:			out_be32(&mspi->pram->tstate, 0);
drivers/spi/spi-fsl-cpm.c:			out_be16(&mspi->pram->tbptr,
drivers/spi/spi-fsl-cpm.c:				 in_be16(&mspi->pram->tbase));
drivers/spi/spi-fsl-cpm.c:	struct cpm_buf_desc __iomem *tx_bd = mspi->tx_bd;
drivers/spi/spi-fsl-cpm.c:	struct cpm_buf_desc __iomem *rx_bd = mspi->rx_bd;
drivers/spi/spi-fsl-cpm.c:	unsigned int xfer_len = min(mspi->count, SPI_MRBLR);
drivers/spi/spi-fsl-cpm.c:	struct fsl_spi_reg *reg_base = mspi->reg_base;
drivers/spi/spi-fsl-cpm.c:	xfer_ofs = mspi->xfer_in_progress->len - mspi->count;
drivers/spi/spi-fsl-cpm.c:	if (mspi->rx_dma == mspi->dma_dummy_rx)
drivers/spi/spi-fsl-cpm.c:		out_be32(&rx_bd->cbd_bufaddr, mspi->rx_dma);
drivers/spi/spi-fsl-cpm.c:		out_be32(&rx_bd->cbd_bufaddr, mspi->rx_dma + xfer_ofs);
drivers/spi/spi-fsl-cpm.c:	if (mspi->tx_dma == mspi->dma_dummy_tx)
drivers/spi/spi-fsl-cpm.c:		out_be32(&tx_bd->cbd_bufaddr, mspi->tx_dma);
drivers/spi/spi-fsl-cpm.c:		out_be32(&tx_bd->cbd_bufaddr, mspi->tx_dma + xfer_ofs);
drivers/spi/spi-fsl-cpm.c:	struct device *dev = mspi->dev;
drivers/spi/spi-fsl-cpm.c:	struct fsl_spi_reg *reg_base = mspi->reg_base;
drivers/spi/spi-fsl-cpm.c:		mspi->map_tx_dma = 0;
drivers/spi/spi-fsl-cpm.c:		mspi->map_rx_dma = 0;
drivers/spi/spi-fsl-cpm.c:		mspi->map_tx_dma = 1;
drivers/spi/spi-fsl-cpm.c:		mspi->map_rx_dma = 1;
drivers/spi/spi-fsl-cpm.c:		mspi->tx_dma = mspi->dma_dummy_tx;
drivers/spi/spi-fsl-cpm.c:		mspi->map_tx_dma = 0;
drivers/spi/spi-fsl-cpm.c:		mspi->rx_dma = mspi->dma_dummy_rx;
drivers/spi/spi-fsl-cpm.c:		mspi->map_rx_dma = 0;
drivers/spi/spi-fsl-cpm.c:	if (mspi->map_tx_dma) {
drivers/spi/spi-fsl-cpm.c:		void *nonconst_tx = (void *)mspi->tx; /* shut up gcc */
drivers/spi/spi-fsl-cpm.c:		mspi->tx_dma = dma_map_single(dev, nonconst_tx, t->len,
drivers/spi/spi-fsl-cpm.c:		if (dma_mapping_error(dev, mspi->tx_dma)) {
drivers/spi/spi-fsl-cpm.c:		mspi->tx_dma = t->tx_dma;
drivers/spi/spi-fsl-cpm.c:	if (mspi->map_rx_dma) {
drivers/spi/spi-fsl-cpm.c:		mspi->rx_dma = dma_map_single(dev, mspi->rx, t->len,
drivers/spi/spi-fsl-cpm.c:		if (dma_mapping_error(dev, mspi->rx_dma)) {
drivers/spi/spi-fsl-cpm.c:		mspi->rx_dma = t->rx_dma;
drivers/spi/spi-fsl-cpm.c:	mspi->xfer_in_progress = t;
drivers/spi/spi-fsl-cpm.c:	mspi->count = t->len;
drivers/spi/spi-fsl-cpm.c:	if (mspi->map_tx_dma)
drivers/spi/spi-fsl-cpm.c:		dma_unmap_single(dev, mspi->tx_dma, t->len, DMA_TO_DEVICE);
drivers/spi/spi-fsl-cpm.c:	struct device *dev = mspi->dev;
drivers/spi/spi-fsl-cpm.c:	struct spi_transfer *t = mspi->xfer_in_progress;
drivers/spi/spi-fsl-cpm.c:	if (mspi->map_tx_dma)
drivers/spi/spi-fsl-cpm.c:		dma_unmap_single(dev, mspi->tx_dma, t->len, DMA_TO_DEVICE);
drivers/spi/spi-fsl-cpm.c:	if (mspi->map_rx_dma)
drivers/spi/spi-fsl-cpm.c:		dma_unmap_single(dev, mspi->rx_dma, t->len, DMA_FROM_DEVICE);
drivers/spi/spi-fsl-cpm.c:	mspi->xfer_in_progress = NULL;
drivers/spi/spi-fsl-cpm.c:	struct fsl_spi_reg *reg_base = mspi->reg_base;
drivers/spi/spi-fsl-cpm.c:	dev_dbg(mspi->dev, "%s: bd datlen %d, count %d\n", __func__,
drivers/spi/spi-fsl-cpm.c:		in_be16(&mspi->rx_bd->cbd_datlen), mspi->count);
drivers/spi/spi-fsl-cpm.c:	len = in_be16(&mspi->rx_bd->cbd_datlen);
drivers/spi/spi-fsl-cpm.c:	if (len > mspi->count) {
drivers/spi/spi-fsl-cpm.c:		len = mspi->count;
drivers/spi/spi-fsl-cpm.c:	mspi->count -= len;
drivers/spi/spi-fsl-cpm.c:	if (mspi->count)
drivers/spi/spi-fsl-cpm.c:		complete(&mspi->done);
drivers/spi/spi-fsl-cpm.c:	struct device *dev = mspi->dev;
drivers/spi/spi-fsl-cpm.c:	if (mspi->flags & SPI_QE && iprop && size == sizeof(*iprop) * 4)
drivers/spi/spi-fsl-cpm.c:	if (mspi->flags & SPI_QE) {
drivers/spi/spi-fsl-cpm.c:		qe_issue_cmd(QE_ASSIGN_PAGE_TO_DEVICE, mspi->subblock,
drivers/spi/spi-fsl-cpm.c:	if (mspi->flags & SPI_CPM2) {
drivers/spi/spi-fsl-cpm.c:	struct device *dev = mspi->dev;
drivers/spi/spi-fsl-cpm.c:	if (!(mspi->flags & SPI_CPM_MODE))
drivers/spi/spi-fsl-cpm.c:	if (mspi->flags & SPI_QE) {
drivers/spi/spi-fsl-cpm.c:			mspi->subblock = *iprop;
drivers/spi/spi-fsl-cpm.c:		switch (mspi->subblock) {
drivers/spi/spi-fsl-cpm.c:			mspi->subblock = QE_CR_SUBBLOCK_SPI1;
drivers/spi/spi-fsl-cpm.c:			mspi->subblock = QE_CR_SUBBLOCK_SPI2;
drivers/spi/spi-fsl-cpm.c:	if (mspi->flags & SPI_CPM1) {
drivers/spi/spi-fsl-cpm.c:			mspi->pram = NULL;
drivers/spi/spi-fsl-cpm.c:			mspi->pram = pram;
drivers/spi/spi-fsl-cpm.c:			mspi->pram = NULL;
drivers/spi/spi-fsl-cpm.c:			mspi->pram = cpm_muram_addr(pram_ofs);
drivers/spi/spi-fsl-cpm.c:	if (mspi->pram == NULL) {
drivers/spi/spi-fsl-cpm.c:	bds_ofs = cpm_muram_alloc(sizeof(*mspi->tx_bd) +
drivers/spi/spi-fsl-cpm.c:				  sizeof(*mspi->rx_bd), 8);
drivers/spi/spi-fsl-cpm.c:	mspi->dma_dummy_tx = dma_map_single(dev, empty_zero_page, PAGE_SIZE,
drivers/spi/spi-fsl-cpm.c:	if (dma_mapping_error(dev, mspi->dma_dummy_tx)) {
drivers/spi/spi-fsl-cpm.c:	mspi->dma_dummy_rx = dma_map_single(dev, fsl_dummy_rx, SPI_MRBLR,
drivers/spi/spi-fsl-cpm.c:	if (dma_mapping_error(dev, mspi->dma_dummy_rx)) {
drivers/spi/spi-fsl-cpm.c:	mspi->tx_bd = cpm_muram_addr(bds_ofs);
drivers/spi/spi-fsl-cpm.c:	mspi->rx_bd = cpm_muram_addr(bds_ofs + sizeof(*mspi->tx_bd));
drivers/spi/spi-fsl-cpm.c:	out_be16(&mspi->pram->tbase, cpm_muram_offset(mspi->tx_bd));
drivers/spi/spi-fsl-cpm.c:	out_be16(&mspi->pram->rbase, cpm_muram_offset(mspi->rx_bd));
drivers/spi/spi-fsl-cpm.c:	out_8(&mspi->pram->tfcr, CPMFCR_EB | CPMFCR_GBL);
drivers/spi/spi-fsl-cpm.c:	out_8(&mspi->pram->rfcr, CPMFCR_EB | CPMFCR_GBL);
drivers/spi/spi-fsl-cpm.c:	out_be16(&mspi->pram->mrblr, SPI_MRBLR);
drivers/spi/spi-fsl-cpm.c:	out_be32(&mspi->pram->rstate, 0);
drivers/spi/spi-fsl-cpm.c:	out_be32(&mspi->pram->rdp, 0);
drivers/spi/spi-fsl-cpm.c:	out_be16(&mspi->pram->rbptr, 0);
drivers/spi/spi-fsl-cpm.c:	out_be16(&mspi->pram->rbc, 0);
drivers/spi/spi-fsl-cpm.c:	out_be32(&mspi->pram->rxtmp, 0);
drivers/spi/spi-fsl-cpm.c:	out_be32(&mspi->pram->tstate, 0);
drivers/spi/spi-fsl-cpm.c:	out_be32(&mspi->pram->tdp, 0);
drivers/spi/spi-fsl-cpm.c:	out_be16(&mspi->pram->tbptr, 0);
drivers/spi/spi-fsl-cpm.c:	out_be16(&mspi->pram->tbc, 0);
drivers/spi/spi-fsl-cpm.c:	out_be32(&mspi->pram->txtmp, 0);
drivers/spi/spi-fsl-cpm.c:	dma_unmap_single(dev, mspi->dma_dummy_tx, PAGE_SIZE, DMA_TO_DEVICE);
drivers/spi/spi-fsl-cpm.c:	if (!(mspi->flags & SPI_CPM1))
drivers/spi/spi-fsl-cpm.c:		cpm_muram_free(cpm_muram_offset(mspi->pram));
drivers/spi/spi-fsl-cpm.c:	struct device *dev = mspi->dev;
drivers/spi/spi-fsl-cpm.c:	if (!(mspi->flags & SPI_CPM_MODE))
drivers/spi/spi-fsl-cpm.c:	dma_unmap_single(dev, mspi->dma_dummy_rx, SPI_MRBLR, DMA_FROM_DEVICE);
drivers/spi/spi-fsl-cpm.c:	dma_unmap_single(dev, mspi->dma_dummy_tx, PAGE_SIZE, DMA_TO_DEVICE);
drivers/spi/spi-fsl-cpm.c:	cpm_muram_free(cpm_muram_offset(mspi->tx_bd));
drivers/spi/spi-fsl-cpm.c:	cpm_muram_free(cpm_muram_offset(mspi->pram));
drivers/spi/spidev.c:		dev_dbg(&spidev->spi->dev,
drivers/spi/spidev.c:			u_tmp->bits_per_word ? : spidev->spi->bits_per_word,
drivers/spi/spidev.c:			u_tmp->speed_hz ? : spidev->spi->max_speed_hz);
drivers/spi/spidev.c:		retval = put_user(spi->mode & SPI_MODE_MASK,
drivers/spi/spidev.c:		retval = put_user(spi->mode & SPI_MODE_MASK,
drivers/spi/spidev.c:		retval = put_user((spi->mode & SPI_LSB_FIRST) ?  1 : 0,
drivers/spi/spidev.c:		retval = put_user(spi->bits_per_word, (__u8 __user *)arg);
drivers/spi/spidev.c:			u32	save = spi->mode;
drivers/spi/spidev.c:			tmp |= spi->mode & ~SPI_MODE_MASK;
drivers/spi/spidev.c:			spi->mode = (u16)tmp;
drivers/spi/spidev.c:				spi->mode = save;
drivers/spi/spidev.c:				dev_dbg(&spi->dev, "spi mode %x\n", tmp);
drivers/spi/spidev.c:			u32	save = spi->mode;
drivers/spi/spidev.c:				spi->mode |= SPI_LSB_FIRST;
drivers/spi/spidev.c:				spi->mode &= ~SPI_LSB_FIRST;
drivers/spi/spidev.c:				spi->mode = save;
drivers/spi/spidev.c:				dev_dbg(&spi->dev, "%csb first\n",
drivers/spi/spidev.c:			u8	save = spi->bits_per_word;
drivers/spi/spidev.c:			spi->bits_per_word = tmp;
drivers/spi/spidev.c:				spi->bits_per_word = save;
drivers/spi/spidev.c:				dev_dbg(&spi->dev, "%d bits per word\n", tmp);
drivers/spi/spidev.c:			u32	save = spi->max_speed_hz;
drivers/spi/spidev.c:			spi->max_speed_hz = tmp;
drivers/spi/spidev.c:				dev_dbg(&spi->dev, "%d Hz (max)\n", tmp);
drivers/spi/spidev.c:			spi->max_speed_hz = save;
drivers/spi/spidev.c:			dev_dbg(&spidev->spi->dev, "open/ENOMEM\n");
drivers/spi/spidev.c:			dev_dbg(&spidev->spi->dev, "open/ENOMEM\n");
drivers/spi/spidev.c:			spidev->speed_hz = spidev->spi->max_speed_hz;
drivers/spi/spidev.c:	if (!has_acpi_companion(&spi->dev))
drivers/spi/spidev.c:	id = acpi_match_device(spidev_acpi_ids, &spi->dev);
drivers/spi/spidev.c:		dev_warn(&spi->dev, "do not use this driver in production systems!\n");
drivers/spi/spidev.c:	if (spi->dev.of_node && !of_match_device(spidev_dt_ids, &spi->dev)) {
drivers/spi/spidev.c:		dev_err(&spi->dev, "buggy DT: spidev listed directly in DT\n");
drivers/spi/spidev.c:		WARN_ON(spi->dev.of_node &&
drivers/spi/spidev.c:			!of_match_device(spidev_dt_ids, &spi->dev));
drivers/spi/spidev.c:		dev = device_create(spidev_class, &spi->dev, spidev->devt,
drivers/spi/spidev.c:				    spi->master->bus_num, spi->chip_select);
drivers/spi/spidev.c:		dev_dbg(&spi->dev, "no minor number available!\n");
drivers/spi/spidev.c:	spidev->speed_hz = spi->max_speed_hz;
drivers/spi/spi-coldfire-qspi.c:	writew(val, mcfqspi->iobase + MCFQSPI_QMR);
drivers/spi/spi-coldfire-qspi.c:	writew(val, mcfqspi->iobase + MCFQSPI_QDLYR);
drivers/spi/spi-coldfire-qspi.c:	return readw(mcfqspi->iobase + MCFQSPI_QDLYR);
drivers/spi/spi-coldfire-qspi.c:	writew(val, mcfqspi->iobase + MCFQSPI_QWR);
drivers/spi/spi-coldfire-qspi.c:	writew(val, mcfqspi->iobase + MCFQSPI_QIR);
drivers/spi/spi-coldfire-qspi.c:	writew(val, mcfqspi->iobase + MCFQSPI_QAR);
drivers/spi/spi-coldfire-qspi.c:	writew(val, mcfqspi->iobase + MCFQSPI_QDR);
drivers/spi/spi-coldfire-qspi.c:	return readw(mcfqspi->iobase + MCFQSPI_QDR);
drivers/spi/spi-coldfire-qspi.c:	mcfqspi->cs_control->select(mcfqspi->cs_control, chip_select, cs_high);
drivers/spi/spi-coldfire-qspi.c:	mcfqspi->cs_control->deselect(mcfqspi->cs_control, chip_select, cs_high);
drivers/spi/spi-coldfire-qspi.c:	return (mcfqspi->cs_control->setup) ?
drivers/spi/spi-coldfire-qspi.c:		mcfqspi->cs_control->setup(mcfqspi->cs_control) : 0;
drivers/spi/spi-coldfire-qspi.c:	if (mcfqspi->cs_control->teardown)
drivers/spi/spi-coldfire-qspi.c:		mcfqspi->cs_control->teardown(mcfqspi->cs_control);
drivers/spi/spi-coldfire-qspi.c:	wake_up(&mcfqspi->waitq);
drivers/spi/spi-coldfire-qspi.c:			wait_event(mcfqspi->waitq, !mcfqspi_qdlyr_spe(mcfqspi));
drivers/spi/spi-coldfire-qspi.c:		wait_event(mcfqspi->waitq, !mcfqspi_qdlyr_spe(mcfqspi));
drivers/spi/spi-coldfire-qspi.c:	wait_event(mcfqspi->waitq, !mcfqspi_qdlyr_spe(mcfqspi));
drivers/spi/spi-coldfire-qspi.c:			wait_event(mcfqspi->waitq, !mcfqspi_qdlyr_spe(mcfqspi));
drivers/spi/spi-coldfire-qspi.c:		wait_event(mcfqspi->waitq, !mcfqspi_qdlyr_spe(mcfqspi));
drivers/spi/spi-coldfire-qspi.c:	wait_event(mcfqspi->waitq, !mcfqspi_qdlyr_spe(mcfqspi));
drivers/spi/spi-coldfire-qspi.c:	struct mcfqspi *mcfqspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-coldfire-qspi.c:	bool cs_high = spi->mode & SPI_CS_HIGH;
drivers/spi/spi-coldfire-qspi.c:		mcfqspi_cs_select(mcfqspi, spi->chip_select, cs_high);
drivers/spi/spi-coldfire-qspi.c:		mcfqspi_cs_deselect(mcfqspi, spi->chip_select, cs_high);
drivers/spi/spi-coldfire-qspi.c:	if (spi->mode & SPI_CPHA)
drivers/spi/spi-coldfire-qspi.c:	if (spi->mode & SPI_CPOL)
drivers/spi/spi-coldfire-qspi.c:	mcfqspi_cs_deselect(spi_master_get_devdata(spi->master),
drivers/spi/spi-coldfire-qspi.c:			    spi->chip_select, spi->mode & SPI_CS_HIGH);
drivers/spi/spi-coldfire-qspi.c:	dev_dbg(&spi->dev,
drivers/spi/spi-coldfire-qspi.c:			spi->bits_per_word, spi->chip_select,
drivers/spi/spi-coldfire-qspi.c:			(MCFQSPI_BUSCLK / mcfqspi_qmr_baud(spi->max_speed_hz))
drivers/spi/spi-coldfire-qspi.c:	mcfqspi->iobase = devm_ioremap_resource(&pdev->dev, res);
drivers/spi/spi-coldfire-qspi.c:	if (IS_ERR(mcfqspi->iobase)) {
drivers/spi/spi-coldfire-qspi.c:		status = PTR_ERR(mcfqspi->iobase);
drivers/spi/spi-coldfire-qspi.c:	mcfqspi->irq = platform_get_irq(pdev, 0);
drivers/spi/spi-coldfire-qspi.c:	if (mcfqspi->irq < 0) {
drivers/spi/spi-coldfire-qspi.c:	status = devm_request_irq(&pdev->dev, mcfqspi->irq, mcfqspi_irq_handler,
drivers/spi/spi-coldfire-qspi.c:	mcfqspi->clk = devm_clk_get(&pdev->dev, "qspi_clk");
drivers/spi/spi-coldfire-qspi.c:	if (IS_ERR(mcfqspi->clk)) {
drivers/spi/spi-coldfire-qspi.c:		status = PTR_ERR(mcfqspi->clk);
drivers/spi/spi-coldfire-qspi.c:	clk_enable(mcfqspi->clk);
drivers/spi/spi-coldfire-qspi.c:	mcfqspi->cs_control = pdata->cs_control;
drivers/spi/spi-coldfire-qspi.c:	init_waitqueue_head(&mcfqspi->waitq);
drivers/spi/spi-coldfire-qspi.c:	clk_disable(mcfqspi->clk);
drivers/spi/spi-coldfire-qspi.c:	clk_disable(mcfqspi->clk);
drivers/spi/spi-coldfire-qspi.c:	clk_disable(mcfqspi->clk);
drivers/spi/spi-coldfire-qspi.c:	clk_enable(mcfqspi->clk);
drivers/spi/spi-coldfire-qspi.c:	clk_disable(mcfqspi->clk);
drivers/spi/spi-coldfire-qspi.c:	clk_enable(mcfqspi->clk);
drivers/spi/built-in.o:spi-sun6i.o/
drivers/spi/spi-mpc52xx-psc.c:	struct mpc52xx_psc_spi_cs *cs = spi->controller_state;
drivers/spi/spi-mpc52xx-psc.c:			? t->speed_hz : spi->max_speed_hz;
drivers/spi/spi-mpc52xx-psc.c:			? t->bits_per_word : spi->bits_per_word;
drivers/spi/spi-mpc52xx-psc.c:	struct mpc52xx_psc_spi_cs *cs = spi->controller_state;
drivers/spi/spi-mpc52xx-psc.c:	struct mpc52xx_psc_spi *mps = spi_master_get_devdata(spi->master);
drivers/spi/spi-mpc52xx-psc.c:	if (spi->mode & SPI_CPHA)
drivers/spi/spi-mpc52xx-psc.c:	if (spi->mode & SPI_CPOL)
drivers/spi/spi-mpc52xx-psc.c:	if (spi->mode & SPI_LSB_FIRST)
drivers/spi/spi-mpc52xx-psc.c:		mps->cs_control(spi, (spi->mode & SPI_CS_HIGH) ? 1 : 0);
drivers/spi/spi-mpc52xx-psc.c:	struct mpc52xx_psc_spi *mps = spi_master_get_devdata(spi->master);
drivers/spi/spi-mpc52xx-psc.c:		mps->cs_control(spi, (spi->mode & SPI_CS_HIGH) ? 0 : 1);
drivers/spi/spi-mpc52xx-psc.c:	struct mpc52xx_psc_spi *mps = spi_master_get_devdata(spi->master);
drivers/spi/spi-mpc52xx-psc.c:		dev_dbg(&spi->dev, "send %d bytes...\n", send_at_once);
drivers/spi/spi-mpc52xx-psc.c:		dev_dbg(&spi->dev, "%d bytes received\n", recv_at_once);
drivers/spi/spi-mpc52xx-psc.c:	struct mpc52xx_psc_spi *mps = spi_master_get_devdata(spi->master);
drivers/spi/spi-mpc52xx-psc.c:	struct mpc52xx_psc_spi_cs *cs = spi->controller_state;
drivers/spi/spi-mpc52xx-psc.c:	if (spi->bits_per_word%8)
drivers/spi/spi-mpc52xx-psc.c:		spi->controller_state = cs;
drivers/spi/spi-mpc52xx-psc.c:	cs->bits_per_word = spi->bits_per_word;
drivers/spi/spi-mpc52xx-psc.c:	cs->speed_hz = spi->max_speed_hz;
drivers/spi/spi-mpc52xx-psc.c:	struct mpc52xx_psc_spi *mps = spi_master_get_devdata(spi->master);
drivers/spi/spi-mpc52xx-psc.c:	kfree(spi->controller_state);
drivers/spi/spi-mpc52xx-psc.c:	/* the spi->mode bits understood by this driver: */
drivers/spi/spi-fsl-lib.c:#include "spi-fsl-lib.h"
drivers/spi/spi-fsl-lib.c:	type *rx = mpc8xxx_spi->rx;					  \
drivers/spi/spi-fsl-lib.c:	*rx++ = (type)(data >> mpc8xxx_spi->rx_shift);			  \
drivers/spi/spi-fsl-lib.c:	mpc8xxx_spi->rx = rx;						  \
drivers/spi/spi-fsl-lib.c:	const type *tx = mpc8xxx_spi->tx;			\
drivers/spi/spi-fsl-lib.c:	data = *tx++ << mpc8xxx_spi->tx_shift;			\
drivers/spi/spi-fsl-lib.c:	mpc8xxx_spi->tx = tx;					\
drivers/spi/spi-fsl-lib.c:	/* the spi->mode bits understood by this driver: */
drivers/spi/spi-fsl-lib.c:	mpc8xxx_spi->dev = dev;
drivers/spi/spi-fsl-lib.c:	mpc8xxx_spi->get_rx = mpc8xxx_spi_rx_buf_u8;
drivers/spi/spi-fsl-lib.c:	mpc8xxx_spi->get_tx = mpc8xxx_spi_tx_buf_u8;
drivers/spi/spi-fsl-lib.c:	mpc8xxx_spi->flags = pdata->flags;
drivers/spi/spi-fsl-lib.c:	mpc8xxx_spi->spibrg = pdata->sysclk;
drivers/spi/spi-fsl-lib.c:	mpc8xxx_spi->irq = irq;
drivers/spi/spi-fsl-lib.c:	mpc8xxx_spi->rx_shift = 0;
drivers/spi/spi-fsl-lib.c:	mpc8xxx_spi->tx_shift = 0;
drivers/spi/spi-fsl-lib.c:	init_completion(&mpc8xxx_spi->done);
drivers/spi/spi-sh-hspi.c: * Based on spi-sh.c:
drivers/spi/spi-sh-hspi.c:	iowrite32(val, hspi->addr + reg);
drivers/spi/spi-sh-hspi.c:	return ioread32(hspi->addr + reg);
drivers/spi/spi-sh-hspi.c:	dev_err(hspi->dev, "timeout\n");
drivers/spi/spi-sh-hspi.c:	struct device *dev = hspi->dev;
drivers/spi/spi-sh-hspi.c:		rate = clk_get_rate(hspi->clk);
drivers/spi/spi-sh-hspi.c:	if (spi->mode & SPI_CPHA)
drivers/spi/spi-sh-hspi.c:	if (spi->mode & SPI_CPOL)
drivers/spi/spi-sh-hspi.c:	dev_dbg(hspi->dev, "%s\n", __func__);
drivers/spi/spi-sh-hspi.c:	hspi->master	= master;
drivers/spi/spi-sh-hspi.c:	hspi->dev	= &pdev->dev;
drivers/spi/spi-sh-hspi.c:	hspi->clk	= clk;
drivers/spi/spi-sh-hspi.c:	hspi->addr	= devm_ioremap(hspi->dev,
drivers/spi/spi-sh-hspi.c:	if (!hspi->addr) {
drivers/spi/spi-sh-hspi.c:	clk_put(hspi->clk);
drivers/spi/spi-tegra114.c:	return readl(tspi->base + reg);
drivers/spi/spi-tegra114.c:	writel(val, tspi->base + reg);
drivers/spi/spi-tegra114.c:		readl(tspi->base + SPI_COMMAND1);
drivers/spi/spi-tegra114.c:	unsigned remain_len = t->len - tspi->cur_pos;
drivers/spi/spi-tegra114.c:	tspi->bytes_per_word = DIV_ROUND_UP(bits_per_word, 8);
drivers/spi/spi-tegra114.c:		tspi->is_packed = 1;
drivers/spi/spi-tegra114.c:		tspi->words_per_32bit = 32/bits_per_word;
drivers/spi/spi-tegra114.c:		tspi->is_packed = 0;
drivers/spi/spi-tegra114.c:		tspi->words_per_32bit = 1;
drivers/spi/spi-tegra114.c:	if (tspi->is_packed) {
drivers/spi/spi-tegra114.c:		max_len = min(remain_len, tspi->max_buf_size);
drivers/spi/spi-tegra114.c:		tspi->curr_dma_words = max_len/tspi->bytes_per_word;
drivers/spi/spi-tegra114.c:		max_word = (remain_len - 1) / tspi->bytes_per_word + 1;
drivers/spi/spi-tegra114.c:		max_word = min(max_word, tspi->max_buf_size/4);
drivers/spi/spi-tegra114.c:		tspi->curr_dma_words = max_word;
drivers/spi/spi-tegra114.c:	u8 *tx_buf = (u8 *)t->tx_buf + tspi->cur_tx_pos;
drivers/spi/spi-tegra114.c:	if (tspi->is_packed) {
drivers/spi/spi-tegra114.c:		fifo_words_left = tx_empty_count * tspi->words_per_32bit;
drivers/spi/spi-tegra114.c:		written_words = min(fifo_words_left, tspi->curr_dma_words);
drivers/spi/spi-tegra114.c:		nbytes = written_words * tspi->bytes_per_word;
drivers/spi/spi-tegra114.c:		max_n_32bit = min(tspi->curr_dma_words,  tx_empty_count);
drivers/spi/spi-tegra114.c:		nbytes = written_words * tspi->bytes_per_word;
drivers/spi/spi-tegra114.c:			for (i = 0; nbytes && (i < tspi->bytes_per_word);
drivers/spi/spi-tegra114.c:	tspi->cur_tx_pos += written_words * tspi->bytes_per_word;
drivers/spi/spi-tegra114.c:	u8 *rx_buf = (u8 *)t->rx_buf + tspi->cur_rx_pos;
drivers/spi/spi-tegra114.c:	if (tspi->is_packed) {
drivers/spi/spi-tegra114.c:		len = tspi->curr_dma_words * tspi->bytes_per_word;
drivers/spi/spi-tegra114.c:		tspi->cur_rx_pos += tspi->curr_dma_words * tspi->bytes_per_word;
drivers/spi/spi-tegra114.c:		read_words += tspi->curr_dma_words;
drivers/spi/spi-tegra114.c:			for (i = 0; (i < tspi->bytes_per_word); i++)
drivers/spi/spi-tegra114.c:		tspi->cur_rx_pos += rx_full_count * tspi->bytes_per_word;
drivers/spi/spi-tegra114.c:	dma_sync_single_for_cpu(tspi->dev, tspi->tx_dma_phys,
drivers/spi/spi-tegra114.c:				tspi->dma_buf_size, DMA_TO_DEVICE);
drivers/spi/spi-tegra114.c:	if (tspi->is_packed) {
drivers/spi/spi-tegra114.c:		unsigned len = tspi->curr_dma_words * tspi->bytes_per_word;
drivers/spi/spi-tegra114.c:		memcpy(tspi->tx_dma_buf, t->tx_buf + tspi->cur_pos, len);
drivers/spi/spi-tegra114.c:		u8 *tx_buf = (u8 *)t->tx_buf + tspi->cur_tx_pos;
drivers/spi/spi-tegra114.c:		unsigned consume = tspi->curr_dma_words * tspi->bytes_per_word;
drivers/spi/spi-tegra114.c:		for (count = 0; count < tspi->curr_dma_words; count++) {
drivers/spi/spi-tegra114.c:			for (i = 0; consume && (i < tspi->bytes_per_word);
drivers/spi/spi-tegra114.c:			tspi->tx_dma_buf[count] = x;
drivers/spi/spi-tegra114.c:	tspi->cur_tx_pos += tspi->curr_dma_words * tspi->bytes_per_word;
drivers/spi/spi-tegra114.c:	dma_sync_single_for_device(tspi->dev, tspi->tx_dma_phys,
drivers/spi/spi-tegra114.c:				tspi->dma_buf_size, DMA_TO_DEVICE);
drivers/spi/spi-tegra114.c:	dma_sync_single_for_cpu(tspi->dev, tspi->rx_dma_phys,
drivers/spi/spi-tegra114.c:		tspi->dma_buf_size, DMA_FROM_DEVICE);
drivers/spi/spi-tegra114.c:	if (tspi->is_packed) {
drivers/spi/spi-tegra114.c:		unsigned len = tspi->curr_dma_words * tspi->bytes_per_word;
drivers/spi/spi-tegra114.c:		memcpy(t->rx_buf + tspi->cur_rx_pos, tspi->rx_dma_buf, len);
drivers/spi/spi-tegra114.c:		unsigned char *rx_buf = t->rx_buf + tspi->cur_rx_pos;
drivers/spi/spi-tegra114.c:		for (count = 0; count < tspi->curr_dma_words; count++) {
drivers/spi/spi-tegra114.c:			u32 x = tspi->rx_dma_buf[count] & rx_mask;
drivers/spi/spi-tegra114.c:			for (i = 0; (i < tspi->bytes_per_word); i++)
drivers/spi/spi-tegra114.c:	tspi->cur_rx_pos += tspi->curr_dma_words * tspi->bytes_per_word;
drivers/spi/spi-tegra114.c:	dma_sync_single_for_device(tspi->dev, tspi->rx_dma_phys,
drivers/spi/spi-tegra114.c:		tspi->dma_buf_size, DMA_FROM_DEVICE);
drivers/spi/spi-tegra114.c:	reinit_completion(&tspi->tx_dma_complete);
drivers/spi/spi-tegra114.c:	tspi->tx_dma_desc = dmaengine_prep_slave_single(tspi->tx_dma_chan,
drivers/spi/spi-tegra114.c:				tspi->tx_dma_phys, len, DMA_MEM_TO_DEV,
drivers/spi/spi-tegra114.c:	if (!tspi->tx_dma_desc) {
drivers/spi/spi-tegra114.c:		dev_err(tspi->dev, "Not able to get desc for Tx\n");
drivers/spi/spi-tegra114.c:	tspi->tx_dma_desc->callback = tegra_spi_dma_complete;
drivers/spi/spi-tegra114.c:	tspi->tx_dma_desc->callback_param = &tspi->tx_dma_complete;
drivers/spi/spi-tegra114.c:	dmaengine_submit(tspi->tx_dma_desc);
drivers/spi/spi-tegra114.c:	dma_async_issue_pending(tspi->tx_dma_chan);
drivers/spi/spi-tegra114.c:	reinit_completion(&tspi->rx_dma_complete);
drivers/spi/spi-tegra114.c:	tspi->rx_dma_desc = dmaengine_prep_slave_single(tspi->rx_dma_chan,
drivers/spi/spi-tegra114.c:				tspi->rx_dma_phys, len, DMA_DEV_TO_MEM,
drivers/spi/spi-tegra114.c:	if (!tspi->rx_dma_desc) {
drivers/spi/spi-tegra114.c:		dev_err(tspi->dev, "Not able to get desc for Rx\n");
drivers/spi/spi-tegra114.c:	tspi->rx_dma_desc->callback = tegra_spi_dma_complete;
drivers/spi/spi-tegra114.c:	tspi->rx_dma_desc->callback_param = &tspi->rx_dma_complete;
drivers/spi/spi-tegra114.c:	dmaengine_submit(tspi->rx_dma_desc);
drivers/spi/spi-tegra114.c:	dma_async_issue_pending(tspi->rx_dma_chan);
drivers/spi/spi-tegra114.c:		dev_err(tspi->dev, "Rx/Tx fifo are not empty status 0x%08x\n",
drivers/spi/spi-tegra114.c:	val = SPI_DMA_BLK_SET(tspi->curr_dma_words - 1);
drivers/spi/spi-tegra114.c:	if (tspi->is_packed)
drivers/spi/spi-tegra114.c:		len = DIV_ROUND_UP(tspi->curr_dma_words * tspi->bytes_per_word,
drivers/spi/spi-tegra114.c:		len = tspi->curr_dma_words * 4;
drivers/spi/spi-tegra114.c:	if (tspi->cur_direction & DATA_DIR_TX)
drivers/spi/spi-tegra114.c:	if (tspi->cur_direction & DATA_DIR_RX)
drivers/spi/spi-tegra114.c:	tspi->dma_control_reg = val;
drivers/spi/spi-tegra114.c:	if (tspi->cur_direction & DATA_DIR_TX) {
drivers/spi/spi-tegra114.c:			dev_err(tspi->dev,
drivers/spi/spi-tegra114.c:	if (tspi->cur_direction & DATA_DIR_RX) {
drivers/spi/spi-tegra114.c:		dma_sync_single_for_device(tspi->dev, tspi->rx_dma_phys,
drivers/spi/spi-tegra114.c:				tspi->dma_buf_size, DMA_FROM_DEVICE);
drivers/spi/spi-tegra114.c:			dev_err(tspi->dev,
drivers/spi/spi-tegra114.c:			if (tspi->cur_direction & DATA_DIR_TX)
drivers/spi/spi-tegra114.c:				dmaengine_terminate_all(tspi->tx_dma_chan);
drivers/spi/spi-tegra114.c:	tspi->is_curr_dma_xfer = true;
drivers/spi/spi-tegra114.c:	tspi->dma_control_reg = val;
drivers/spi/spi-tegra114.c:	if (tspi->cur_direction & DATA_DIR_TX)
drivers/spi/spi-tegra114.c:		cur_words = tspi->curr_dma_words;
drivers/spi/spi-tegra114.c:	if (tspi->cur_direction & DATA_DIR_TX)
drivers/spi/spi-tegra114.c:	if (tspi->cur_direction & DATA_DIR_RX)
drivers/spi/spi-tegra114.c:	tspi->dma_control_reg = val;
drivers/spi/spi-tegra114.c:	tspi->is_curr_dma_xfer = false;
drivers/spi/spi-tegra114.c:	dma_chan = dma_request_slave_channel_reason(tspi->dev,
drivers/spi/spi-tegra114.c:			dev_err(tspi->dev,
drivers/spi/spi-tegra114.c:	dma_buf = dma_alloc_coherent(tspi->dev, tspi->dma_buf_size,
drivers/spi/spi-tegra114.c:		dev_err(tspi->dev, " Not able to allocate the dma buffer\n");
drivers/spi/spi-tegra114.c:		dma_sconfig.src_addr = tspi->phys + SPI_RX_FIFO;
drivers/spi/spi-tegra114.c:		dma_sconfig.dst_addr = tspi->phys + SPI_TX_FIFO;
drivers/spi/spi-tegra114.c:		tspi->rx_dma_chan = dma_chan;
drivers/spi/spi-tegra114.c:		tspi->rx_dma_buf = dma_buf;
drivers/spi/spi-tegra114.c:		tspi->rx_dma_phys = dma_phys;
drivers/spi/spi-tegra114.c:		tspi->tx_dma_chan = dma_chan;
drivers/spi/spi-tegra114.c:		tspi->tx_dma_buf = dma_buf;
drivers/spi/spi-tegra114.c:		tspi->tx_dma_phys = dma_phys;
drivers/spi/spi-tegra114.c:	dma_free_coherent(tspi->dev, tspi->dma_buf_size, dma_buf, dma_phys);
drivers/spi/spi-tegra114.c:		dma_buf = tspi->rx_dma_buf;
drivers/spi/spi-tegra114.c:		dma_chan = tspi->rx_dma_chan;
drivers/spi/spi-tegra114.c:		dma_phys = tspi->rx_dma_phys;
drivers/spi/spi-tegra114.c:		tspi->rx_dma_chan = NULL;
drivers/spi/spi-tegra114.c:		tspi->rx_dma_buf = NULL;
drivers/spi/spi-tegra114.c:		dma_buf = tspi->tx_dma_buf;
drivers/spi/spi-tegra114.c:		dma_chan = tspi->tx_dma_chan;
drivers/spi/spi-tegra114.c:		dma_phys = tspi->tx_dma_phys;
drivers/spi/spi-tegra114.c:		tspi->tx_dma_buf = NULL;
drivers/spi/spi-tegra114.c:		tspi->tx_dma_chan = NULL;
drivers/spi/spi-tegra114.c:	dma_free_coherent(tspi->dev, tspi->dma_buf_size, dma_buf, dma_phys);
drivers/spi/spi-tegra114.c:	struct tegra_spi_data *tspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-tegra114.c:	if (speed != tspi->cur_speed) {
drivers/spi/spi-tegra114.c:		clk_set_rate(tspi->clk, speed);
drivers/spi/spi-tegra114.c:		tspi->cur_speed = speed;
drivers/spi/spi-tegra114.c:	tspi->cur_spi = spi;
drivers/spi/spi-tegra114.c:	tspi->cur_pos = 0;
drivers/spi/spi-tegra114.c:	tspi->cur_rx_pos = 0;
drivers/spi/spi-tegra114.c:	tspi->cur_tx_pos = 0;
drivers/spi/spi-tegra114.c:	tspi->curr_xfer = t;
drivers/spi/spi-tegra114.c:		command1 = tspi->def_command1_reg;
drivers/spi/spi-tegra114.c:		req_mode = spi->mode & 0x3;
drivers/spi/spi-tegra114.c:		if (tspi->cs_control) {
drivers/spi/spi-tegra114.c:			if (tspi->cs_control != spi)
drivers/spi/spi-tegra114.c:			tspi->cs_control = NULL;
drivers/spi/spi-tegra114.c:		if (spi->mode & SPI_CS_HIGH)
drivers/spi/spi-tegra114.c:		command1 = tspi->command1_reg;
drivers/spi/spi-tegra114.c:	struct tegra_spi_data *tspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-tegra114.c:	if (tspi->is_packed)
drivers/spi/spi-tegra114.c:	tspi->cur_direction = 0;
drivers/spi/spi-tegra114.c:		tspi->cur_direction |= DATA_DIR_RX;
drivers/spi/spi-tegra114.c:		tspi->cur_direction |= DATA_DIR_TX;
drivers/spi/spi-tegra114.c:	command1 |= SPI_CS_SEL(spi->chip_select);
drivers/spi/spi-tegra114.c:	tspi->command1_reg = command1;
drivers/spi/spi-tegra114.c:	dev_dbg(tspi->dev, "The def 0x%x and written 0x%x\n",
drivers/spi/spi-tegra114.c:		tspi->def_command1_reg, (unsigned)command1);
drivers/spi/spi-tegra114.c:	struct tegra_spi_data *tspi = spi_master_get_devdata(spi->master);
drivers/spi/spi-tegra114.c:	dev_dbg(&spi->dev, "setup %d bpw, %scpol, %scpha, %dHz\n",
drivers/spi/spi-tegra114.c:		spi->bits_per_word,
drivers/spi/spi-tegra114.c:		spi->mode & SPI_CPOL ? "" : "~",
drivers/spi/spi-tegra114.c:		spi->mode & SPI_CPHA ? "" : "~",
drivers/spi/spi-tegra114.c:		spi->max_speed_hz);
drivers/spi/spi-tegra114.c:	ret = pm_runtime_get_sync(tspi->dev);
drivers/spi/spi-tegra114.c:		dev_err(tspi->dev, "pm runtime failed, e = %d\n", ret);
drivers/spi/spi-tegra114.c:	spin_lock_irqsave(&tspi->lock, flags);
drivers/spi/spi-tegra114.c:	val = tspi->def_command1_reg;
drivers/spi/spi-tegra114.c:	if (spi->mode & SPI_CS_HIGH)
drivers/spi/spi-tegra114.c:		val &= ~SPI_CS_POL_INACTIVE(spi->chip_select);
drivers/spi/spi-tegra114.c:		val |= SPI_CS_POL_INACTIVE(spi->chip_select);
drivers/spi/spi-tegra114.c:	tspi->def_command1_reg = val;
drivers/spi/spi-tegra114.c:	tegra_spi_writel(tspi, tspi->def_command1_reg, SPI_COMMAND1);
drivers/spi/spi-tegra114.c:	spin_unlock_irqrestore(&tspi->lock, flags);
drivers/spi/spi-tegra114.c:	pm_runtime_put(tspi->dev);
drivers/spi/spi-tegra114.c:		reinit_completion(&tspi->xfer_completion);
drivers/spi/spi-tegra114.c:			dev_err(tspi->dev,
drivers/spi/spi-tegra114.c:		ret = wait_for_completion_timeout(&tspi->xfer_completion,
drivers/spi/spi-tegra114.c:			dev_err(tspi->dev,
drivers/spi/spi-tegra114.c:		if (tspi->tx_status ||  tspi->rx_status) {
drivers/spi/spi-tegra114.c:			dev_err(tspi->dev, "Error in Transfer\n");
drivers/spi/spi-tegra114.c:			tegra_spi_writel(tspi, tspi->def_command1_reg,
drivers/spi/spi-tegra114.c:				tspi->cs_control = spi;
drivers/spi/spi-tegra114.c:				tegra_spi_writel(tspi, tspi->def_command1_reg,
drivers/spi/spi-tegra114.c:			tegra_spi_writel(tspi, tspi->def_command1_reg,
drivers/spi/spi-tegra114.c:	struct spi_transfer *t = tspi->curr_xfer;
drivers/spi/spi-tegra114.c:	spin_lock_irqsave(&tspi->lock, flags);
drivers/spi/spi-tegra114.c:	if (tspi->tx_status ||  tspi->rx_status) {
drivers/spi/spi-tegra114.c:		dev_err(tspi->dev, "CpuXfer ERROR bit set 0x%x\n",
drivers/spi/spi-tegra114.c:			tspi->status_reg);
drivers/spi/spi-tegra114.c:		dev_err(tspi->dev, "CpuXfer 0x%08x:0x%08x\n",
drivers/spi/spi-tegra114.c:			tspi->command1_reg, tspi->dma_control_reg);
drivers/spi/spi-tegra114.c:		reset_control_assert(tspi->rst);
drivers/spi/spi-tegra114.c:		reset_control_deassert(tspi->rst);
drivers/spi/spi-tegra114.c:		complete(&tspi->xfer_completion);
drivers/spi/spi-tegra114.c:	if (tspi->cur_direction & DATA_DIR_RX)
drivers/spi/spi-tegra114.c:	if (tspi->cur_direction & DATA_DIR_TX)
drivers/spi/spi-tegra114.c:		tspi->cur_pos = tspi->cur_tx_pos;
drivers/spi/spi-tegra114.c:		tspi->cur_pos = tspi->cur_rx_pos;
drivers/spi/spi-tegra114.c:	if (tspi->cur_pos == t->len) {
drivers/spi/spi-tegra114.c:		complete(&tspi->xfer_completion);
drivers/spi/spi-tegra114.c:	tegra_spi_calculate_curr_xfer_param(tspi->cur_spi, tspi, t);
drivers/spi/spi-tegra114.c:	spin_unlock_irqrestore(&tspi->lock, flags);
drivers/spi/spi-tegra114.c:	struct spi_transfer *t = tspi->curr_xfer;
drivers/spi/spi-tegra114.c:	if (tspi->cur_direction & DATA_DIR_TX) {
drivers/spi/spi-tegra114.c:		if (tspi->tx_status) {
drivers/spi/spi-tegra114.c:			dmaengine_terminate_all(tspi->tx_dma_chan);
drivers/spi/spi-tegra114.c:				&tspi->tx_dma_complete, SPI_DMA_TIMEOUT);
drivers/spi/spi-tegra114.c:				dmaengine_terminate_all(tspi->tx_dma_chan);
drivers/spi/spi-tegra114.c:				dev_err(tspi->dev, "TxDma Xfer failed\n");
drivers/spi/spi-tegra114.c:	if (tspi->cur_direction & DATA_DIR_RX) {
drivers/spi/spi-tegra114.c:		if (tspi->rx_status) {
drivers/spi/spi-tegra114.c:			dmaengine_terminate_all(tspi->rx_dma_chan);
drivers/spi/spi-tegra114.c:				&tspi->rx_dma_complete, SPI_DMA_TIMEOUT);
drivers/spi/spi-tegra114.c:				dmaengine_terminate_all(tspi->rx_dma_chan);
drivers/spi/spi-tegra114.c:				dev_err(tspi->dev, "RxDma Xfer failed\n");
drivers/spi/spi-tegra114.c:	spin_lock_irqsave(&tspi->lock, flags);
drivers/spi/spi-tegra114.c:		dev_err(tspi->dev, "DmaXfer: ERROR bit set 0x%x\n",
drivers/spi/spi-tegra114.c:			tspi->status_reg);
drivers/spi/spi-tegra114.c:		dev_err(tspi->dev, "DmaXfer 0x%08x:0x%08x\n",
drivers/spi/spi-tegra114.c:			tspi->command1_reg, tspi->dma_control_reg);
drivers/spi/spi-tegra114.c:		reset_control_assert(tspi->rst);
drivers/spi/spi-tegra114.c:		reset_control_deassert(tspi->rst);
drivers/spi/spi-tegra114.c:		complete(&tspi->xfer_completion);
drivers/spi/spi-tegra114.c:		spin_unlock_irqrestore(&tspi->lock, flags);
drivers/spi/spi-tegra114.c:	if (tspi->cur_direction & DATA_DIR_RX)
drivers/spi/spi-tegra114.c:	if (tspi->cur_direction & DATA_DIR_TX)
drivers/spi/spi-tegra114.c:		tspi->cur_pos = tspi->cur_tx_pos;
drivers/spi/spi-tegra114.c:		tspi->cur_pos = tspi->cur_rx_pos;
drivers/spi/spi-tegra114.c:	if (tspi->cur_pos == t->len) {
drivers/spi/spi-tegra114.c:		complete(&tspi->xfer_completion);
drivers/spi/spi-tegra114.c:	total_fifo_words = tegra_spi_calculate_curr_xfer_param(tspi->cur_spi,
drivers/spi/spi-tegra114.c:	spin_unlock_irqrestore(&tspi->lock, flags);
drivers/spi/spi-tegra114.c:	if (!tspi->is_curr_dma_xfer)
drivers/spi/spi-tegra114.c:	tspi->status_reg = tegra_spi_readl(tspi, SPI_FIFO_STATUS);
drivers/spi/spi-tegra114.c:	if (tspi->cur_direction & DATA_DIR_TX)
drivers/spi/spi-tegra114.c:		tspi->tx_status = tspi->status_reg &
drivers/spi/spi-tegra114.c:	if (tspi->cur_direction & DATA_DIR_RX)
drivers/spi/spi-tegra114.c:		tspi->rx_status = tspi->status_reg &
drivers/spi/spi-tegra114.c:	if (of_property_read_u32(pdev->dev.of_node, "spi-max-frequency",
drivers/spi/spi-tegra114.c:	/* the spi->mode bits understood by this driver: */
drivers/spi/spi-tegra114.c:	tspi->master = master;
drivers/spi/spi-tegra114.c:	tspi->dev = &pdev->dev;
drivers/spi/spi-tegra114.c:	spin_lock_init(&tspi->lock);
drivers/spi/spi-tegra114.c:	tspi->base = devm_ioremap_resource(&pdev->dev, r);
drivers/spi/spi-tegra114.c:	if (IS_ERR(tspi->base)) {
drivers/spi/spi-tegra114.c:		ret = PTR_ERR(tspi->base);
drivers/spi/spi-tegra114.c:	tspi->phys = r->start;
drivers/spi/spi-tegra114.c:	tspi->irq = spi_irq;
drivers/spi/spi-tegra114.c:	ret = request_threaded_irq(tspi->irq, tegra_spi_isr,
drivers/spi/spi-tegra114.c:					tspi->irq);
drivers/spi/spi-tegra114.c:	tspi->clk = devm_clk_get(&pdev->dev, "spi");
drivers/spi/spi-tegra114.c:	if (IS_ERR(tspi->clk)) {
drivers/spi/spi-tegra114.c:		ret = PTR_ERR(tspi->clk);
drivers/spi/spi-tegra114.c:	tspi->rst = devm_reset_control_get_exclusive(&pdev->dev, "spi");
drivers/spi/spi-tegra114.c:	if (IS_ERR(tspi->rst)) {
drivers/spi/spi-tegra114.c:		ret = PTR_ERR(tspi->rst);
drivers/spi/spi-tegra114.c:	tspi->max_buf_size = SPI_FIFO_DEPTH << 2;
drivers/spi/spi-tegra114.c:	tspi->dma_buf_size = DEFAULT_SPI_DMA_BUF_LEN;
drivers/spi/spi-tegra114.c:	tspi->max_buf_size = tspi->dma_buf_size;
drivers/spi/spi-tegra114.c:	init_completion(&tspi->tx_dma_complete);
drivers/spi/spi-tegra114.c:	init_completion(&tspi->rx_dma_complete);
drivers/spi/spi-tegra114.c:	init_completion(&tspi->xfer_completion);
drivers/spi/spi-tegra114.c:	tspi->def_command1_reg  = SPI_M_S;
drivers/spi/spi-tegra114.c:	tegra_spi_writel(tspi, tspi->def_command1_reg, SPI_COMMAND1);
drivers/spi/spi-tegra114.c:	free_irq(tspi->irq, tspi);
drivers/spi/spi-tegra114.c:	if (tspi->tx_dma_chan)
drivers/spi/spi-tegra114.c:	if (tspi->rx_dma_chan)
drivers/spi/spi-tegra114.c:	tegra_spi_writel(tspi, tspi->command1_reg, SPI_COMMAND1);
drivers/spi/spi-tegra114.c:	clk_disable_unprepare(tspi->clk);
drivers/spi/spi-tegra114.c:	ret = clk_prepare_enable(tspi->clk);
drivers/spi/spi-tegra114.c:		dev_err(tspi->dev, "clk_prepare failed: %d\n", ret);
drivers/spi/spi-tegra114.c:		.name		= "spi-tegra114",
drivers/spi/spi-tegra114.c:MODULE_ALIAS("platform:spi-tegra114");
drivers/spi/spi-ppc4xx.c:	dev_dbg(&spi->dev, "txrx: tx %p, rx %p, len %d\n",
drivers/spi/spi-ppc4xx.c:	hw = spi_master_get_devdata(spi->master);
drivers/spi/spi-ppc4xx.c:	struct ppc4xx_spi *hw = spi_master_get_devdata(spi->master);
drivers/spi/spi-ppc4xx.c:	struct spi_ppc4xx_cs *cs = spi->controller_state;
drivers/spi/spi-ppc4xx.c:	bits_per_word = spi->bits_per_word;
drivers/spi/spi-ppc4xx.c:	speed = spi->max_speed_hz;
drivers/spi/spi-ppc4xx.c:			speed = min(t->speed_hz, spi->max_speed_hz);
drivers/spi/spi-ppc4xx.c:	if (!speed || (speed > spi->max_speed_hz)) {
drivers/spi/spi-ppc4xx.c:		dev_err(&spi->dev, "invalid speed_hz (%d)\n", speed);
drivers/spi/spi-ppc4xx.c:	dev_dbg(&spi->dev, "setting pre-scaler to %d (hz %d)\n", cdm, speed);
drivers/spi/spi-ppc4xx.c:	struct spi_ppc4xx_cs *cs = spi->controller_state;
drivers/spi/spi-ppc4xx.c:	if (!spi->max_speed_hz) {
drivers/spi/spi-ppc4xx.c:		dev_err(&spi->dev, "invalid max_speed_hz (must be non-zero)\n");
drivers/spi/spi-ppc4xx.c:		spi->controller_state = cs;
drivers/spi/spi-ppc4xx.c:	switch (spi->mode & (SPI_CPHA | SPI_CPOL)) {
drivers/spi/spi-ppc4xx.c:	if (spi->mode & SPI_LSB_FIRST)
drivers/spi/spi-ppc4xx.c:	struct ppc4xx_spi *hw = spi_master_get_devdata(spi->master);
drivers/spi/spi-ppc4xx.c:	unsigned int cs = spi->chip_select;
drivers/spi/spi-ppc4xx.c:	cspol = spi->mode & SPI_CS_HIGH ? 1 : 0;
drivers/spi/spi-ppc4xx.c:	kfree(spi->controller_state);
drivers/spi/spi-ppc4xx.c:	/* the spi->mode bits understood by this driver: */
drivers/spi/spi-axi-spi-engine.c:	if (spi->mode & SPI_CPOL)
drivers/spi/spi-axi-spi-engine.c:	if (spi->mode & SPI_CPHA)
drivers/spi/spi-axi-spi-engine.c:	if (spi->mode & SPI_3WIRE)
drivers/spi/spi-axi-spi-engine.c:		mask ^= BIT(spi->chip_select);
drivers/spi/spi-axi-spi-engine.c:	{ .compatible = "adi,axi-spi-engine-1.00.a" },
drivers/spi/spi-axi-spi-engine.c:		.name = "spi-engine",
drivers/spi/spi-nuc900.c:#include <linux/platform_data/spi-nuc900.h>
drivers/spi/spi-nuc900.c:	unsigned int cs = spi->mode & SPI_CS_HIGH ? 1 : 0;
drivers/spi/spi-nuc900.c:	unsigned int cpol = spi->mode & SPI_CPOL ? 1 : 0;
drivers/spi/spi-xcomm.c:	unsigned long cs = spi->chip_select;
drivers/spi/spi-xcomm.c:	if (spi->mode & SPI_CPOL)
drivers/spi/spi-xcomm.c:	if (spi->mode & SPI_CPHA)
drivers/spi/spi-xcomm.c:	if (spi->mode & SPI_3WIRE)
drivers/spi/spi-xcomm.c:	{ "spi-xcomm" },
drivers/spi/spi-xcomm.c:		.name	= "spi-xcomm",
drivers/spi/spi-omap-100k.c:	struct omap1_spi100k_cs *cs = spi->controller_state;
drivers/spi/spi-omap-100k.c:				spi100k_write_data(spi->master, word_len, *tx++);
drivers/spi/spi-omap-100k.c:				*rx++ = spi100k_read_data(spi->master, word_len);
drivers/spi/spi-omap-100k.c:				spi100k_write_data(spi->master, word_len, *tx++);
drivers/spi/spi-omap-100k.c:				*rx++ = spi100k_read_data(spi->master, word_len);
drivers/spi/spi-omap-100k.c:				spi100k_write_data(spi->master, word_len, *tx);
drivers/spi/spi-omap-100k.c:				*rx = spi100k_read_data(spi->master, word_len);
drivers/spi/spi-omap-100k.c:	struct omap1_spi100k *spi100k = spi_master_get_devdata(spi->master);
drivers/spi/spi-omap-100k.c:	struct omap1_spi100k_cs *cs = spi->controller_state;
drivers/spi/spi-omap-100k.c:		word_len = spi->bits_per_word;
drivers/spi/spi-omap-100k.c:	if (spi->bits_per_word > 32)
drivers/spi/spi-omap-100k.c:/* the spi->mode bits understood by this driver: */
drivers/spi/spi-omap-100k.c:	struct omap1_spi100k_cs *cs = spi->controller_state;
drivers/spi/spi-omap-100k.c:	spi100k = spi_master_get_devdata(spi->master);
drivers/spi/spi-omap-100k.c:		cs = devm_kzalloc(&spi->dev, sizeof(*cs), GFP_KERNEL);
drivers/spi/spi-omap-100k.c:		cs->base = spi100k->base + spi->chip_select * 0x14;
drivers/spi/spi-omap-100k.c:		spi->controller_state = cs;
drivers/spi/spi-omap-100k.c:	spi100k_open(spi->master);
drivers/spi/Makefile:obj-$(CONFIG_SPI_LOOPBACK_TEST)		+= spi-loopback-test.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_ALTERA)		+= spi-altera.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_ARMADA_3700)		+= spi-armada-3700.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_ATMEL)			+= spi-atmel.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_ATH79)			+= spi-ath79.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_AU1550)		+= spi-au1550.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_AXI_SPI_ENGINE)	+= spi-axi-spi-engine.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_BCM2835)		+= spi-bcm2835.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_BCM2835AUX)		+= spi-bcm2835aux.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_BCM53XX)		+= spi-bcm53xx.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_BCM63XX)		+= spi-bcm63xx.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_BCM63XX_HSSPI)		+= spi-bcm63xx-hsspi.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_BCM_QSPI)		+= spi-iproc-qspi.o spi-brcmstb-qspi.o spi-bcm-qspi.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_BFIN5XX)		+= spi-bfin5xx.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_ADI_V3)                += spi-adi-v3.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_BFIN_SPORT)		+= spi-bfin-sport.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_BITBANG)		+= spi-bitbang.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_BUTTERFLY)		+= spi-butterfly.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_CADENCE)		+= spi-cadence.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_CLPS711X)		+= spi-clps711x.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_COLDFIRE_QSPI)		+= spi-coldfire-qspi.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_DAVINCI)		+= spi-davinci.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_DLN2)			+= spi-dln2.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_DESIGNWARE)		+= spi-dw.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_DW_MMIO)		+= spi-dw-mmio.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_DW_PCI)		+= spi-dw-midpci.o
drivers/spi/Makefile:spi-dw-midpci-objs			:= spi-dw-pci.o spi-dw-mid.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_EFM32)			+= spi-efm32.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_EP93XX)		+= spi-ep93xx.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_FALCON)		+= spi-falcon.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_FSL_CPM)		+= spi-fsl-cpm.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_FSL_DSPI)		+= spi-fsl-dspi.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_FSL_LIB)		+= spi-fsl-lib.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_FSL_ESPI)		+= spi-fsl-espi.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_FSL_LPSPI)		+= spi-fsl-lpspi.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_FSL_SPI)		+= spi-fsl-spi.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_GPIO)			+= spi-gpio.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_IMG_SPFI)		+= spi-img-spfi.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_IMX)			+= spi-imx.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_LANTIQ_SSC)		+= spi-lantiq-ssc.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_JCORE)			+= spi-jcore.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_LM70_LLP)		+= spi-lm70llp.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_LP8841_RTC)		+= spi-lp8841-rtc.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_MESON_SPICC)		+= spi-meson-spicc.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_MESON_SPIFC)		+= spi-meson-spifc.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_MPC512x_PSC)		+= spi-mpc512x-psc.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_MPC52xx_PSC)		+= spi-mpc52xx-psc.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_MPC52xx)		+= spi-mpc52xx.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_MT65XX)                += spi-mt65xx.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_MXS)			+= spi-mxs.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_NUC900)		+= spi-nuc900.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_OC_TINY)		+= spi-oc-tiny.o
drivers/spi/Makefile:spi-octeon-objs				:= spi-cavium.o spi-cavium-octeon.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_OCTEON)		+= spi-octeon.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_OMAP_UWIRE)		+= spi-omap-uwire.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_OMAP_100K)		+= spi-omap-100k.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_OMAP24XX)		+= spi-omap2-mcspi.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_TI_QSPI)		+= spi-ti-qspi.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_ORION)			+= spi-orion.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_PIC32)			+= spi-pic32.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_PIC32_SQI)		+= spi-pic32-sqi.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_PL022)			+= spi-pl022.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_PPC4xx)		+= spi-ppc4xx.o
drivers/spi/Makefile:spi-pxa2xx-platform-objs		:= spi-pxa2xx.o spi-pxa2xx-dma.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_PXA2XX)		+= spi-pxa2xx-platform.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_PXA2XX_PCI)		+= spi-pxa2xx-pci.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_QUP)			+= spi-qup.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_ROCKCHIP)		+= spi-rockchip.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_RB4XX)			+= spi-rb4xx.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_RSPI)			+= spi-rspi.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_S3C24XX)		+= spi-s3c24xx-hw.o
drivers/spi/Makefile:spi-s3c24xx-hw-y			:= spi-s3c24xx.o
drivers/spi/Makefile:spi-s3c24xx-hw-$(CONFIG_SPI_S3C24XX_FIQ) += spi-s3c24xx-fiq.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_S3C64XX)		+= spi-s3c64xx.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_SC18IS602)		+= spi-sc18is602.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_SH)			+= spi-sh.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_SH_HSPI)		+= spi-sh-hspi.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_SH_MSIOF)		+= spi-sh-msiof.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_SH_SCI)		+= spi-sh-sci.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_SIRF)		+= spi-sirf.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_SPRD_ADI)		+= spi-sprd-adi.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_STM32) 		+= spi-stm32.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_ST_SSC4)		+= spi-st-ssc4.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_SUN4I)			+= spi-sun4i.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_SUN6I)			+= spi-sun6i.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_TEGRA114)		+= spi-tegra114.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_TEGRA20_SFLASH)	+= spi-tegra20-sflash.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_TEGRA20_SLINK)		+= spi-tegra20-slink.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_TLE62X0)		+= spi-tle62x0.o
drivers/spi/Makefile:spi-thunderx-objs			:= spi-cavium.o spi-cavium-thunderx.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_THUNDERX)		+= spi-thunderx.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_TOPCLIFF_PCH)		+= spi-topcliff-pch.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_TXX9)			+= spi-txx9.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_XCOMM)		+= spi-xcomm.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_XILINX)		+= spi-xilinx.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_XLP)			+= spi-xlp.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_XTENSA_XTFPGA)		+= spi-xtensa-xtfpga.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_ZYNQMP_GQSPI)		+= spi-zynqmp-gqspi.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_SLAVE_TIME)		+= spi-slave-time.o
drivers/spi/Makefile:obj-$(CONFIG_SPI_SLAVE_SYSTEM_CONTROL)	+= spi-slave-system-control.o
drivers/spi/spi-s3c24xx-fiq.S:#include "spi-s3c24xx-fiq.h"
drivers/spi/spi-pic32.c:	u32			speed_hz; /* spi-clk rate */
drivers/spi/spi-pic32.c:	if (pic32s->bits_per_word != spi->bits_per_word) {
drivers/spi/spi-pic32.c:		pic32_spi_set_word_size(pic32s, spi->bits_per_word);
drivers/spi/spi-pic32.c:		pic32s->bits_per_word = spi->bits_per_word;
drivers/spi/spi-pic32.c:	if (pic32s->speed_hz != spi->max_speed_hz) {
drivers/spi/spi-pic32.c:		pic32_spi_set_clk_rate(pic32s, spi->max_speed_hz);
drivers/spi/spi-pic32.c:		pic32s->speed_hz = spi->max_speed_hz;
drivers/spi/spi-pic32.c:	if (pic32s->mode != spi->mode) {
drivers/spi/spi-pic32.c:		if (spi->mode & SPI_CPOL)
drivers/spi/spi-pic32.c:		if (spi->mode & SPI_CPHA)
drivers/spi/spi-pic32.c:		pic32s->mode = spi->mode;
drivers/spi/spi-pic32.c:			dev_err(&spi->dev, "dma submit error\n");
drivers/spi/spi-pic32.c:		dev_err(&spi->dev, "wait error/timedout\n");
drivers/spi/spi-pic32.c:	if (!spi->max_speed_hz) {
drivers/spi/spi-pic32.c:		dev_err(&spi->dev, "No max speed HZ parameter\n");
drivers/spi/spi-pic32.c:	if (!gpio_is_valid(spi->cs_gpio))
drivers/spi/spi-pic32.c:	gpio_direction_output(spi->cs_gpio, !(spi->mode & SPI_CS_HIGH));
drivers/spi/spi-pic32.c:	gpio_direction_output(spi->cs_gpio, !(spi->mode & SPI_CS_HIGH));
drivers/spi/spi-pic32.c:							  dev, "spi-rx");
drivers/spi/spi-pic32.c:							  dev, "spi-tx");
drivers/spi/spi-pic32.c:		.name = "spi-pic32",
drivers/spi/spi-s3c64xx.c:#include <linux/platform_data/spi-s3c64xx.h>
drivers/spi/spi-s3c64xx.c:					spi_master_get_devdata(spi->master);
drivers/spi/spi-s3c64xx.c:	spi->dma_rx = sdd->rx_dma.ch;
drivers/spi/spi-s3c64xx.c:	spi->dma_tx = sdd->tx_dma.ch;
drivers/spi/spi-s3c64xx.c:	struct s3c64xx_spi_csinfo *cs = spi->controller_data;
drivers/spi/spi-s3c64xx.c:		sdd->cur_mode = spi->mode;
drivers/spi/spi-s3c64xx.c:		dev_err(&spi->dev, "I/O Error: rx-%d tx-%d res:rx-%c tx-%c len-%d\n",
drivers/spi/spi-s3c64xx.c:	slave_np = spi->dev.of_node;
drivers/spi/spi-s3c64xx.c:		dev_err(&spi->dev, "device node not found\n");
drivers/spi/spi-s3c64xx.c:		dev_err(&spi->dev, "child node 'controller-data' not found\n");
drivers/spi/spi-s3c64xx.c:	of_property_read_u32(data_np, "samsung,spi-feedback-delay", &fb_delay);
drivers/spi/spi-s3c64xx.c:	struct s3c64xx_spi_csinfo *cs = spi->controller_data;
drivers/spi/spi-s3c64xx.c:	sdd = spi_master_get_devdata(spi->master);
drivers/spi/spi-s3c64xx.c:	if (spi->dev.of_node) {
drivers/spi/spi-s3c64xx.c:		spi->controller_data = cs;
drivers/spi/spi-s3c64xx.c:		/* On non-DT platforms the SPI core will set spi->cs_gpio
drivers/spi/spi-s3c64xx.c:		 * is defined by using platform data so spi->cs_gpio value
drivers/spi/spi-s3c64xx.c:		spi->cs_gpio = cs->line;
drivers/spi/spi-s3c64xx.c:		dev_err(&spi->dev, "No CS for SPI(%d)\n", spi->chip_select);
drivers/spi/spi-s3c64xx.c:		if (gpio_is_valid(spi->cs_gpio)) {
drivers/spi/spi-s3c64xx.c:			err = gpio_request_one(spi->cs_gpio, GPIOF_OUT_INIT_HIGH,
drivers/spi/spi-s3c64xx.c:					       dev_name(&spi->dev));
drivers/spi/spi-s3c64xx.c:				dev_err(&spi->dev,
drivers/spi/spi-s3c64xx.c:					spi->cs_gpio, err);
drivers/spi/spi-s3c64xx.c:		if (spi->max_speed_hz > speed)
drivers/spi/spi-s3c64xx.c:			spi->max_speed_hz = speed;
drivers/spi/spi-s3c64xx.c:		psr = clk_get_rate(sdd->src_clk) / 2 / spi->max_speed_hz - 1;
drivers/spi/spi-s3c64xx.c:		if (spi->max_speed_hz < speed) {
drivers/spi/spi-s3c64xx.c:		if (spi->max_speed_hz >= speed) {
drivers/spi/spi-s3c64xx.c:			spi->max_speed_hz = speed;
drivers/spi/spi-s3c64xx.c:			dev_err(&spi->dev, "Can't set %dHz transfer speed\n",
drivers/spi/spi-s3c64xx.c:				spi->max_speed_hz);
drivers/spi/spi-s3c64xx.c:	if (gpio_is_valid(spi->cs_gpio))
drivers/spi/spi-s3c64xx.c:		gpio_free(spi->cs_gpio);
drivers/spi/spi-s3c64xx.c:	if (spi->dev.of_node)
drivers/spi/spi-s3c64xx.c:	if (gpio_is_valid(spi->cs_gpio)) {
drivers/spi/spi-s3c64xx.c:		gpio_free(spi->cs_gpio);
drivers/spi/spi-s3c64xx.c:		if (spi->dev.of_node)
drivers/spi/spi-s3c64xx.c:			 * spi->cs_gpio to -ENOENT and .setup()
drivers/spi/spi-s3c64xx.c:			spi->cs_gpio = -ENOENT;
drivers/spi/spi-s3c64xx.c:		dev_err(&spi->dev, "RX overrun\n");
drivers/spi/spi-s3c64xx.c:		dev_err(&spi->dev, "RX underrun\n");
drivers/spi/spi-s3c64xx.c:		dev_err(&spi->dev, "TX overrun\n");
drivers/spi/spi-s3c64xx.c:		dev_err(&spi->dev, "TX underrun\n");
drivers/spi/spi-s3c64xx.c:	if (of_property_read_u32(dev->of_node, "samsung,spi-src-clk", &temp)) {
drivers/spi/spi-s3c64xx.c:	/* the spi->mode bits understood by this driver: */
drivers/spi/spi-s3c64xx.c:				"spi-s3c64xx", sdd);
drivers/spi/spi-pic32-sqi.c:	bd_ctrl = spi->chip_select << BD_DEVSEL_SHIFT;
drivers/spi/spi-pic32-sqi.c:	if (spi->mode & SPI_LSB_FIRST)
drivers/spi/spi-pic32-sqi.c:		if (sqi->cur_speed != spi->max_speed_hz) {
drivers/spi/spi-pic32-sqi.c:			sqi->cur_speed = spi->max_speed_hz;
drivers/spi/spi-pic32-sqi.c:			ret = pic32_sqi_set_clk_rate(sqi, spi->max_speed_hz);
drivers/spi/spi-pic32-sqi.c:				dev_warn(&spi->dev, "set_clk, %d\n", ret);
drivers/spi/spi-pic32-sqi.c:		mode = spi->mode & (SPI_MODE_3 | SPI_LSB_FIRST);
drivers/spi/spi-pic32-sqi.c:			dev_err(&spi->dev, "xfer %p err\n", xfer);
drivers/spi/spi-pic32-sqi.c:	spi_finalize_current_message(spi->master);
drivers/input/misc/adxl34x-spi.c:	if (spi->max_speed_hz > MAX_SPI_FREQ_HZ) {
drivers/input/misc/adxl34x-spi.c:		dev_err(&spi->dev, "SPI CLK %d Hz too fast\n", spi->max_speed_hz);
drivers/input/misc/adxl34x-spi.c:	ac = adxl34x_probe(&spi->dev, spi->irq,
drivers/input/misc/adxl34x-spi.c:			   spi->max_speed_hz > MAX_FREQ_NO_FIFODELAY,
drivers/input/misc/ad714x-spi.c:	spi->bits_per_word = 8;
drivers/input/misc/ad714x-spi.c:	chip = ad714x_probe(&spi->dev, BUS_SPI, spi->irq,
drivers/input/rmi4/rmi_spi.c:	struct spi_device *spi = rmi_spi->spi;
drivers/input/rmi4/rmi_spi.c:	int buf_size = rmi_spi->xfer_buf_size
drivers/input/rmi4/rmi_spi.c:		? rmi_spi->xfer_buf_size : RMI_SPI_DEFAULT_XFER_BUF_SIZE;
drivers/input/rmi4/rmi_spi.c:	tmp = rmi_spi->rx_buf;
drivers/input/rmi4/rmi_spi.c:	buf = devm_kzalloc(&spi->dev, buf_size * 2,
drivers/input/rmi4/rmi_spi.c:	rmi_spi->rx_buf = buf;
drivers/input/rmi4/rmi_spi.c:	rmi_spi->tx_buf = &rmi_spi->rx_buf[buf_size];
drivers/input/rmi4/rmi_spi.c:	rmi_spi->xfer_buf_size = buf_size;
drivers/input/rmi4/rmi_spi.c:		devm_kfree(&spi->dev, tmp);
drivers/input/rmi4/rmi_spi.c:	if (rmi_spi->xport.pdata.spi_data.read_delay_us)
drivers/input/rmi4/rmi_spi.c:		rmi_spi->rx_xfer_count = buf_size;
drivers/input/rmi4/rmi_spi.c:		rmi_spi->rx_xfer_count = 1;
drivers/input/rmi4/rmi_spi.c:	if (rmi_spi->xport.pdata.spi_data.write_delay_us)
drivers/input/rmi4/rmi_spi.c:		rmi_spi->tx_xfer_count = buf_size;
drivers/input/rmi4/rmi_spi.c:		rmi_spi->tx_xfer_count = 1;
drivers/input/rmi4/rmi_spi.c:	tmp = rmi_spi->rx_xfers;
drivers/input/rmi4/rmi_spi.c:	xfer_buf = devm_kzalloc(&spi->dev,
drivers/input/rmi4/rmi_spi.c:		(rmi_spi->rx_xfer_count + rmi_spi->tx_xfer_count)
drivers/input/rmi4/rmi_spi.c:	rmi_spi->rx_xfers = xfer_buf;
drivers/input/rmi4/rmi_spi.c:	rmi_spi->tx_xfers = &xfer_buf[rmi_spi->rx_xfer_count];
drivers/input/rmi4/rmi_spi.c:		devm_kfree(&spi->dev, tmp);
drivers/input/rmi4/rmi_spi.c:	struct spi_device *spi = rmi_spi->spi;
drivers/input/rmi4/rmi_spi.c:					&rmi_spi->xport.pdata.spi_data;
drivers/input/rmi4/rmi_spi.c:	if (rmi_spi->xfer_buf_size < len)
drivers/input/rmi4/rmi_spi.c:		rmi_spi->tx_buf[0] = (addr >> 8);
drivers/input/rmi4/rmi_spi.c:		rmi_spi->tx_buf[1] = addr & 0xFF;
drivers/input/rmi4/rmi_spi.c:		rmi_spi->tx_buf[0] = (addr >> 8) | 0x80;
drivers/input/rmi4/rmi_spi.c:		rmi_spi->tx_buf[1] = addr & 0xFF;
drivers/input/rmi4/rmi_spi.c:		rmi_spi->tx_buf[0] = 0x40;
drivers/input/rmi4/rmi_spi.c:		rmi_spi->tx_buf[1] = (addr >> 8) & 0xFF;
drivers/input/rmi4/rmi_spi.c:		rmi_spi->tx_buf[2] = addr & 0xFF;
drivers/input/rmi4/rmi_spi.c:		rmi_spi->tx_buf[3] = tx_len;
drivers/input/rmi4/rmi_spi.c:		memcpy(&rmi_spi->tx_buf[cmd_len], tx_buf, tx_len);
drivers/input/rmi4/rmi_spi.c:	if (rmi_spi->tx_xfer_count > 1) {
drivers/input/rmi4/rmi_spi.c:			xfer = &rmi_spi->tx_xfers[i];
drivers/input/rmi4/rmi_spi.c:			xfer->tx_buf = &rmi_spi->tx_buf[i];
drivers/input/rmi4/rmi_spi.c:		xfer = rmi_spi->tx_xfers;
drivers/input/rmi4/rmi_spi.c:		xfer->tx_buf = rmi_spi->tx_buf;
drivers/input/rmi4/rmi_spi.c:	rmi_dbg(RMI_DEBUG_XPORT, &spi->dev, "%s: cmd: %s tx_buf len: %d tx_buf: %*ph\n",
drivers/input/rmi4/rmi_spi.c:		total_tx_len, total_tx_len, rmi_spi->tx_buf);
drivers/input/rmi4/rmi_spi.c:		if (rmi_spi->rx_xfer_count > 1) {
drivers/input/rmi4/rmi_spi.c:				xfer = &rmi_spi->rx_xfers[i];
drivers/input/rmi4/rmi_spi.c:				xfer->rx_buf = &rmi_spi->rx_buf[i];
drivers/input/rmi4/rmi_spi.c:			xfer = rmi_spi->rx_xfers;
drivers/input/rmi4/rmi_spi.c:			xfer->rx_buf = rmi_spi->rx_buf;
drivers/input/rmi4/rmi_spi.c:		dev_err(&spi->dev, "spi xfer failed: %d\n", ret);
drivers/input/rmi4/rmi_spi.c:		memcpy(rx_buf, rmi_spi->rx_buf, rx_len);
drivers/input/rmi4/rmi_spi.c:		rmi_dbg(RMI_DEBUG_XPORT, &spi->dev, "%s: (%d) %*ph\n",
drivers/input/rmi4/rmi_spi.c:		rmi_spi->page = page;
drivers/input/rmi4/rmi_spi.c:	mutex_lock(&rmi_spi->page_mutex);
drivers/input/rmi4/rmi_spi.c:	if (RMI_SPI_PAGE(addr) != rmi_spi->page) {
drivers/input/rmi4/rmi_spi.c:	mutex_unlock(&rmi_spi->page_mutex);
drivers/input/rmi4/rmi_spi.c:	mutex_lock(&rmi_spi->page_mutex);
drivers/input/rmi4/rmi_spi.c:	if (RMI_SPI_PAGE(addr) != rmi_spi->page) {
drivers/input/rmi4/rmi_spi.c:	mutex_unlock(&rmi_spi->page_mutex);
drivers/input/rmi4/rmi_spi.c:	struct device *dev = &spi->dev;
drivers/input/rmi4/rmi_spi.c:			"spi-rx-delay-us", 1);
drivers/input/rmi4/rmi_spi.c:			"spi-tx-delay-us", 1);
drivers/input/rmi4/rmi_spi.c:	rmi_unregister_transport_device(&rmi_spi->xport);
drivers/input/rmi4/rmi_spi.c:	struct rmi_device_platform_data *spi_pdata = spi->dev.platform_data;
drivers/input/rmi4/rmi_spi.c:	if (spi->master->flags & SPI_MASTER_HALF_DUPLEX)
drivers/input/rmi4/rmi_spi.c:	rmi_spi = devm_kzalloc(&spi->dev, sizeof(struct rmi_spi_xport),
drivers/input/rmi4/rmi_spi.c:	pdata = &rmi_spi->xport.pdata;
drivers/input/rmi4/rmi_spi.c:	if (spi->dev.of_node) {
drivers/input/rmi4/rmi_spi.c:		spi->bits_per_word = pdata->spi_data.bits_per_word;
drivers/input/rmi4/rmi_spi.c:		spi->mode = pdata->spi_data.mode;
drivers/input/rmi4/rmi_spi.c:		dev_err(&spi->dev, "spi_setup failed!\n");
drivers/input/rmi4/rmi_spi.c:	pdata->irq = spi->irq;
drivers/input/rmi4/rmi_spi.c:	rmi_spi->spi = spi;
drivers/input/rmi4/rmi_spi.c:	mutex_init(&rmi_spi->page_mutex);
drivers/input/rmi4/rmi_spi.c:	rmi_spi->xport.dev = &spi->dev;
drivers/input/rmi4/rmi_spi.c:	rmi_spi->xport.proto_name = "spi";
drivers/input/rmi4/rmi_spi.c:	rmi_spi->xport.ops = &rmi_spi_ops;
drivers/input/rmi4/rmi_spi.c:		dev_err(&spi->dev, "Failed to set page select to 0.\n");
drivers/input/rmi4/rmi_spi.c:	dev_info(&spi->dev, "registering SPI-connected sensor\n");
drivers/input/rmi4/rmi_spi.c:	error = rmi_register_transport_device(&rmi_spi->xport);
drivers/input/rmi4/rmi_spi.c:		dev_err(&spi->dev, "failed to register sensor: %d\n", error);
drivers/input/rmi4/rmi_spi.c:	error = devm_add_action_or_reset(&spi->dev,
drivers/input/rmi4/rmi_spi.c:	ret = rmi_driver_suspend(rmi_spi->xport.rmi_dev, true);
drivers/input/rmi4/rmi_spi.c:	ret = rmi_driver_resume(rmi_spi->xport.rmi_dev, true);
drivers/input/rmi4/rmi_spi.c:	ret = rmi_driver_suspend(rmi_spi->xport.rmi_dev, false);
drivers/input/rmi4/rmi_spi.c:	ret = rmi_driver_resume(rmi_spi->xport.rmi_dev, false);
drivers/input/touchscreen/ads7846.c:		disable_irq(ts->spi->irq);
drivers/input/touchscreen/ads7846.c:		enable_irq(ts->spi->irq);
drivers/input/touchscreen/ads7846.c:		dev_err(&ts->spi->dev, "Failed to enable supply: %d\n", error);
drivers/input/touchscreen/ads7846.c:	ssize_t v = ads7846_read12_ser(&ts->spi->dev, \
drivers/input/touchscreen/ads7846.c:			dev_dbg(&spi->dev, "assuming 2.5V internal vREF\n");
drivers/input/touchscreen/ads7846.c:			dev_warn(&spi->dev,
drivers/input/touchscreen/ads7846.c:	ts->hwmon = hwmon_device_register_with_groups(&spi->dev, spi->modalias,
drivers/input/touchscreen/ads7846.c:			dev_err(&ts->spi->dev, "spi_sync --> %d\n", error);
drivers/input/touchscreen/ads7846.c:		dev_vdbg(&ts->spi->dev, "x/y: %d/%d, PD %d\n", x, y, Rt);
drivers/input/touchscreen/ads7846.c:		dev_vdbg(&ts->spi->dev, "ignored %d pressure %d\n",
drivers/input/touchscreen/ads7846.c:			dev_vdbg(&ts->spi->dev, "DOWN\n");
drivers/input/touchscreen/ads7846.c:		dev_vdbg(&ts->spi->dev, "%4d/%4d/%4d\n", x, y, Rt);
drivers/input/touchscreen/ads7846.c:		dev_vdbg(&ts->spi->dev, "UP\n");
drivers/input/touchscreen/ads7846.c:		if (device_may_wakeup(&ts->spi->dev))
drivers/input/touchscreen/ads7846.c:			enable_irq_wake(ts->spi->irq);
drivers/input/touchscreen/ads7846.c:		if (device_may_wakeup(&ts->spi->dev))
drivers/input/touchscreen/ads7846.c:			disable_irq_wake(ts->spi->irq);
drivers/input/touchscreen/ads7846.c:			dev_err(&spi->dev,
drivers/input/touchscreen/ads7846.c:		dev_err(&spi->dev, "no get_pendown_state nor gpio_pendown?\n");
drivers/input/touchscreen/ads7846.c:	if (!spi->irq) {
drivers/input/touchscreen/ads7846.c:		dev_dbg(&spi->dev, "no IRQ?\n");
drivers/input/touchscreen/ads7846.c:	if (spi->max_speed_hz > (125000 * SAMPLE_BITS)) {
drivers/input/touchscreen/ads7846.c:		dev_err(&spi->dev, "f(sample) %d KHz?\n",
drivers/input/touchscreen/ads7846.c:				(spi->max_speed_hz/SAMPLE_BITS)/1000);
drivers/input/touchscreen/ads7846.c:	spi->bits_per_word = 8;
drivers/input/touchscreen/ads7846.c:	spi->mode = SPI_MODE_0;
drivers/input/touchscreen/ads7846.c:	pdata = dev_get_platdata(&spi->dev);
drivers/input/touchscreen/ads7846.c:		pdata = ads7846_probe_dt(&spi->dev);
drivers/input/touchscreen/ads7846.c:	snprintf(ts->phys, sizeof(ts->phys), "%s/input0", dev_name(&spi->dev));
drivers/input/touchscreen/ads7846.c:	input_dev->dev.parent = &spi->dev;
drivers/input/touchscreen/ads7846.c:	ts->reg = regulator_get(&spi->dev, "vcc");
drivers/input/touchscreen/ads7846.c:		dev_err(&spi->dev, "unable to get regulator: %d\n", err);
drivers/input/touchscreen/ads7846.c:		dev_err(&spi->dev, "unable to enable regulator: %d\n", err);
drivers/input/touchscreen/ads7846.c:	err = request_threaded_irq(spi->irq, ads7846_hard_irq, ads7846_irq,
drivers/input/touchscreen/ads7846.c:				   irq_flags, spi->dev.driver->name, ts);
drivers/input/touchscreen/ads7846.c:		dev_info(&spi->dev,
drivers/input/touchscreen/ads7846.c:			"trying pin change workaround on irq %d\n", spi->irq);
drivers/input/touchscreen/ads7846.c:		err = request_threaded_irq(spi->irq,
drivers/input/touchscreen/ads7846.c:				  irq_flags, spi->dev.driver->name, ts);
drivers/input/touchscreen/ads7846.c:		dev_dbg(&spi->dev, "irq %d busy?\n", spi->irq);
drivers/input/touchscreen/ads7846.c:	dev_info(&spi->dev, "touchscreen, irq %d\n", spi->irq);
drivers/input/touchscreen/ads7846.c:		ads7845_read12_ser(&spi->dev, PWRDOWN);
drivers/input/touchscreen/ads7846.c:		(void) ads7846_read12_ser(&spi->dev, READ_12BIT_SER(vaux));
drivers/input/touchscreen/ads7846.c:	err = sysfs_create_group(&spi->dev.kobj, &ads784x_attr_group);
drivers/input/touchscreen/ads7846.c:	device_init_wakeup(&spi->dev, pdata->wakeup);
drivers/input/touchscreen/ads7846.c:	if (!dev_get_platdata(&spi->dev))
drivers/input/touchscreen/ads7846.c:		devm_kfree(&spi->dev, (void *)pdata);
drivers/input/touchscreen/ads7846.c:	sysfs_remove_group(&spi->dev.kobj, &ads784x_attr_group);
drivers/input/touchscreen/ads7846.c:	free_irq(spi->irq, ts);
drivers/input/touchscreen/ads7846.c:	sysfs_remove_group(&spi->dev.kobj, &ads784x_attr_group);
drivers/input/touchscreen/ads7846.c:	free_irq(ts->spi->irq, ts);
drivers/input/touchscreen/ads7846.c:	dev_dbg(&spi->dev, "unregistered touchscreen\n");
drivers/input/touchscreen/ad7879-spi.c:	if (spi->max_speed_hz > MAX_SPI_FREQ_HZ) {
drivers/input/touchscreen/ad7879-spi.c:		dev_err(&spi->dev, "SPI CLK %d Hz?\n", spi->max_speed_hz);
drivers/input/touchscreen/ad7879-spi.c:	return ad7879_probe(&spi->dev, regmap, spi->irq, BUS_SPI, AD7879_DEVID);
drivers/input/touchscreen/surface3_spi.c:		dev_err(&ts_data->spi->dev,
drivers/input/touchscreen/surface3_spi.c:		dev_err(&ts_data->spi->dev,
drivers/input/touchscreen/surface3_spi.c:	dev_dbg(&data->spi->dev, "%s received -> %*ph\n",
drivers/input/touchscreen/surface3_spi.c:	dev = &data->spi->dev;
drivers/input/touchscreen/surface3_spi.c:	input = devm_input_allocate_device(&data->spi->dev);
drivers/input/touchscreen/surface3_spi.c:		dev_err(&data->spi->dev,
drivers/input/touchscreen/surface3_spi.c:	input = devm_input_allocate_device(&data->spi->dev);
drivers/input/touchscreen/surface3_spi.c:		dev_err(&data->spi->dev,
drivers/input/touchscreen/surface3_spi.c:	spi->bits_per_word = 8;
drivers/input/touchscreen/surface3_spi.c:	spi->mode = SPI_MODE_0;
drivers/input/touchscreen/surface3_spi.c:	data = devm_kzalloc(&spi->dev, sizeof(*data), GFP_KERNEL);
drivers/input/touchscreen/surface3_spi.c:	error = devm_request_threaded_irq(&spi->dev, spi->irq,
drivers/input/touchscreen/surface3_spi.c:	disable_irq(data->spi->irq);
drivers/input/touchscreen/surface3_spi.c:	enable_irq(data->spi->irq);
drivers/input/touchscreen/tsc2005.c:	spi->mode = SPI_MODE_0;
drivers/input/touchscreen/tsc2005.c:	spi->bits_per_word = 8;
drivers/input/touchscreen/tsc2005.c:	if (!spi->max_speed_hz)
drivers/input/touchscreen/tsc2005.c:		spi->max_speed_hz = TSC2005_SPI_MAX_SPEED_HZ;
drivers/input/touchscreen/tsc2005.c:	return tsc200x_probe(&spi->dev, spi->irq, &tsc2005_input_id,
drivers/input/touchscreen/tsc2005.c:	return tsc200x_remove(&spi->dev);
drivers/input/touchscreen/cyttsp_spi.c:	spi->bits_per_word = CY_SPI_BITS_PER_WORD;
drivers/input/touchscreen/cyttsp_spi.c:	spi->mode = SPI_MODE_0;
drivers/input/touchscreen/cyttsp_spi.c:		dev_err(&spi->dev, "%s: SPI setup error %d\n",
drivers/input/touchscreen/cyttsp_spi.c:	ts = cyttsp_probe(&cyttsp_spi_bus_ops, &spi->dev, spi->irq,
drivers/input/touchscreen/cyttsp4_spi.c:	spi->bits_per_word = CY_SPI_BITS_PER_WORD;
drivers/input/touchscreen/cyttsp4_spi.c:	spi->mode = SPI_MODE_0;
drivers/input/touchscreen/cyttsp4_spi.c:		dev_err(&spi->dev, "%s: SPI setup error %d\n",
drivers/input/touchscreen/cyttsp4_spi.c:	ts = cyttsp4_probe(&cyttsp_spi_bus_ops, &spi->dev, spi->irq,
drivers/input/touchscreen/ad7877.c:		dev_err(&ts->spi->dev, "spi_sync --> %d\n", error);
drivers/input/touchscreen/ad7877.c:		disable_irq(ts->spi->irq);
drivers/input/touchscreen/ad7877.c:		enable_irq(ts->spi->irq);
drivers/input/touchscreen/ad7877.c:	struct ad7877_platform_data	*pdata = dev_get_platdata(&spi->dev);
drivers/input/touchscreen/ad7877.c:	if (!spi->irq) {
drivers/input/touchscreen/ad7877.c:		dev_dbg(&spi->dev, "no IRQ?\n");
drivers/input/touchscreen/ad7877.c:		dev_dbg(&spi->dev, "no platform data?\n");
drivers/input/touchscreen/ad7877.c:	if (spi->max_speed_hz > MAX_SPI_FREQ_HZ) {
drivers/input/touchscreen/ad7877.c:		dev_dbg(&spi->dev, "SPI CLK %d Hz?\n",spi->max_speed_hz);
drivers/input/touchscreen/ad7877.c:	spi->bits_per_word = 16;
drivers/input/touchscreen/ad7877.c:		dev_dbg(&spi->dev, "spi master doesn't support 16 bits/word\n");
drivers/input/touchscreen/ad7877.c:	ts = devm_kzalloc(&spi->dev, sizeof(struct ad7877), GFP_KERNEL);
drivers/input/touchscreen/ad7877.c:	input_dev = devm_input_allocate_device(&spi->dev);
drivers/input/touchscreen/ad7877.c:	err = devm_add_action_or_reset(&spi->dev, ad7877_disable, ts);
drivers/input/touchscreen/ad7877.c:	snprintf(ts->phys, sizeof(ts->phys), "%s/input0", dev_name(&spi->dev));
drivers/input/touchscreen/ad7877.c:	input_dev->dev.parent = &spi->dev;
drivers/input/touchscreen/ad7877.c:		dev_err(&spi->dev, "%s: Failed to probe %s\n",
drivers/input/touchscreen/ad7877.c:			dev_name(&spi->dev), input_dev->name);
drivers/input/touchscreen/ad7877.c:	err = devm_request_threaded_irq(&spi->dev, spi->irq, NULL, ad7877_irq,
drivers/input/touchscreen/ad7877.c:					spi->dev.driver->name, ts);
drivers/input/touchscreen/ad7877.c:		dev_dbg(&spi->dev, "irq %d busy?\n", spi->irq);
drivers/input/touchscreen/ad7877.c:	err = devm_device_add_group(&spi->dev, &ad7877_attr_group);
drivers/input/joystick/psxpad-spi.c:		dev_err(&pad->spi->dev,
drivers/input/joystick/psxpad-spi.c:		dev_err(&pad->spi->dev,
drivers/input/joystick/psxpad-spi.c:		dev_err(&pad->spi->dev,
drivers/input/joystick/psxpad-spi.c:		dev_err(&pad->spi->dev,
drivers/input/joystick/psxpad-spi.c:		dev_err(&pad->spi->dev,
drivers/input/joystick/psxpad-spi.c:	pm_runtime_get_sync(&pad->spi->dev);
drivers/input/joystick/psxpad-spi.c:	pm_runtime_put_sync(&pad->spi->dev);
drivers/input/joystick/psxpad-spi.c:		dev_err(&pad->spi->dev,
drivers/input/joystick/psxpad-spi.c:	pad = devm_kzalloc(&spi->dev, sizeof(struct psxpad), GFP_KERNEL);
drivers/input/joystick/psxpad-spi.c:		dev_err(&spi->dev, "failed to allocate input device\n");
drivers/input/joystick/psxpad-spi.c:	snprintf(pad->phys, sizeof(pad->phys), "%s/input", dev_name(&spi->dev));
drivers/input/joystick/psxpad-spi.c:	spi->mode = SPI_MODE_3;
drivers/input/joystick/psxpad-spi.c:	spi->bits_per_word = 8;
drivers/input/joystick/psxpad-spi.c:	spi->master->min_speed_hz = 125000;
drivers/input/joystick/psxpad-spi.c:	spi->master->max_speed_hz = 125000;
drivers/input/joystick/psxpad-spi.c:		dev_err(&spi->dev,
drivers/input/joystick/psxpad-spi.c:	pm_runtime_enable(&spi->dev);
drivers/leds/leds-dac124s085.c:	dac = devm_kzalloc(&spi->dev, sizeof(*dac), GFP_KERNEL);
drivers/leds/leds-dac124s085.c:	spi->bits_per_word = 16;
drivers/leds/leds-dac124s085.c:		ret = led_classdev_register(&spi->dev, &led->ldev);
drivers/char/tpm/st33zp24/Makefile:tpm_st33zp24_spi-objs = spi.o
drivers/ata/pata_ep93xx.c: * DMA engine support based on spi-ep93xx.c by Mika Westerberg.
drivers/built-in.o:mtd/spi-nor/spi-nor.o/
drivers/built-in.o:spi/spi-sun6i.o/
drivers/mtd/modules.builtin:kernel/drivers/mtd/spi-nor/spi-nor.ko
drivers/mtd/spi-nor/nxp-spifi.c:#include <linux/mtd/spi-nor.h>
drivers/mtd/spi-nor/nxp-spifi.c:	if (!of_property_read_u32(np, "spi-rx-bus-width", &property)) {
drivers/mtd/spi-nor/nxp-spifi.c:	if (of_find_property(np, "spi-cpha", NULL))
drivers/mtd/spi-nor/nxp-spifi.c:	if (of_find_property(np, "spi-cpol", NULL))
Binary file drivers/mtd/spi-nor/spi-nor.o matches
drivers/mtd/spi-nor/spi-nor.c:#include <linux/mtd/spi-nor.h>
drivers/mtd/spi-nor/spi-nor.c:		pr_err("spi-nor: please fill all the necessary fields!\n");
drivers/mtd/spi-nor/spi-nor.c:	 * In the spi-nor framework, we don't need to make the difference
drivers/mtd/spi-nor/spi-nor.c:	 * with Atmel spi-nor
drivers/mtd/spi-nor/intel-spi.c:#include <linux/mtd/spi-nor.h>
drivers/mtd/spi-nor/intel-spi.c:/* Offsets are from @ispi->base */
drivers/mtd/spi-nor/intel-spi.c:/* Offset is from @ispi->pregs */
drivers/mtd/spi-nor/intel-spi.c:/* Offsets are from @ispi->sregs */
drivers/mtd/spi-nor/intel-spi.c:	dev_dbg(ispi->dev, "BFPREG=0x%08x\n", readl(ispi->base + BFPREG));
drivers/mtd/spi-nor/intel-spi.c:	value = readl(ispi->base + HSFSTS_CTL);
drivers/mtd/spi-nor/intel-spi.c:	dev_dbg(ispi->dev, "HSFSTS_CTL=0x%08x\n", value);
drivers/mtd/spi-nor/intel-spi.c:		dev_dbg(ispi->dev, "-> Locked\n");
drivers/mtd/spi-nor/intel-spi.c:	dev_dbg(ispi->dev, "FADDR=0x%08x\n", readl(ispi->base + FADDR));
drivers/mtd/spi-nor/intel-spi.c:	dev_dbg(ispi->dev, "DLOCK=0x%08x\n", readl(ispi->base + DLOCK));
drivers/mtd/spi-nor/intel-spi.c:		dev_dbg(ispi->dev, "FDATA(%d)=0x%08x\n",
drivers/mtd/spi-nor/intel-spi.c:			i, readl(ispi->base + FDATA(i)));
drivers/mtd/spi-nor/intel-spi.c:	dev_dbg(ispi->dev, "FRACC=0x%08x\n", readl(ispi->base + FRACC));
drivers/mtd/spi-nor/intel-spi.c:	for (i = 0; i < ispi->nregions; i++)
drivers/mtd/spi-nor/intel-spi.c:		dev_dbg(ispi->dev, "FREG(%d)=0x%08x\n", i,
drivers/mtd/spi-nor/intel-spi.c:			readl(ispi->base + FREG(i)));
drivers/mtd/spi-nor/intel-spi.c:	for (i = 0; i < ispi->pr_num; i++)
drivers/mtd/spi-nor/intel-spi.c:		dev_dbg(ispi->dev, "PR(%d)=0x%08x\n", i,
drivers/mtd/spi-nor/intel-spi.c:			readl(ispi->pregs + PR(i)));
drivers/mtd/spi-nor/intel-spi.c:	value = readl(ispi->sregs + SSFSTS_CTL);
drivers/mtd/spi-nor/intel-spi.c:	dev_dbg(ispi->dev, "SSFSTS_CTL=0x%08x\n", value);
drivers/mtd/spi-nor/intel-spi.c:	dev_dbg(ispi->dev, "PREOP_OPTYPE=0x%08x\n",
drivers/mtd/spi-nor/intel-spi.c:		readl(ispi->sregs + PREOP_OPTYPE));
drivers/mtd/spi-nor/intel-spi.c:	dev_dbg(ispi->dev, "OPMENU0=0x%08x\n", readl(ispi->sregs + OPMENU0));
drivers/mtd/spi-nor/intel-spi.c:	dev_dbg(ispi->dev, "OPMENU1=0x%08x\n", readl(ispi->sregs + OPMENU1));
drivers/mtd/spi-nor/intel-spi.c:	if (ispi->info->type == INTEL_SPI_BYT)
drivers/mtd/spi-nor/intel-spi.c:		dev_dbg(ispi->dev, "BCR=0x%08x\n", readl(ispi->base + BYT_BCR));
drivers/mtd/spi-nor/intel-spi.c:	dev_dbg(ispi->dev, "LVSCC=0x%08x\n", readl(ispi->base + LVSCC));
drivers/mtd/spi-nor/intel-spi.c:	dev_dbg(ispi->dev, "UVSCC=0x%08x\n", readl(ispi->base + UVSCC));
drivers/mtd/spi-nor/intel-spi.c:	dev_dbg(ispi->dev, "Protected regions:\n");
drivers/mtd/spi-nor/intel-spi.c:	for (i = 0; i < ispi->pr_num; i++) {
drivers/mtd/spi-nor/intel-spi.c:		value = readl(ispi->pregs + PR(i));
drivers/mtd/spi-nor/intel-spi.c:		dev_dbg(ispi->dev, " %02d base: 0x%08x limit: 0x%08x [%c%c]\n",
drivers/mtd/spi-nor/intel-spi.c:	dev_dbg(ispi->dev, "Flash regions:\n");
drivers/mtd/spi-nor/intel-spi.c:	for (i = 0; i < ispi->nregions; i++) {
drivers/mtd/spi-nor/intel-spi.c:		region = readl(ispi->base + FREG(i));
drivers/mtd/spi-nor/intel-spi.c:			dev_dbg(ispi->dev, " %02d disabled\n", i);
drivers/mtd/spi-nor/intel-spi.c:			dev_dbg(ispi->dev, " %02d base: 0x%08x limit: 0x%08x\n",
drivers/mtd/spi-nor/intel-spi.c:	dev_dbg(ispi->dev, "Using %cW sequencer for register access\n",
drivers/mtd/spi-nor/intel-spi.c:		ispi->swseq_reg ? 'S' : 'H');
drivers/mtd/spi-nor/intel-spi.c:	dev_dbg(ispi->dev, "Using %cW sequencer for erase operation\n",
drivers/mtd/spi-nor/intel-spi.c:		ispi->swseq_erase ? 'S' : 'H');
drivers/mtd/spi-nor/intel-spi.c:		memcpy_fromio(buf, ispi->base + FDATA(i), bytes);
drivers/mtd/spi-nor/intel-spi.c:		memcpy_toio(ispi->base + FDATA(i), buf, bytes);
drivers/mtd/spi-nor/intel-spi.c:	return readl_poll_timeout(ispi->base + HSFSTS_CTL, val,
drivers/mtd/spi-nor/intel-spi.c:	return readl_poll_timeout(ispi->sregs + SSFSTS_CTL, val,
drivers/mtd/spi-nor/intel-spi.c:	switch (ispi->info->type) {
drivers/mtd/spi-nor/intel-spi.c:		ispi->sregs = ispi->base + BYT_SSFSTS_CTL;
drivers/mtd/spi-nor/intel-spi.c:		ispi->pregs = ispi->base + BYT_PR;
drivers/mtd/spi-nor/intel-spi.c:		ispi->nregions = BYT_FREG_NUM;
drivers/mtd/spi-nor/intel-spi.c:		ispi->pr_num = BYT_PR_NUM;
drivers/mtd/spi-nor/intel-spi.c:		ispi->swseq_reg = true;
drivers/mtd/spi-nor/intel-spi.c:			val = readl(ispi->base + BYT_BCR);
drivers/mtd/spi-nor/intel-spi.c:				writel(val, ispi->base + BYT_BCR);
drivers/mtd/spi-nor/intel-spi.c:				val = readl(ispi->base + BYT_BCR);
drivers/mtd/spi-nor/intel-spi.c:			ispi->writeable = !!(val & BYT_BCR_WPD);
drivers/mtd/spi-nor/intel-spi.c:		ispi->sregs = ispi->base + LPT_SSFSTS_CTL;
drivers/mtd/spi-nor/intel-spi.c:		ispi->pregs = ispi->base + LPT_PR;
drivers/mtd/spi-nor/intel-spi.c:		ispi->nregions = LPT_FREG_NUM;
drivers/mtd/spi-nor/intel-spi.c:		ispi->pr_num = LPT_PR_NUM;
drivers/mtd/spi-nor/intel-spi.c:		ispi->swseq_reg = true;
drivers/mtd/spi-nor/intel-spi.c:		ispi->sregs = ispi->base + BXT_SSFSTS_CTL;
drivers/mtd/spi-nor/intel-spi.c:		ispi->pregs = ispi->base + BXT_PR;
drivers/mtd/spi-nor/intel-spi.c:		ispi->nregions = BXT_FREG_NUM;
drivers/mtd/spi-nor/intel-spi.c:		ispi->pr_num = BXT_PR_NUM;
drivers/mtd/spi-nor/intel-spi.c:		ispi->erase_64k = true;
drivers/mtd/spi-nor/intel-spi.c:	val = readl(ispi->base + HSFSTS_CTL);
drivers/mtd/spi-nor/intel-spi.c:	writel(val, ispi->base + HSFSTS_CTL);
drivers/mtd/spi-nor/intel-spi.c:	lvscc = readl(ispi->base + LVSCC);
drivers/mtd/spi-nor/intel-spi.c:	uvscc = readl(ispi->base + UVSCC);
drivers/mtd/spi-nor/intel-spi.c:		ispi->swseq_erase = true;
drivers/mtd/spi-nor/intel-spi.c:	if (ispi->info->type == INTEL_SPI_BXT && !ispi->swseq_erase)
drivers/mtd/spi-nor/intel-spi.c:			ispi->erase_64k = false;
drivers/mtd/spi-nor/intel-spi.c:	if (ispi->swseq_reg) {
drivers/mtd/spi-nor/intel-spi.c:		val = readl(ispi->sregs + SSFSTS_CTL);
drivers/mtd/spi-nor/intel-spi.c:		writel(val, ispi->sregs + SSFSTS_CTL);
drivers/mtd/spi-nor/intel-spi.c:	val = readl(ispi->base + HSFSTS_CTL);
drivers/mtd/spi-nor/intel-spi.c:	ispi->locked = !!(val & HSFSTS_CTL_FLOCKDN);
drivers/mtd/spi-nor/intel-spi.c:	if (ispi->locked) {
drivers/mtd/spi-nor/intel-spi.c:		opmenu0 = readl(ispi->sregs + OPMENU0);
drivers/mtd/spi-nor/intel-spi.c:		opmenu1 = readl(ispi->sregs + OPMENU1);
drivers/mtd/spi-nor/intel-spi.c:			for (i = 0; i < ARRAY_SIZE(ispi->opcodes) / 2; i++) {
drivers/mtd/spi-nor/intel-spi.c:				ispi->opcodes[i] = opmenu0 >> i * 8;
drivers/mtd/spi-nor/intel-spi.c:				ispi->opcodes[i + 4] = opmenu1 >> i * 8;
drivers/mtd/spi-nor/intel-spi.c:	if (ispi->locked) {
drivers/mtd/spi-nor/intel-spi.c:		for (i = 0; i < ARRAY_SIZE(ispi->opcodes); i++)
drivers/mtd/spi-nor/intel-spi.c:			if (ispi->opcodes[i] == opcode)
drivers/mtd/spi-nor/intel-spi.c:	writel(opcode, ispi->sregs + OPMENU0);
drivers/mtd/spi-nor/intel-spi.c:	preop = readw(ispi->sregs + PREOP_OPTYPE);
drivers/mtd/spi-nor/intel-spi.c:	writel(optype << 16 | preop, ispi->sregs + PREOP_OPTYPE);
drivers/mtd/spi-nor/intel-spi.c:	val = readl(ispi->base + HSFSTS_CTL);
drivers/mtd/spi-nor/intel-spi.c:	writel(val, ispi->base + HSFSTS_CTL);
drivers/mtd/spi-nor/intel-spi.c:	status = readl(ispi->base + HSFSTS_CTL);
drivers/mtd/spi-nor/intel-spi.c:	preop = readw(ispi->sregs + PREOP_OPTYPE);
drivers/mtd/spi-nor/intel-spi.c:	writel(val, ispi->sregs + SSFSTS_CTL);
drivers/mtd/spi-nor/intel-spi.c:	status = readl(ispi->sregs + SSFSTS_CTL);
drivers/mtd/spi-nor/intel-spi.c:	writel(0, ispi->base + FADDR);
drivers/mtd/spi-nor/intel-spi.c:	if (ispi->swseq_reg)
drivers/mtd/spi-nor/intel-spi.c:		if (!ispi->locked)
drivers/mtd/spi-nor/intel-spi.c:			writel(opcode, ispi->sregs + PREOP_OPTYPE);
drivers/mtd/spi-nor/intel-spi.c:	writel(0, ispi->base + FADDR);
drivers/mtd/spi-nor/intel-spi.c:	if (ispi->swseq_reg)
drivers/mtd/spi-nor/intel-spi.c:		writel(from, ispi->base + FADDR);
drivers/mtd/spi-nor/intel-spi.c:		val = readl(ispi->base + HSFSTS_CTL);
drivers/mtd/spi-nor/intel-spi.c:		writel(val, ispi->base + HSFSTS_CTL);
drivers/mtd/spi-nor/intel-spi.c:		status = readl(ispi->base + HSFSTS_CTL);
drivers/mtd/spi-nor/intel-spi.c:			dev_err(ispi->dev, "read error: %llx: %#x\n", from,
drivers/mtd/spi-nor/intel-spi.c:		writel(to, ispi->base + FADDR);
drivers/mtd/spi-nor/intel-spi.c:		val = readl(ispi->base + HSFSTS_CTL);
drivers/mtd/spi-nor/intel-spi.c:			dev_err(ispi->dev, "failed to write block\n");
drivers/mtd/spi-nor/intel-spi.c:		writel(val, ispi->base + HSFSTS_CTL);
drivers/mtd/spi-nor/intel-spi.c:			dev_err(ispi->dev, "timeout\n");
drivers/mtd/spi-nor/intel-spi.c:		status = readl(ispi->base + HSFSTS_CTL);
drivers/mtd/spi-nor/intel-spi.c:			dev_err(ispi->dev, "write error: %llx: %#x\n", to,
drivers/mtd/spi-nor/intel-spi.c:	if (len >= SZ_64K && ispi->erase_64k) {
drivers/mtd/spi-nor/intel-spi.c:	if (ispi->swseq_erase) {
drivers/mtd/spi-nor/intel-spi.c:			writel(offs, ispi->base + FADDR);
drivers/mtd/spi-nor/intel-spi.c:		writel(offs, ispi->base + FADDR);
drivers/mtd/spi-nor/intel-spi.c:		val = readl(ispi->base + HSFSTS_CTL);
drivers/mtd/spi-nor/intel-spi.c:		writel(val, ispi->base + HSFSTS_CTL);
drivers/mtd/spi-nor/intel-spi.c:		status = readl(ispi->base + HSFSTS_CTL);
drivers/mtd/spi-nor/intel-spi.c:	for (i = 0; i < ispi->pr_num; i++) {
drivers/mtd/spi-nor/intel-spi.c:		pr_value = readl(ispi->pregs + PR(i));
drivers/mtd/spi-nor/intel-spi.c:	for (i = 1; i < ispi->nregions; i++) {
drivers/mtd/spi-nor/intel-spi.c:		region = readl(ispi->base + FREG(i));
drivers/mtd/spi-nor/intel-spi.c:			ispi->writeable = false;
drivers/mtd/spi-nor/intel-spi.c:	ispi->base = devm_ioremap_resource(dev, mem);
drivers/mtd/spi-nor/intel-spi.c:	if (IS_ERR(ispi->base))
drivers/mtd/spi-nor/intel-spi.c:		return ERR_CAST(ispi->base);
drivers/mtd/spi-nor/intel-spi.c:	ispi->dev = dev;
drivers/mtd/spi-nor/intel-spi.c:	ispi->info = info;
drivers/mtd/spi-nor/intel-spi.c:	ispi->writeable = info->writeable;
drivers/mtd/spi-nor/intel-spi.c:	ispi->nor.dev = ispi->dev;
drivers/mtd/spi-nor/intel-spi.c:	ispi->nor.priv = ispi;
drivers/mtd/spi-nor/intel-spi.c:	ispi->nor.read_reg = intel_spi_read_reg;
drivers/mtd/spi-nor/intel-spi.c:	ispi->nor.write_reg = intel_spi_write_reg;
drivers/mtd/spi-nor/intel-spi.c:	ispi->nor.read = intel_spi_read;
drivers/mtd/spi-nor/intel-spi.c:	ispi->nor.write = intel_spi_write;
drivers/mtd/spi-nor/intel-spi.c:	ispi->nor.erase = intel_spi_erase;
drivers/mtd/spi-nor/intel-spi.c:	ret = spi_nor_scan(&ispi->nor, NULL, &hwcaps);
drivers/mtd/spi-nor/intel-spi.c:	if (!ispi->writeable || !writeable)
drivers/mtd/spi-nor/intel-spi.c:		ispi->nor.mtd.flags &= ~MTD_WRITEABLE;
drivers/mtd/spi-nor/intel-spi.c:	ret = mtd_device_parse_register(&ispi->nor.mtd, NULL, NULL, &part, 1);
drivers/mtd/spi-nor/intel-spi.c:	return mtd_device_unregister(&ispi->nor.mtd);
drivers/mtd/spi-nor/hisi-sfc.c:#include <linux/mtd/spi-nor.h>
drivers/mtd/spi-nor/hisi-sfc.c:	ret = of_property_read_u32(np, "spi-max-frequency",
drivers/mtd/spi-nor/hisi-sfc.c:		dev_err(dev, "There's no spi-max-frequency property for %pOF\n",
drivers/mtd/spi-nor/hisi-sfc.c:	{ .compatible = "hisilicon,fmc-spi-nor"},
drivers/mtd/spi-nor/modules.builtin:kernel/drivers/mtd/spi-nor/spi-nor.ko
drivers/mtd/spi-nor/fsl-quadspi.c:#include <linux/mtd/spi-nor.h>
drivers/mtd/spi-nor/fsl-quadspi.c:	if (of_get_property(np, "fsl,qspi-has-second-chip", NULL))
drivers/mtd/spi-nor/fsl-quadspi.c:		ret = of_property_read_u32(np, "spi-max-frequency",
drivers/mtd/spi-nor/aspeed-smc.c:#include <linux/mtd/spi-nor.h>
drivers/mtd/spi-nor/aspeed-smc.c:		if (!of_device_is_compatible(child, "jedec,spi-nor"))
drivers/mtd/spi-nor/stm32-quadspi.c:#include <linux/mtd/spi-nor.h>
drivers/mtd/spi-nor/stm32-quadspi.c:	if (readl_relaxed(qspi->io_base + QUADSPI_SR) & SR_TCF)
drivers/mtd/spi-nor/stm32-quadspi.c:	reinit_completion(&qspi->cmd_completion);
drivers/mtd/spi-nor/stm32-quadspi.c:	cr = readl_relaxed(qspi->io_base + QUADSPI_CR);
drivers/mtd/spi-nor/stm32-quadspi.c:	writel_relaxed(cr | CR_TCIE, qspi->io_base + QUADSPI_CR);
drivers/mtd/spi-nor/stm32-quadspi.c:	if (!wait_for_completion_interruptible_timeout(&qspi->cmd_completion,
drivers/mtd/spi-nor/stm32-quadspi.c:	writel_relaxed(cr, qspi->io_base + QUADSPI_CR);
drivers/mtd/spi-nor/stm32-quadspi.c:	return readl_relaxed_poll_timeout(qspi->io_base + QUADSPI_SR, sr,
drivers/mtd/spi-nor/stm32-quadspi.c:		ret = readl_relaxed_poll_timeout(qspi->io_base + QUADSPI_SR,
drivers/mtd/spi-nor/stm32-quadspi.c:			dev_err(qspi->dev, "fifo timeout (stat:%#x)\n", sr);
drivers/mtd/spi-nor/stm32-quadspi.c:		tx_fifo(buf++, qspi->io_base + QUADSPI_DR);
drivers/mtd/spi-nor/stm32-quadspi.c:	memcpy_fromio(cmd->buf, qspi->mm_base + cmd->addr, cmd->len);
drivers/mtd/spi-nor/stm32-quadspi.c:	dcr = readl_relaxed(qspi->io_base + QUADSPI_DCR) & ~DCR_FSIZE_MASK;
drivers/mtd/spi-nor/stm32-quadspi.c:	writel_relaxed(dcr, qspi->io_base + QUADSPI_DCR);
drivers/mtd/spi-nor/stm32-quadspi.c:	cr = readl_relaxed(qspi->io_base + QUADSPI_CR);
drivers/mtd/spi-nor/stm32-quadspi.c:	writel_relaxed(cr, qspi->io_base + QUADSPI_CR);
drivers/mtd/spi-nor/stm32-quadspi.c:		writel_relaxed(cmd->len - 1, qspi->io_base + QUADSPI_DLR);
drivers/mtd/spi-nor/stm32-quadspi.c:	writel_relaxed(ccr, qspi->io_base + QUADSPI_CCR);
drivers/mtd/spi-nor/stm32-quadspi.c:		writel_relaxed(cmd->addr, qspi->io_base + QUADSPI_AR);
drivers/mtd/spi-nor/stm32-quadspi.c:		writel_relaxed(FCR_CTCF, qspi->io_base + QUADSPI_FCR);
drivers/mtd/spi-nor/stm32-quadspi.c:	cr = readl_relaxed(qspi->io_base + QUADSPI_CR) | CR_ABORT;
drivers/mtd/spi-nor/stm32-quadspi.c:	writel_relaxed(cr, qspi->io_base + QUADSPI_CR);
drivers/mtd/spi-nor/stm32-quadspi.c:		dev_err(qspi->dev, "%s abort err:%d\n", __func__, err);
drivers/mtd/spi-nor/stm32-quadspi.c:	struct device *dev = flash->qspi->dev;
drivers/mtd/spi-nor/stm32-quadspi.c:	struct device *dev = flash->qspi->dev;
drivers/mtd/spi-nor/stm32-quadspi.c:	dev_dbg(qspi->dev, "read(%#.2x): buf:%p from:%#.8x len:%#zx\n",
drivers/mtd/spi-nor/stm32-quadspi.c:	struct device *dev = flash->qspi->dev;
drivers/mtd/spi-nor/stm32-quadspi.c:	struct device *dev = flash->qspi->dev;
drivers/mtd/spi-nor/stm32-quadspi.c:	cr = readl_relaxed(qspi->io_base + QUADSPI_CR);
drivers/mtd/spi-nor/stm32-quadspi.c:	sr = readl_relaxed(qspi->io_base + QUADSPI_SR);
drivers/mtd/spi-nor/stm32-quadspi.c:		complete(&qspi->cmd_completion);
drivers/mtd/spi-nor/stm32-quadspi.c:		dev_info_ratelimited(qspi->dev, "spurious interrupt\n");
drivers/mtd/spi-nor/stm32-quadspi.c:	writel_relaxed(fcr, qspi->io_base + QUADSPI_FCR);
drivers/mtd/spi-nor/stm32-quadspi.c:	mutex_lock(&qspi->lock);
drivers/mtd/spi-nor/stm32-quadspi.c:	mutex_unlock(&qspi->lock);
drivers/mtd/spi-nor/stm32-quadspi.c:	of_property_read_u32(np, "spi-max-frequency", &max_rate);
drivers/mtd/spi-nor/stm32-quadspi.c:	presc = DIV_ROUND_UP(qspi->clk_rate, max_rate) - 1;
drivers/mtd/spi-nor/stm32-quadspi.c:	if (of_property_read_u32(np, "spi-rx-bus-width", &width))
drivers/mtd/spi-nor/stm32-quadspi.c:	flash = &qspi->flash[cs_num];
drivers/mtd/spi-nor/stm32-quadspi.c:	flash->nor.dev = qspi->dev;
drivers/mtd/spi-nor/stm32-quadspi.c:	writel_relaxed(LPTR_DFT_TIMEOUT, qspi->io_base + QUADSPI_LPTR);
drivers/mtd/spi-nor/stm32-quadspi.c:		       | CR_EN, qspi->io_base + QUADSPI_CR);
drivers/mtd/spi-nor/stm32-quadspi.c:	 * if fsize is NULL, the controller can't sent spi-nor command.
drivers/mtd/spi-nor/stm32-quadspi.c:		dev_err(qspi->dev, "device scan failed\n");
drivers/mtd/spi-nor/stm32-quadspi.c:	if (mtd->size > qspi->mm_size)
drivers/mtd/spi-nor/stm32-quadspi.c:	writel_relaxed(DCR_CSHT(1), qspi->io_base + QUADSPI_DCR);
drivers/mtd/spi-nor/stm32-quadspi.c:		dev_err(qspi->dev, "mtd device parse failed\n");
drivers/mtd/spi-nor/stm32-quadspi.c:	dev_dbg(qspi->dev, "read mm:%s cs:%d bus:%d\n",
drivers/mtd/spi-nor/stm32-quadspi.c:		if (qspi->flash[i].registered)
drivers/mtd/spi-nor/stm32-quadspi.c:			mtd_device_unregister(&qspi->flash[i].nor.mtd);
drivers/mtd/spi-nor/stm32-quadspi.c:	qspi->nor_num = of_get_child_count(dev->of_node);
drivers/mtd/spi-nor/stm32-quadspi.c:	if (!qspi->nor_num || qspi->nor_num > STM32_MAX_NORCHIP)
drivers/mtd/spi-nor/stm32-quadspi.c:	qspi->io_base = devm_ioremap_resource(dev, res);
drivers/mtd/spi-nor/stm32-quadspi.c:	if (IS_ERR(qspi->io_base))
drivers/mtd/spi-nor/stm32-quadspi.c:		return PTR_ERR(qspi->io_base);
drivers/mtd/spi-nor/stm32-quadspi.c:	qspi->mm_base = devm_ioremap_resource(dev, res);
drivers/mtd/spi-nor/stm32-quadspi.c:	if (IS_ERR(qspi->mm_base))
drivers/mtd/spi-nor/stm32-quadspi.c:		return PTR_ERR(qspi->mm_base);
drivers/mtd/spi-nor/stm32-quadspi.c:	qspi->mm_size = resource_size(res);
drivers/mtd/spi-nor/stm32-quadspi.c:	init_completion(&qspi->cmd_completion);
drivers/mtd/spi-nor/stm32-quadspi.c:	qspi->clk = devm_clk_get(dev, NULL);
drivers/mtd/spi-nor/stm32-quadspi.c:	if (IS_ERR(qspi->clk))
drivers/mtd/spi-nor/stm32-quadspi.c:		return PTR_ERR(qspi->clk);
drivers/mtd/spi-nor/stm32-quadspi.c:	qspi->clk_rate = clk_get_rate(qspi->clk);
drivers/mtd/spi-nor/stm32-quadspi.c:	if (!qspi->clk_rate)
drivers/mtd/spi-nor/stm32-quadspi.c:	ret = clk_prepare_enable(qspi->clk);
drivers/mtd/spi-nor/stm32-quadspi.c:	qspi->dev = dev;
drivers/mtd/spi-nor/stm32-quadspi.c:	mutex_init(&qspi->lock);
drivers/mtd/spi-nor/stm32-quadspi.c:	mutex_destroy(&qspi->lock);
drivers/mtd/spi-nor/stm32-quadspi.c:	clk_disable_unprepare(qspi->clk);
drivers/mtd/spi-nor/stm32-quadspi.c:	writel_relaxed(0, qspi->io_base + QUADSPI_CR);
drivers/mtd/spi-nor/stm32-quadspi.c:	mutex_destroy(&qspi->lock);
drivers/mtd/spi-nor/stm32-quadspi.c:	clk_disable_unprepare(qspi->clk);
drivers/mtd/spi-nor/Kconfig:	  will be called intel-spi-pci.
drivers/mtd/spi-nor/Kconfig:	  will be called intel-spi-platform.
drivers/mtd/spi-nor/.built-in.o.cmd:cmd_drivers/mtd/spi-nor/built-in.o :=  rm -f drivers/mtd/spi-nor/built-in.o; arm-linux-gnueabi-ar rcSTPD drivers/mtd/spi-nor/built-in.o drivers/mtd/spi-nor/spi-nor.o 
drivers/mtd/spi-nor/.spi-nor.o.cmd:cmd_drivers/mtd/spi-nor/spi-nor.o := arm-linux-gnueabi-gcc -Wp,-MD,drivers/mtd/spi-nor/.spi-nor.o.d  -nostdinc -isystem /usr/lib/gcc-cross/arm-linux-gnueabi/7/include -I./arch/arm/include -I./arch/arm/include/generated  -I./include -I./arch/arm/include/uapi -I./arch/arm/include/generated/uapi -I./include/uapi -I./include/generated/uapi -include ./include/linux/kconfig.h -D__KERNEL__ -mlittle-endian -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -fshort-wchar -Werror-implicit-function-declaration -Wno-format-security -std=gnu89 -fno-PIE -fno-dwarf2-cfi-asm -fno-ipa-sra -mabi=aapcs-linux -mno-thumb-interwork -mfpu=vfp -funwind-tables -marm -Wa,-mno-warn-deprecated -D__LINUX_ARM_ARCH__=5 -march=armv5te -mtune=arm9tdmi -msoft-float -Uarm -fno-delete-null-pointer-checks -Wno-frame-address -Wno-format-truncation -Wno-format-overflow -Wno-int-in-bool-context -O2 --param=allow-store-data-races=0 -DCC_HAVE_ASM_GOTO -Wframe-larger-than=1024 -fno-stack-protector -Wno-unused-but-set-variable -Wno-unused-const-variable -fomit-frame-pointer -fno-var-tracking-assignments -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fno-stack-check -fconserve-stack -Werror=implicit-int -Werror=strict-prototypes -Werror=date-time -Werror=incompatible-pointer-types -Werror=designated-init    -DKBUILD_BASENAME='"spi_nor"'  -DKBUILD_MODNAME='"spi_nor"' -c -o drivers/mtd/spi-nor/spi-nor.o drivers/mtd/spi-nor/spi-nor.c
drivers/mtd/spi-nor/.spi-nor.o.cmd:source_drivers/mtd/spi-nor/spi-nor.o := drivers/mtd/spi-nor/spi-nor.c
drivers/mtd/spi-nor/.spi-nor.o.cmd:deps_drivers/mtd/spi-nor/spi-nor.o := \
drivers/mtd/spi-nor/.spi-nor.o.cmd:  include/linux/mtd/spi-nor.h \
drivers/mtd/spi-nor/.spi-nor.o.cmd:drivers/mtd/spi-nor/spi-nor.o: $(deps_drivers/mtd/spi-nor/spi-nor.o)
drivers/mtd/spi-nor/.spi-nor.o.cmd:$(deps_drivers/mtd/spi-nor/spi-nor.o):
drivers/mtd/spi-nor/cadence-quadspi.c:#include <linux/mtd/spi-nor.h>
drivers/mtd/spi-nor/cadence-quadspi.c:	u32 reg = readl(cqspi->iobase + CQSPI_REG_CONFIG);
drivers/mtd/spi-nor/cadence-quadspi.c:	u32 reg = readl(cqspi->iobase + CQSPI_REG_SDRAMLEVEL);
drivers/mtd/spi-nor/cadence-quadspi.c:	irq_status = readl(cqspi->iobase + CQSPI_REG_IRQSTATUS);
drivers/mtd/spi-nor/cadence-quadspi.c:	writel(irq_status, cqspi->iobase + CQSPI_REG_IRQSTATUS);
drivers/mtd/spi-nor/cadence-quadspi.c:		complete(&cqspi->transfer_complete);
drivers/mtd/spi-nor/cadence-quadspi.c:			dev_err(&cqspi->pdev->dev,
drivers/mtd/spi-nor/cadence-quadspi.c:	void __iomem *reg_base = cqspi->iobase;
drivers/mtd/spi-nor/cadence-quadspi.c:		dev_err(&cqspi->pdev->dev,
drivers/mtd/spi-nor/cadence-quadspi.c:	void __iomem *reg_base = cqspi->iobase;
drivers/mtd/spi-nor/cadence-quadspi.c:	void __iomem *reg_base = cqspi->iobase;
drivers/mtd/spi-nor/cadence-quadspi.c:	void __iomem *reg_base = cqspi->iobase;
drivers/mtd/spi-nor/cadence-quadspi.c:	void __iomem *reg_base = cqspi->iobase;
drivers/mtd/spi-nor/cadence-quadspi.c:	void __iomem *reg_base = cqspi->iobase;
drivers/mtd/spi-nor/cadence-quadspi.c:	void __iomem *ahb_base = cqspi->ahb_base;
drivers/mtd/spi-nor/cadence-quadspi.c:	reinit_completion(&cqspi->transfer_complete);
drivers/mtd/spi-nor/cadence-quadspi.c:		ret = wait_for_completion_timeout(&cqspi->transfer_complete,
drivers/mtd/spi-nor/cadence-quadspi.c:			bytes_to_read *= cqspi->fifo_width;
drivers/mtd/spi-nor/cadence-quadspi.c:			reinit_completion(&cqspi->transfer_complete);
drivers/mtd/spi-nor/cadence-quadspi.c:	void __iomem *reg_base = cqspi->iobase;
drivers/mtd/spi-nor/cadence-quadspi.c:	void __iomem *reg_base = cqspi->iobase;
drivers/mtd/spi-nor/cadence-quadspi.c:	reinit_completion(&cqspi->transfer_complete);
drivers/mtd/spi-nor/cadence-quadspi.c:	if (cqspi->wr_delay)
drivers/mtd/spi-nor/cadence-quadspi.c:		ndelay(cqspi->wr_delay);
drivers/mtd/spi-nor/cadence-quadspi.c:		iowrite32_rep(cqspi->ahb_base, txbuf,
drivers/mtd/spi-nor/cadence-quadspi.c:		ret = wait_for_completion_timeout(&cqspi->transfer_complete,
drivers/mtd/spi-nor/cadence-quadspi.c:			reinit_completion(&cqspi->transfer_complete);
drivers/mtd/spi-nor/cadence-quadspi.c:	void __iomem *reg_base = cqspi->iobase;
drivers/mtd/spi-nor/cadence-quadspi.c:	if (cqspi->is_decoded_cs) {
drivers/mtd/spi-nor/cadence-quadspi.c:	void __iomem *iobase = cqspi->iobase;
drivers/mtd/spi-nor/cadence-quadspi.c:	cqspi->current_page_size = nor->page_size;
drivers/mtd/spi-nor/cadence-quadspi.c:	cqspi->current_erase_size = nor->mtd.erasesize;
drivers/mtd/spi-nor/cadence-quadspi.c:	cqspi->current_addr_width = nor->addr_width;
drivers/mtd/spi-nor/cadence-quadspi.c:	void __iomem *iobase = cqspi->iobase;
drivers/mtd/spi-nor/cadence-quadspi.c:	const unsigned int ref_clk_hz = cqspi->master_ref_clk_hz;
drivers/mtd/spi-nor/cadence-quadspi.c:	tsclk = DIV_ROUND_UP(ref_clk_hz, cqspi->sclk);
drivers/mtd/spi-nor/cadence-quadspi.c:	const unsigned int ref_clk_hz = cqspi->master_ref_clk_hz;
drivers/mtd/spi-nor/cadence-quadspi.c:	void __iomem *reg_base = cqspi->iobase;
drivers/mtd/spi-nor/cadence-quadspi.c:	div = DIV_ROUND_UP(ref_clk_hz, 2 * cqspi->sclk) - 1;
drivers/mtd/spi-nor/cadence-quadspi.c:	void __iomem *reg_base = cqspi->iobase;
drivers/mtd/spi-nor/cadence-quadspi.c:	void __iomem *reg_base = cqspi->iobase;
drivers/mtd/spi-nor/cadence-quadspi.c:	int switch_cs = (cqspi->current_cs != f_pdata->cs);
drivers/mtd/spi-nor/cadence-quadspi.c:	int switch_ck = (cqspi->sclk != sclk);
drivers/mtd/spi-nor/cadence-quadspi.c:	if ((cqspi->current_page_size != nor->page_size) ||
drivers/mtd/spi-nor/cadence-quadspi.c:	    (cqspi->current_erase_size != nor->mtd.erasesize) ||
drivers/mtd/spi-nor/cadence-quadspi.c:	    (cqspi->current_addr_width != nor->addr_width))
drivers/mtd/spi-nor/cadence-quadspi.c:		cqspi->current_cs = f_pdata->cs;
drivers/mtd/spi-nor/cadence-quadspi.c:		cqspi->sclk = sclk;
drivers/mtd/spi-nor/cadence-quadspi.c:		cqspi_readdata_capture(cqspi, !cqspi->rclk_en,
drivers/mtd/spi-nor/cadence-quadspi.c:		memcpy_toio(cqspi->ahb_base + to, buf, len);
drivers/mtd/spi-nor/cadence-quadspi.c:		memcpy_fromio(buf, cqspi->ahb_base + from, len);
drivers/mtd/spi-nor/cadence-quadspi.c:	mutex_lock(&cqspi->bus_mutex);
drivers/mtd/spi-nor/cadence-quadspi.c:	mutex_unlock(&cqspi->bus_mutex);
drivers/mtd/spi-nor/cadence-quadspi.c:	if (of_property_read_u32(np, "spi-max-frequency", &f_pdata->clk_rate)) {
drivers/mtd/spi-nor/cadence-quadspi.c:		dev_err(&pdev->dev, "couldn't determine spi-max-frequency\n");
drivers/mtd/spi-nor/cadence-quadspi.c:	cqspi->is_decoded_cs = of_property_read_bool(np, "cdns,is-decoded-cs");
drivers/mtd/spi-nor/cadence-quadspi.c:	if (of_property_read_u32(np, "cdns,fifo-depth", &cqspi->fifo_depth)) {
drivers/mtd/spi-nor/cadence-quadspi.c:	if (of_property_read_u32(np, "cdns,fifo-width", &cqspi->fifo_width)) {
drivers/mtd/spi-nor/cadence-quadspi.c:				 &cqspi->trigger_address)) {
drivers/mtd/spi-nor/cadence-quadspi.c:	cqspi->rclk_en = of_property_read_bool(np, "cdns,rclk-en");
drivers/mtd/spi-nor/cadence-quadspi.c:	writel(0, cqspi->iobase + CQSPI_REG_REMAP);
drivers/mtd/spi-nor/cadence-quadspi.c:	writel(0, cqspi->iobase + CQSPI_REG_IRQMASK);
drivers/mtd/spi-nor/cadence-quadspi.c:	writel(cqspi->fifo_depth / 2, cqspi->iobase + CQSPI_REG_SRAMPARTITION);
drivers/mtd/spi-nor/cadence-quadspi.c:	writel(cqspi->trigger_address,
drivers/mtd/spi-nor/cadence-quadspi.c:	       cqspi->iobase + CQSPI_REG_INDIRECTTRIGGER);
drivers/mtd/spi-nor/cadence-quadspi.c:	writel(cqspi->fifo_depth * cqspi->fifo_width / 2,
drivers/mtd/spi-nor/cadence-quadspi.c:	       cqspi->iobase + CQSPI_REG_INDIRECTRDWATERMARK);
drivers/mtd/spi-nor/cadence-quadspi.c:	writel(cqspi->fifo_depth * cqspi->fifo_width / 8,
drivers/mtd/spi-nor/cadence-quadspi.c:	       cqspi->iobase + CQSPI_REG_INDIRECTWRWATERMARK);
drivers/mtd/spi-nor/cadence-quadspi.c:	reg = readl(cqspi->iobase + CQSPI_REG_CONFIG);
drivers/mtd/spi-nor/cadence-quadspi.c:	writel(reg, cqspi->iobase + CQSPI_REG_CONFIG);
drivers/mtd/spi-nor/cadence-quadspi.c:	struct platform_device *pdev = cqspi->pdev;
drivers/mtd/spi-nor/cadence-quadspi.c:		f_pdata = &cqspi->f_pdata[cs];
drivers/mtd/spi-nor/cadence-quadspi.c:		if (mtd->size <= cqspi->ahb_size) {
drivers/mtd/spi-nor/cadence-quadspi.c:		if (cqspi->f_pdata[i].registered)
drivers/mtd/spi-nor/cadence-quadspi.c:			mtd_device_unregister(&cqspi->f_pdata[i].nor.mtd);
drivers/mtd/spi-nor/cadence-quadspi.c:	mutex_init(&cqspi->bus_mutex);
drivers/mtd/spi-nor/cadence-quadspi.c:	cqspi->pdev = pdev;
drivers/mtd/spi-nor/cadence-quadspi.c:	cqspi->clk = devm_clk_get(dev, NULL);
drivers/mtd/spi-nor/cadence-quadspi.c:	if (IS_ERR(cqspi->clk)) {
drivers/mtd/spi-nor/cadence-quadspi.c:		return PTR_ERR(cqspi->clk);
drivers/mtd/spi-nor/cadence-quadspi.c:	cqspi->iobase = devm_ioremap_resource(dev, res);
drivers/mtd/spi-nor/cadence-quadspi.c:	if (IS_ERR(cqspi->iobase)) {
drivers/mtd/spi-nor/cadence-quadspi.c:		return PTR_ERR(cqspi->iobase);
drivers/mtd/spi-nor/cadence-quadspi.c:	cqspi->ahb_base = devm_ioremap_resource(dev, res_ahb);
drivers/mtd/spi-nor/cadence-quadspi.c:	if (IS_ERR(cqspi->ahb_base)) {
drivers/mtd/spi-nor/cadence-quadspi.c:		return PTR_ERR(cqspi->ahb_base);
drivers/mtd/spi-nor/cadence-quadspi.c:	cqspi->ahb_size = resource_size(res_ahb);
drivers/mtd/spi-nor/cadence-quadspi.c:	init_completion(&cqspi->transfer_complete);
drivers/mtd/spi-nor/cadence-quadspi.c:	ret = clk_prepare_enable(cqspi->clk);
drivers/mtd/spi-nor/cadence-quadspi.c:	cqspi->master_ref_clk_hz = clk_get_rate(cqspi->clk);
drivers/mtd/spi-nor/cadence-quadspi.c:		cqspi->wr_delay = 5 * DIV_ROUND_UP(NSEC_PER_SEC,
drivers/mtd/spi-nor/cadence-quadspi.c:						   cqspi->master_ref_clk_hz);
drivers/mtd/spi-nor/cadence-quadspi.c:	cqspi->current_cs = -1;
drivers/mtd/spi-nor/cadence-quadspi.c:	cqspi->sclk = 0;
drivers/mtd/spi-nor/cadence-quadspi.c:	clk_disable_unprepare(cqspi->clk);
drivers/mtd/spi-nor/cadence-quadspi.c:		if (cqspi->f_pdata[i].registered)
drivers/mtd/spi-nor/cadence-quadspi.c:			mtd_device_unregister(&cqspi->f_pdata[i].nor.mtd);
drivers/mtd/spi-nor/cadence-quadspi.c:	clk_disable_unprepare(cqspi->clk);
drivers/mtd/spi-nor/cadence-quadspi.c:		.compatible = "cdns,qspi-nor",
drivers/mtd/spi-nor/mtk-quadspi.c:#include <linux/mtd/spi-nor.h>
drivers/mtd/spi-nor/built-in.o:spi-nor.o/
drivers/mtd/spi-nor/atmel-quadspi.c: * This driver is based on drivers/mtd/spi-nor/fsl-quadspi.c from Freescale.
drivers/mtd/spi-nor/atmel-quadspi.c:#include <linux/mtd/spi-nor.h>
drivers/mtd/spi-nor/atmel-quadspi.c:	/* Setup the spi-nor */
drivers/mtd/spi-nor/atmel-quadspi.c:	err = of_property_read_u32(child, "spi-max-frequency", &aq->clk_rate);
drivers/mtd/spi-nor/Makefile:obj-$(CONFIG_MTD_SPI_NOR)	+= spi-nor.o
drivers/mtd/spi-nor/Makefile:obj-$(CONFIG_SPI_INTEL_SPI_PCI)	+= intel-spi-pci.o
drivers/mtd/spi-nor/Makefile:obj-$(CONFIG_SPI_INTEL_SPI_PLATFORM)	+= intel-spi-platform.o
drivers/mtd/devices/mtd_dataflash.c:			dev_dbg(&spi->dev, "status %d?\n", status);
drivers/mtd/devices/mtd_dataflash.c:	dev_dbg(&spi->dev, "erase addr=0x%llx len 0x%llx\n",
drivers/mtd/devices/mtd_dataflash.c:		dev_dbg(&spi->dev, "ERASE %s: (%x) %x %x %x [%i]\n",
drivers/mtd/devices/mtd_dataflash.c:			dev_err(&spi->dev, "erase %x, err %d\n",
drivers/mtd/devices/mtd_dataflash.c:	dev_dbg(&priv->spi->dev, "read 0x%x..0x%x\n",
drivers/mtd/devices/mtd_dataflash.c:	dev_dbg(&priv->spi->dev, "READ: (%x) %x %x %x\n",
drivers/mtd/devices/mtd_dataflash.c:		dev_dbg(&priv->spi->dev, "read %x..%x --> %d\n",
drivers/mtd/devices/mtd_dataflash.c:	dev_dbg(&spi->dev, "write 0x%x..0x%x\n",
drivers/mtd/devices/mtd_dataflash.c:		dev_dbg(&spi->dev, "write @ %i:%i len=%i\n",
drivers/mtd/devices/mtd_dataflash.c:			dev_dbg(&spi->dev, "TRANSFER: (%x) %x %x %x\n",
drivers/mtd/devices/mtd_dataflash.c:				dev_dbg(&spi->dev, "xfer %u -> %d\n",
drivers/mtd/devices/mtd_dataflash.c:		dev_dbg(&spi->dev, "PROGRAM: (%x) %x %x %x\n",
drivers/mtd/devices/mtd_dataflash.c:			dev_dbg(&spi->dev, "pgm %u/%u -> %d\n",
drivers/mtd/devices/mtd_dataflash.c:		dev_dbg(&spi->dev, "COMPARE: (%x) %x %x %x\n",
drivers/mtd/devices/mtd_dataflash.c:			dev_dbg(&spi->dev, "compare %u -> %d\n",
drivers/mtd/devices/mtd_dataflash.c:			dev_err(&spi->dev, "compare page %u, err %d\n",
drivers/mtd/devices/mtd_dataflash.c:	struct flash_platform_data	*pdata = dev_get_platdata(&spi->dev);
drivers/mtd/devices/mtd_dataflash.c:			spi->master->bus_num, spi->chip_select,
drivers/mtd/devices/mtd_dataflash.c:	device->dev.parent = &spi->dev;
drivers/mtd/devices/mtd_dataflash.c:	mtd_set_of_node(device, spi->dev.of_node);
drivers/mtd/devices/mtd_dataflash.c:	dev_info(&spi->dev, "%s (%lld KBytes) pagesize %d bytes%s\n",
drivers/mtd/devices/mtd_dataflash.c:			dev_dbg(&spi->dev, "OTP, sector protect%s\n",
drivers/mtd/devices/mtd_dataflash.c:					dev_dbg(&spi->dev, "status error %d\n",
drivers/mtd/devices/mtd_dataflash.c:		dev_dbg(&spi->dev, "error %d reading JEDEC ID\n", ret);
drivers/mtd/devices/mtd_dataflash.c:	dev_warn(&spi->dev, "JEDEC id %016llx not handled\n", jedec);
drivers/mtd/devices/mtd_dataflash.c:		dev_dbg(&spi->dev, "status error %d\n", status);
drivers/mtd/devices/mtd_dataflash.c:	 * board setup should have set spi->max_speed_max to
drivers/mtd/devices/mtd_dataflash.c:		dev_info(&spi->dev, "unsupported device (%x)\n",
drivers/mtd/devices/mtd_dataflash.c:		dev_dbg(&spi->dev, "add_dataflash --> %d\n", status);
drivers/mtd/devices/mtd_dataflash.c:	dev_dbg(&spi->dev, "remove\n");
Binary file drivers/mtd/devices/m25p80.o matches
drivers/mtd/devices/m25p80.c:#include <linux/mtd/spi-nor.h>
drivers/mtd/devices/m25p80.c:		dev_err(&spi->dev, "error %d reading %x\n", ret, code);
drivers/mtd/devices/m25p80.c:	data = dev_get_platdata(&spi->dev);
drivers/mtd/devices/m25p80.c:	flash = devm_kzalloc(&spi->dev, sizeof(*flash), GFP_KERNEL);
drivers/mtd/devices/m25p80.c:	nor->dev = &spi->dev;
drivers/mtd/devices/m25p80.c:	spi_nor_set_flash_node(nor, spi->dev.of_node);
drivers/mtd/devices/m25p80.c:	if (spi->mode & SPI_RX_QUAD) {
drivers/mtd/devices/m25p80.c:		if (spi->mode & SPI_TX_QUAD)
drivers/mtd/devices/m25p80.c:	} else if (spi->mode & SPI_RX_DUAL) {
drivers/mtd/devices/m25p80.c:		if (spi->mode & SPI_TX_DUAL)
drivers/mtd/devices/m25p80.c:	else if (!strcmp(spi->modalias, "spi-nor"))
drivers/mtd/devices/m25p80.c:		flash_name = spi->modalias;
drivers/mtd/devices/m25p80.c:	dev_err(&spi->dev, "SPI FLASH Probe task finished\n");
drivers/mtd/devices/m25p80.c: * encourage new users to add support to the spi-nor library, and simply bind
drivers/mtd/devices/m25p80.c: * against a generic string here (e.g., "jedec,spi-nor").
drivers/mtd/devices/m25p80.c: * Many flash names are kept here in this list (as well as in spi-nor.c) to
drivers/mtd/devices/m25p80.c:	 * Allow non-DT platform devices to bind to the "spi-nor" modalias, and
drivers/mtd/devices/m25p80.c:	{"spi-nor"},
drivers/mtd/devices/m25p80.c:	 * them with "spi-nor" in platform data.
drivers/mtd/devices/m25p80.c:	 * Entries that were used in DTs without "jedec,spi-nor" fallback and
drivers/mtd/devices/m25p80.c:	{ .compatible = "jedec,spi-nor" },
drivers/mtd/devices/.m25p80.o.cmd:  include/linux/mtd/spi-nor.h \
drivers/mtd/devices/sst25l.c:			dev_err(&flash->spi->dev, "Erase failed\n");
drivers/mtd/devices/sst25l.c:		dev_err(&spi->dev, "error reading device id\n");
drivers/mtd/devices/sst25l.c:		dev_err(&spi->dev, "unknown id %.4x\n", id);
drivers/mtd/devices/sst25l.c:	flash = devm_kzalloc(&spi->dev, sizeof(*flash), GFP_KERNEL);
drivers/mtd/devices/sst25l.c:	data = dev_get_platdata(&spi->dev);
drivers/mtd/devices/sst25l.c:	flash->mtd.dev.parent   = &spi->dev;
drivers/mtd/devices/sst25l.c:	dev_info(&spi->dev, "%s (%lld KiB)\n", flash_info->name,
drivers/mtd/devices/mchp23k256.c:	flash = devm_kzalloc(&spi->dev, sizeof(*flash), GFP_KERNEL);
drivers/mtd/devices/mchp23k256.c:	data = dev_get_platdata(&spi->dev);
drivers/mtd/devices/mchp23k256.c:	flash->caps = of_device_get_match_data(&spi->dev);
drivers/mtd/devices/mchp23k256.c:	mtd_set_of_node(&flash->mtd, spi->dev.of_node);
drivers/mtd/devices/mchp23k256.c:	flash->mtd.dev.parent	= &spi->dev;
drivers/mtd/devices/st_spi_fsm.c:#include <linux/mtd/spi-nor.h>
drivers/mtd/devices/st_spi_fsm.c:	{ .compatible = "st,spi-fsm", },
drivers/mtd/devices/st_spi_fsm.c:		.name	= "st-spi-fsm",
drivers/mtd/Kconfig:source "drivers/mtd/spi-nor/Kconfig"
drivers/mtd/.built-in.o.cmd:cmd_drivers/mtd/built-in.o :=  rm -f drivers/mtd/built-in.o; arm-linux-gnueabi-ar rcSTPD drivers/mtd/built-in.o drivers/mtd/mtd.o drivers/mtd/ofpart.o drivers/mtd/parsers/built-in.o drivers/mtd/mtd_blkdevs.o drivers/mtd/mtdblock.o drivers/mtd/chips/built-in.o drivers/mtd/lpddr/built-in.o drivers/mtd/maps/built-in.o drivers/mtd/devices/built-in.o drivers/mtd/nand/built-in.o drivers/mtd/onenand/built-in.o drivers/mtd/tests/built-in.o drivers/mtd/spi-nor/built-in.o 
drivers/mtd/built-in.o:spi-nor/spi-nor.o/
drivers/mtd/Makefile:obj-$(CONFIG_MTD_SPI_NOR)	+= spi-nor/
drivers/net/ethernet/sfc/falcon/falcon.c:			     FRF_AB_EE_SPI_HCMD_SF_SEL, spi->device_id,
drivers/net/ethernet/sfc/falcon/falcon.c:			     (addressed ? spi->addr_len : 0),
drivers/net/ethernet/sfc/falcon/falcon.c:	return command | (((address >> 8) & spi->munge_address) << 3);
drivers/net/ethernet/sfc/falcon/falcon.c:		   (spi->block_size - (start & (spi->block_size - 1))));
drivers/net/ethernet/sfc/falcon/falcon.c:				  spi->device_id, status);
drivers/net/ethernet/sfc/falcon/falcon.c:	if (len != spi->erase_size)
drivers/net/ethernet/sfc/falcon/falcon.c:	if (spi->erase_command == 0)
drivers/net/ethernet/sfc/falcon/falcon.c:	rc = falcon_spi_cmd(efx, spi, spi->erase_command, start, NULL,
drivers/net/ethernet/sfc/falcon/falcon.c:	if (falcon_spi_present(spi) && spi->size > FALCON_FLASH_BOOTCODE_START) {
drivers/net/ethernet/sfc/falcon/falcon.c:		parts[n_parts].common.mtd.size = spi->size - FALCON_FLASH_BOOTCODE_START;
drivers/net/ethernet/sfc/falcon/falcon.c:		parts[n_parts].common.mtd.erasesize = spi->erase_size;
drivers/net/ethernet/sfc/falcon/falcon.c:	if (falcon_spi_present(spi) && spi->size > FALCON_EEPROM_BOOTCONFIG_START) {
drivers/net/ethernet/sfc/falcon/falcon.c:			min(spi->size, FALCON_EEPROM_BOOTCONFIG_END) -
drivers/net/ethernet/sfc/falcon/falcon.c:		parts[n_parts].common.mtd.erasesize = spi->erase_size;
drivers/net/ethernet/sfc/falcon/nic.h:	return spi->size != 0;
drivers/net/ethernet/chelsio/cxgb/espi.c:	u32 enable, pl_intr = readl(espi->adapter->regs + A_PL_ENABLE);
drivers/net/ethernet/chelsio/cxgb/espi.c:	enable = t1_is_T1B(espi->adapter) ? 0 : ESPI_INTR_MASK;
drivers/net/ethernet/chelsio/cxgb/espi.c:	writel(enable, espi->adapter->regs + A_ESPI_INTR_ENABLE);
drivers/net/ethernet/chelsio/cxgb/espi.c:	writel(pl_intr | F_PL_INTR_ESPI, espi->adapter->regs + A_PL_ENABLE);
drivers/net/ethernet/chelsio/cxgb/espi.c:	readl(espi->adapter->regs + A_ESPI_DIP2_ERR_COUNT);
drivers/net/ethernet/chelsio/cxgb/espi.c:	writel(0xffffffff, espi->adapter->regs + A_ESPI_INTR_STATUS);
drivers/net/ethernet/chelsio/cxgb/espi.c:	writel(F_PL_INTR_ESPI, espi->adapter->regs + A_PL_CAUSE);
drivers/net/ethernet/chelsio/cxgb/espi.c:	u32 pl_intr = readl(espi->adapter->regs + A_PL_ENABLE);
drivers/net/ethernet/chelsio/cxgb/espi.c:	writel(0, espi->adapter->regs + A_ESPI_INTR_ENABLE);
drivers/net/ethernet/chelsio/cxgb/espi.c:	writel(pl_intr & ~F_PL_INTR_ESPI, espi->adapter->regs + A_PL_ENABLE);
drivers/net/ethernet/chelsio/cxgb/espi.c:	u32 status = readl(espi->adapter->regs + A_ESPI_INTR_STATUS);
drivers/net/ethernet/chelsio/cxgb/espi.c:		espi->intr_cnt.DIP4_err++;
drivers/net/ethernet/chelsio/cxgb/espi.c:		espi->intr_cnt.rx_drops++;
drivers/net/ethernet/chelsio/cxgb/espi.c:		espi->intr_cnt.tx_drops++;
drivers/net/ethernet/chelsio/cxgb/espi.c:		espi->intr_cnt.rx_ovflw++;
drivers/net/ethernet/chelsio/cxgb/espi.c:		espi->intr_cnt.parity_err++;
drivers/net/ethernet/chelsio/cxgb/espi.c:		espi->intr_cnt.DIP2_parity_err++;
drivers/net/ethernet/chelsio/cxgb/espi.c:		readl(espi->adapter->regs + A_ESPI_DIP2_ERR_COUNT);
drivers/net/ethernet/chelsio/cxgb/espi.c:	if (status && t1_is_T1B(espi->adapter))
drivers/net/ethernet/chelsio/cxgb/espi.c:	writel(status, espi->adapter->regs + A_ESPI_INTR_STATUS);
drivers/net/ethernet/chelsio/cxgb/espi.c:	return &espi->intr_cnt;
drivers/net/ethernet/chelsio/cxgb/espi.c:	adapter_t *adapter = espi->adapter;
drivers/net/ethernet/chelsio/cxgb/espi.c:		espi->misc_ctrl = readl(adapter->regs + A_ESPI_MISC_CONTROL);
drivers/net/ethernet/chelsio/cxgb/espi.c:		espi->misc_ctrl &= ~MON_MASK;
drivers/net/ethernet/chelsio/cxgb/espi.c:		espi->misc_ctrl |= F_MONITORED_DIRECTION;
drivers/net/ethernet/chelsio/cxgb/espi.c:			espi->misc_ctrl |= F_MONITORED_INTERFACE;
drivers/net/ethernet/chelsio/cxgb/espi.c:		writel(espi->misc_ctrl, adapter->regs + A_ESPI_MISC_CONTROL);
drivers/net/ethernet/chelsio/cxgb/espi.c:		spin_lock_init(&espi->lock);
drivers/net/ethernet/chelsio/cxgb/espi.c:		espi->adapter = adapter;
drivers/net/ethernet/chelsio/cxgb/espi.c:	spin_lock(&espi->lock);
drivers/net/ethernet/chelsio/cxgb/espi.c:	espi->misc_ctrl = (val & ~MON_MASK) |
drivers/net/ethernet/chelsio/cxgb/espi.c:			  (espi->misc_ctrl & MON_MASK);
drivers/net/ethernet/chelsio/cxgb/espi.c:	writel(espi->misc_ctrl, adapter->regs + A_ESPI_MISC_CONTROL);
drivers/net/ethernet/chelsio/cxgb/espi.c:	spin_unlock(&espi->lock);
drivers/net/ethernet/chelsio/cxgb/espi.c:		if (!spin_trylock(&espi->lock))
drivers/net/ethernet/chelsio/cxgb/espi.c:		spin_lock(&espi->lock);
drivers/net/ethernet/chelsio/cxgb/espi.c:	if ((sel != (espi->misc_ctrl & MON_MASK))) {
drivers/net/ethernet/chelsio/cxgb/espi.c:		writel(((espi->misc_ctrl & ~MON_MASK) | sel),
drivers/net/ethernet/chelsio/cxgb/espi.c:		writel(espi->misc_ctrl, adapter->regs + A_ESPI_MISC_CONTROL);
drivers/net/ethernet/chelsio/cxgb/espi.c:	spin_unlock(&espi->lock);
drivers/net/ethernet/chelsio/cxgb/espi.c:		if (!spin_trylock(&espi->lock))
drivers/net/ethernet/chelsio/cxgb/espi.c:		spin_lock(&espi->lock);
drivers/net/ethernet/chelsio/cxgb/espi.c:	if ((espi->misc_ctrl & MON_MASK) != F_MONITORED_DIRECTION) {
drivers/net/ethernet/chelsio/cxgb/espi.c:		espi->misc_ctrl = (espi->misc_ctrl & ~MON_MASK) |
drivers/net/ethernet/chelsio/cxgb/espi.c:		writel(espi->misc_ctrl, adapter->regs + A_ESPI_MISC_CONTROL);
drivers/net/ethernet/chelsio/cxgb/espi.c:			writel(espi->misc_ctrl | V_MONITORED_PORT_NUM(i),
drivers/net/ethernet/chelsio/cxgb/espi.c:	writel(espi->misc_ctrl, adapter->regs + A_ESPI_MISC_CONTROL);
drivers/net/ethernet/chelsio/cxgb/espi.c:	spin_unlock(&espi->lock);
drivers/net/ethernet/netronome/nfp/nfp_hwmon.c:	if (!(pf->nspi->sensor_mask & BIT(id)))
drivers/net/ethernet/netronome/nfp/nfp_hwmon.c:	if (!pf->nspi->sensor_mask) {
drivers/net/ethernet/netronome/nfp/nfp_main.c:		dev_info(&pdev->dev, "BSP: %s\n", pf->nspi->version);
drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_cmds.c:	memcpy(nspi->version, ni->version, sizeof(nspi->version));
drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_cmds.c:	nspi->version[sizeof(nspi->version) - 1] = '\0';
drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_cmds.c:	nspi->flags = ni->flags;
drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_cmds.c:	nspi->br_primary = ni->br_primary;
drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_cmds.c:	nspi->br_secondary = ni->br_secondary;
drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_cmds.c:	nspi->br_nsp = ni->br_nsp;
drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_cmds.c:	nspi->primary = le16_to_cpu(ni->primary);
drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_cmds.c:	nspi->secondary = le16_to_cpu(ni->secondary);
drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_cmds.c:	nspi->nsp = le16_to_cpu(ni->nsp);
drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp_cmds.c:	nspi->sensor_mask = le64_to_cpu(ni->sensor_mask);
drivers/net/ethernet/wiznet/w5100-spi.c:	const void *mac = of_get_mac_address(spi->dev.of_node);
drivers/net/ethernet/wiznet/w5100-spi.c:	return w5100_probe(&spi->dev, ops, priv_size, mac, spi->irq, -EINVAL);
drivers/net/ethernet/wiznet/w5100-spi.c:	return w5100_remove(&spi->dev);
drivers/net/ethernet/micrel/ks8851.c:	spi->bits_per_word = 8;
drivers/net/ethernet/micrel/ks8851.c:	gpio = of_get_named_gpio_flags(spi->dev.of_node, "reset-gpios",
drivers/net/ethernet/micrel/ks8851.c:		ret = devm_gpio_request_one(&spi->dev, gpio,
drivers/net/ethernet/micrel/ks8851.c:			dev_err(&spi->dev, "reset gpio request failed\n");
drivers/net/ethernet/micrel/ks8851.c:	ks->vdd_io = devm_regulator_get(&spi->dev, "vdd-io");
drivers/net/ethernet/micrel/ks8851.c:		dev_err(&spi->dev, "regulator vdd_io enable fail: %d\n",
drivers/net/ethernet/micrel/ks8851.c:	ks->vdd_reg = devm_regulator_get(&spi->dev, "vdd");
drivers/net/ethernet/micrel/ks8851.c:		dev_err(&spi->dev, "regulator vdd enable fail: %d\n",
drivers/net/ethernet/micrel/ks8851.c:	dev_info(&spi->dev, "message enable is %d\n", msg_enable);
drivers/net/ethernet/micrel/ks8851.c:	SET_NETDEV_DEV(ndev, &spi->dev);
drivers/net/ethernet/micrel/ks8851.c:	ndev->irq = spi->irq;
drivers/net/ethernet/micrel/ks8851.c:		dev_err(&spi->dev, "failed to read device ID\n");
drivers/net/ethernet/micrel/ks8851.c:	ret = request_threaded_irq(spi->irq, NULL, ks8851_irq,
drivers/net/ethernet/micrel/ks8851.c:		dev_err(&spi->dev, "failed to get irq\n");
drivers/net/ethernet/micrel/ks8851.c:		dev_err(&spi->dev, "failed to register network device\n");
drivers/net/ethernet/micrel/ks8851.c:		dev_info(&spi->dev, "remove\n");
drivers/net/ethernet/micrel/ks8851.c:	free_irq(spi->irq, priv);
drivers/net/ethernet/qualcomm/Makefile:qcaspi-objs := qca_7k.o qca_debug.o qca_spi.o
drivers/net/ethernet/qualcomm/qca_spi.c:	if (!spi->dev.of_node) {
drivers/net/ethernet/qualcomm/qca_spi.c:		dev_err(&spi->dev, "Missing device tree\n");
drivers/net/ethernet/qualcomm/qca_spi.c:	legacy_mode = of_property_read_bool(spi->dev.of_node,
drivers/net/ethernet/qualcomm/qca_spi.c:		if (spi->max_speed_hz)
drivers/net/ethernet/qualcomm/qca_spi.c:			qcaspi_clkspeed = spi->max_speed_hz;
drivers/net/ethernet/qualcomm/qca_spi.c:		dev_info(&spi->dev, "Invalid clkspeed: %d\n",
drivers/net/ethernet/qualcomm/qca_spi.c:		dev_info(&spi->dev, "Invalid burst len: %d\n",
drivers/net/ethernet/qualcomm/qca_spi.c:		dev_info(&spi->dev, "Invalid pluggable: %d\n",
drivers/net/ethernet/qualcomm/qca_spi.c:	dev_info(&spi->dev, "ver=%s, clkspeed=%d, burst_len=%d, pluggable=%d\n",
drivers/net/ethernet/qualcomm/qca_spi.c:	spi->mode = SPI_MODE_3;
drivers/net/ethernet/qualcomm/qca_spi.c:	spi->max_speed_hz = qcaspi_clkspeed;
drivers/net/ethernet/qualcomm/qca_spi.c:		dev_err(&spi->dev, "Unable to setup SPI device\n");
drivers/net/ethernet/qualcomm/qca_spi.c:	SET_NETDEV_DEV(qcaspi_devs, &spi->dev);
drivers/net/ethernet/qualcomm/qca_spi.c:		dev_err(&spi->dev, "Fail to retrieve private structure\n");
drivers/net/ethernet/qualcomm/qca_spi.c:	mac = of_get_mac_address(spi->dev.of_node);
drivers/net/ethernet/qualcomm/qca_spi.c:		dev_info(&spi->dev, "Using random MAC address: %pM\n",
drivers/net/ethernet/qualcomm/qca_spi.c:			dev_err(&spi->dev, "Invalid signature (0x%04X)\n",
drivers/net/ethernet/qualcomm/qca_spi.c:		dev_info(&spi->dev, "Unable to register net device %s\n",
drivers/net/ethernet/microchip/encx24j600.c:	int ret = request_threaded_irq(priv->ctx.spi->irq, NULL, encx24j600_isr,
drivers/net/ethernet/microchip/encx24j600.c:			   priv->ctx.spi->irq, ret);
drivers/net/ethernet/microchip/encx24j600.c:	free_irq(priv->ctx.spi->irq, priv);
drivers/net/ethernet/microchip/encx24j600.c:	dev_set_drvdata(&spi->dev, priv);
drivers/net/ethernet/microchip/encx24j600.c:	SET_NETDEV_DEV(ndev, &spi->dev);
drivers/net/ethernet/microchip/encx24j600.c:	devm_regmap_init_encx24j600(&spi->dev, &priv->ctx);
drivers/net/ethernet/microchip/encx24j600.c:	ndev->irq = spi->irq;
drivers/net/ethernet/microchip/encx24j600.c:	struct encx24j600_priv *priv = dev_get_drvdata(&spi->dev);
drivers/net/ethernet/microchip/enc28j60.c:				dev_dbg(&priv->spi->dev,
drivers/net/ethernet/microchip/enc28j60.c:		dev_dbg(&priv->spi->dev, "%s power...\n",
drivers/net/ethernet/microchip/enc28j60.c:		dev_info(&spi->dev, DRV_NAME " Ethernet driver %s loaded\n",
drivers/net/ethernet/microchip/enc28j60.c:	SET_NETDEV_DEV(dev, &spi->dev);
drivers/net/ethernet/microchip/enc28j60.c:			dev_info(&spi->dev, DRV_NAME " chip not found\n");
drivers/net/ethernet/microchip/enc28j60.c:	macaddr = of_get_mac_address(spi->dev.of_node);
drivers/net/ethernet/microchip/enc28j60.c:	ret = request_irq(spi->irq, enc28j60_irq, 0, DRV_NAME, priv);
drivers/net/ethernet/microchip/enc28j60.c:			dev_err(&spi->dev, DRV_NAME ": request irq %d failed "
drivers/net/ethernet/microchip/enc28j60.c:				"(ret = %d)\n", spi->irq, ret);
drivers/net/ethernet/microchip/enc28j60.c:	dev->irq = spi->irq;
drivers/net/ethernet/microchip/enc28j60.c:			dev_err(&spi->dev, "register netdev " DRV_NAME
drivers/net/ethernet/microchip/enc28j60.c:	free_irq(spi->irq, priv);
drivers/net/ethernet/microchip/enc28j60.c:	free_irq(spi->irq, priv);
drivers/net/ieee802154/adf7242.c:			dev_warn(&lp->spi->dev,
drivers/net/ieee802154/adf7242.c:	dev_vdbg(&lp->spi->dev, "%s : loops=%d line %d\n", __func__, cnt, line);
drivers/net/ieee802154/adf7242.c:	dev_vdbg(&lp->spi->dev, "%s : REG 0x%X, VAL 0x%X\n", __func__,
drivers/net/ieee802154/adf7242.c:	dev_vdbg(&lp->spi->dev, "%s : REG 0x%X, VAL 0x%X\n",
drivers/net/ieee802154/adf7242.c:	dev_vdbg(&lp->spi->dev, "%s : CMD=0x%X\n", __func__, cmd);
drivers/net/ieee802154/adf7242.c:	dev_vdbg(&lp->spi->dev, "%s : Power %d dB\n", __func__, db);
drivers/net/ieee802154/adf7242.c:	dev_vdbg(&lp->spi->dev, "%s : min_be=%d max_be=%d retries=%d\n",
drivers/net/ieee802154/adf7242.c:	dev_vdbg(&lp->spi->dev, "%s : Retries = %d\n", __func__, retries);
drivers/net/ieee802154/adf7242.c:	dev_vdbg(&lp->spi->dev, "%s :Exit level=%d\n",
drivers/net/ieee802154/adf7242.c:	enable_irq(lp->spi->irq);
drivers/net/ieee802154/adf7242.c:	disable_irq(lp->spi->irq);
drivers/net/ieee802154/adf7242.c:	dev_dbg(&lp->spi->dev, "%s :Channel=%d\n", __func__, channel);
drivers/net/ieee802154/adf7242.c:	dev_dbg(&lp->spi->dev, "%s :Changed=0x%lX\n", __func__, changed);
drivers/net/ieee802154/adf7242.c:	dev_dbg(&lp->spi->dev, "%s : mode %d\n", __func__, on);
drivers/net/ieee802154/adf7242.c:	dev_dbg(&lp->spi->dev, "%s : level %d\n", __func__, level);
drivers/net/ieee802154/adf7242.c:	disable_irq(lp->spi->irq);
drivers/net/ieee802154/adf7242.c:	enable_irq(lp->spi->irq);
drivers/net/ieee802154/adf7242.c:		dev_dbg(&lp->spi->dev, "Timeout waiting for TX interrupt\n");
drivers/net/ieee802154/adf7242.c:		dev_dbg(&lp->spi->dev,
drivers/net/ieee802154/adf7242.c:		dev_dbg(&lp->spi->dev,
drivers/net/ieee802154/adf7242.c:	dev_dbg(&lp->spi->dev, "%s: ret=%d len=%d lqi=%d rssi=%d\n",
drivers/net/ieee802154/adf7242.c:	dev_dbg(&lp->spi->dev, "%s IRQ1 = %X:\n%s%s%s%s%s%s%s%s\n",
drivers/net/ieee802154/adf7242.c:	dev_dbg(&lp->spi->dev, "%s STATUS = %X:\n%s\n%s\n%s\n%s\n%s%s%s%s%s\n",
drivers/net/ieee802154/adf7242.c:		dev_err(&lp->spi->dev, "%s :ERROR IRQ1 = 0x%X\n",
drivers/net/ieee802154/adf7242.c:			dev_dbg(&lp->spi->dev, "AUTO_STATUS = %X:\n%s%s%s%s\n",
drivers/net/ieee802154/adf7242.c:		dev_dbg(&lp->spi->dev, "%s:%d : ERROR IRQ1 = 0x%X\n",
drivers/net/ieee802154/adf7242.c:		dev_dbg(&lp->spi->dev, "%s:%d : ERROR IRQ1 = 0x%X, xmit %d\n",
drivers/net/ieee802154/adf7242.c:	dev_warn(&lp->spi->dev, "%s (line %d)\n", __func__, line);
drivers/net/ieee802154/adf7242.c:		disable_irq_nosync(lp->spi->irq);
drivers/net/ieee802154/adf7242.c:		enable_irq(lp->spi->irq);
drivers/net/ieee802154/adf7242.c:	ret = request_firmware(&fw, FIRMWARE, &lp->spi->dev);
drivers/net/ieee802154/adf7242.c:		dev_err(&lp->spi->dev,
drivers/net/ieee802154/adf7242.c:		dev_err(&lp->spi->dev,
drivers/net/ieee802154/adf7242.c:		dev_err(&lp->spi->dev,
drivers/net/ieee802154/adf7242.c:	strncat(debugfs_dir_name, dev_name(&lp->spi->dev), DNAME_INLINE_LEN);
drivers/net/ieee802154/adf7242.c:	stats = debugfs_create_devm_seqfile(&lp->spi->dev, "status",
drivers/net/ieee802154/adf7242.c:	if (!spi->irq) {
drivers/net/ieee802154/adf7242.c:		dev_err(&spi->dev, "no IRQ specified\n");
drivers/net/ieee802154/adf7242.c:	hw->parent = &spi->dev;
drivers/net/ieee802154/adf7242.c:	irq_type = irq_get_trigger_type(spi->irq);
drivers/net/ieee802154/adf7242.c:	ret = devm_request_threaded_irq(&spi->dev, spi->irq, NULL, adf7242_isr,
drivers/net/ieee802154/adf7242.c:					dev_name(&spi->dev), lp);
drivers/net/ieee802154/adf7242.c:	disable_irq(spi->irq);
drivers/net/ieee802154/adf7242.c:	dev_set_drvdata(&spi->dev, lp);
drivers/net/ieee802154/adf7242.c:	dev_info(&spi->dev, "mac802154 IRQ-%d registered\n", spi->irq);
drivers/net/ieee802154/mrf24j40.c:#define printdev(X) (&X->spi->dev)
drivers/net/ieee802154/mrf24j40.c:	enable_irq(devrec->spi->irq);
drivers/net/ieee802154/mrf24j40.c:	irq_type = irq_get_trigger_type(devrec->spi->irq);
drivers/net/ieee802154/mrf24j40.c:		dev_warn(&devrec->spi->dev,
drivers/net/ieee802154/mrf24j40.c:	dev_info(&spi->dev, "probe(). IRQ: %d\n", spi->irq);
drivers/net/ieee802154/mrf24j40.c:	devrec->hw->parent = &spi->dev;
drivers/net/ieee802154/mrf24j40.c:		dev_err(&spi->dev, "Failed to allocate short register map: %d\n",
drivers/net/ieee802154/mrf24j40.c:	devrec->regmap_long = devm_regmap_init(&spi->dev,
drivers/net/ieee802154/mrf24j40.c:		dev_err(&spi->dev, "Failed to allocate long register map: %d\n",
drivers/net/ieee802154/mrf24j40.c:	if (spi->max_speed_hz > MAX_SPI_SPEED_HZ) {
drivers/net/ieee802154/mrf24j40.c:		dev_warn(&spi->dev, "spi clock above possible maximum: %d",
drivers/net/ieee802154/mrf24j40.c:	irq_type = irq_get_trigger_type(spi->irq);
drivers/net/ieee802154/mrf24j40.c:	ret = devm_request_irq(&spi->dev, spi->irq, mrf24j40_isr,
drivers/net/ieee802154/mrf24j40.c:			       irq_type, dev_name(&spi->dev), devrec);
drivers/net/ieee802154/cc2520.c:	dev_vdbg(&priv->spi->dev,
drivers/net/ieee802154/cc2520.c:	dev_vdbg(&priv->spi->dev,
drivers/net/ieee802154/cc2520.c:	dev_vdbg(&priv->spi->dev,
drivers/net/ieee802154/cc2520.c:	dev_vdbg(&priv->spi->dev,
drivers/net/ieee802154/cc2520.c:	dev_dbg(&priv->spi->dev, "spi status = %d\n", status);
drivers/net/ieee802154/cc2520.c:	dev_dbg(&priv->spi->dev,
drivers/net/ieee802154/cc2520.c:	dev_vdbg(&priv->spi->dev,
drivers/net/ieee802154/cc2520.c:	dev_vdbg(&priv->spi->dev, "status = %d\n", status);
drivers/net/ieee802154/cc2520.c:	dev_vdbg(&priv->spi->dev, "status = %d\n", status);
drivers/net/ieee802154/cc2520.c:	dev_vdbg(&priv->spi->dev, "buf[0] = %02x\n", priv->buf[0]);
drivers/net/ieee802154/cc2520.c:	dev_vdbg(&priv->spi->dev, "read rxfifo buf[0] = %02x\n", priv->buf[0]);
drivers/net/ieee802154/cc2520.c:	dev_vdbg(&priv->spi->dev, "buf[1] = %02x\n", priv->buf[1]);
drivers/net/ieee802154/cc2520.c:	dev_vdbg(&priv->spi->dev, "status = %d\n", status);
drivers/net/ieee802154/cc2520.c:	dev_vdbg(&priv->spi->dev, "status = %d\n", status);
drivers/net/ieee802154/cc2520.c:	dev_vdbg(&priv->spi->dev,
drivers/net/ieee802154/cc2520.c:	dev_vdbg(&priv->spi->dev, "length buf[1] = %02x\n", priv->buf[1]);
drivers/net/ieee802154/cc2520.c:		dev_err(&priv->spi->dev, "cc2520 tx underflow exception\n");
drivers/net/ieee802154/cc2520.c:		dev_dbg(&priv->spi->dev, "corrupted frame received\n");
drivers/net/ieee802154/cc2520.c:		dev_dbg(&priv->spi->dev, "frame reception failed\n");
drivers/net/ieee802154/cc2520.c:			dev_dbg(&priv->spi->dev, "CRC check failed\n");
drivers/net/ieee802154/cc2520.c:	dev_vdbg(&priv->spi->dev, "RXFIFO: %x %x\n", len, lqi);
drivers/net/ieee802154/cc2520.c:	dev_dbg(&priv->spi->dev, "trying to set channel\n");
drivers/net/ieee802154/cc2520.c:		dev_vdbg(&priv->spi->dev, "%s called for pan id\n", __func__);
drivers/net/ieee802154/cc2520.c:		dev_vdbg(&priv->spi->dev,
drivers/net/ieee802154/cc2520.c:		dev_vdbg(&priv->spi->dev, "%s called for saddr\n", __func__);
drivers/net/ieee802154/cc2520.c:		dev_vdbg(&priv->spi->dev,
drivers/net/ieee802154/cc2520.c:	dev_dbg(&priv->spi->dev, "%s : mode %d\n", __func__, on);
drivers/net/ieee802154/cc2520.c:	priv->hw->parent = &priv->spi->dev;
drivers/net/ieee802154/cc2520.c:	dev_vdbg(&priv->spi->dev, "registered cc2520\n");
drivers/net/ieee802154/cc2520.c:	dev_dbg(&priv->spi->dev, "fifop interrupt received\n");
drivers/net/ieee802154/cc2520.c:		dev_dbg(&priv->spi->dev, "rxfifo overflow\n");
drivers/net/ieee802154/cc2520.c:		dev_dbg(&priv->spi->dev, "SFD for TX\n");
drivers/net/ieee802154/cc2520.c:		dev_dbg(&priv->spi->dev, "SFD for RX\n");
drivers/net/ieee802154/cc2520.c:	struct device_node *np = spi->dev.of_node;
drivers/net/ieee802154/cc2520.c:		struct cc2520_platform_data *spi_pdata = spi->dev.platform_data;
drivers/net/ieee802154/cc2520.c:			dev_err(&priv->spi->dev, "oscillator start failed!\n");
drivers/net/ieee802154/cc2520.c:	dev_vdbg(&priv->spi->dev, "oscillator brought up\n");
drivers/net/ieee802154/cc2520.c:	priv = devm_kzalloc(&spi->dev, sizeof(*priv), GFP_KERNEL);
drivers/net/ieee802154/cc2520.c:		dev_err(&spi->dev, "no platform data\n");
drivers/net/ieee802154/cc2520.c:	priv->buf = devm_kzalloc(&spi->dev,
drivers/net/ieee802154/cc2520.c:		dev_err(&spi->dev, "fifo gpio is not valid\n");
drivers/net/ieee802154/cc2520.c:	ret = devm_gpio_request_one(&spi->dev, pdata.fifo,
drivers/net/ieee802154/cc2520.c:		dev_err(&spi->dev, "cca gpio is not valid\n");
drivers/net/ieee802154/cc2520.c:	ret = devm_gpio_request_one(&spi->dev, pdata.cca,
drivers/net/ieee802154/cc2520.c:		dev_err(&spi->dev, "fifop gpio is not valid\n");
drivers/net/ieee802154/cc2520.c:	ret = devm_gpio_request_one(&spi->dev, pdata.fifop,
drivers/net/ieee802154/cc2520.c:		dev_err(&spi->dev, "sfd gpio is not valid\n");
drivers/net/ieee802154/cc2520.c:	ret = devm_gpio_request_one(&spi->dev, pdata.sfd,
drivers/net/ieee802154/cc2520.c:		dev_err(&spi->dev, "reset gpio is not valid\n");
drivers/net/ieee802154/cc2520.c:	ret = devm_gpio_request_one(&spi->dev, pdata.reset,
drivers/net/ieee802154/cc2520.c:		dev_err(&spi->dev, "vreg gpio is not valid\n");
drivers/net/ieee802154/cc2520.c:	ret = devm_gpio_request_one(&spi->dev, pdata.vreg,
drivers/net/ieee802154/cc2520.c:	ret = devm_request_irq(&spi->dev,
drivers/net/ieee802154/cc2520.c:			       dev_name(&spi->dev),
drivers/net/ieee802154/cc2520.c:		dev_err(&spi->dev, "could not get fifop irq\n");
drivers/net/ieee802154/cc2520.c:	ret = devm_request_irq(&spi->dev,
drivers/net/ieee802154/cc2520.c:			       dev_name(&spi->dev),
drivers/net/ieee802154/cc2520.c:		dev_err(&spi->dev, "could not get sfd irq\n");
drivers/net/ieee802154/ca8210.c:		&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:		dev_dbg(&priv->spi->dev, "%#03x\n", buf[i]);
drivers/net/ieee802154/ca8210.c:	struct ca8210_platform_data *pdata = spi->dev.platform_data;
drivers/net/ieee802154/ca8210.c:			&spi->dev,
drivers/net/ieee802154/ca8210.c:	dev_dbg(&spi->dev, "Reset the device\n");
drivers/net/ieee802154/ca8210.c:			&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:				&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:				&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:			&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:				&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:				&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:				&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:				&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:				&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:				&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:				&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:			dev_warn(&priv->spi->dev, "Wakeup reason unknown\n");
drivers/net/ieee802154/ca8210.c:		dev_info(&priv->spi->dev, "ca8210 was busy during attempted write\n");
drivers/net/ieee802154/ca8210.c:				&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:			dev_err(&priv->spi->dev, "too many retries!\n");
drivers/net/ieee802154/ca8210.c:		dev_info(&priv->spi->dev, "retried spi write\n");
drivers/net/ieee802154/ca8210.c:		dev_dbg(&priv->spi->dev, "READ CMD DURING TX\n");
drivers/net/ieee802154/ca8210.c:				&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:	dev_dbg(&spi->dev, "%s called\n", __func__);
drivers/net/ieee802154/ca8210.c:		dev_dbg(&spi->dev, "%#03x\n", cas_ctl->tx_buf[i]);
drivers/net/ieee802154/ca8210.c:			&spi->dev,
drivers/net/ieee802154/ca8210.c:	struct ca8210_priv *priv = spi->dev.driver_data;
drivers/net/ieee802154/ca8210.c:				&spi->dev,
drivers/net/ieee802154/ca8210.c:				&spi->dev,
drivers/net/ieee802154/ca8210.c:			&spi->dev,
drivers/net/ieee802154/ca8210.c:	dev_dbg(&priv->spi->dev, "irq: Interrupt occurred\n");
drivers/net/ieee802154/ca8210.c:				&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:		dev_crit(&spi->dev, "cascoda_api_downstream returned %d", ret);
drivers/net/ieee802154/ca8210.c:			&spi->dev,
drivers/net/ieee802154/ca8210.c:			&spi->dev,
drivers/net/ieee802154/ca8210.c:		dev_err(&spi->dev, "cascoda_api_downstream failed\n");
drivers/net/ieee802154/ca8210.c:			&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:			&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:			&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:	dev_dbg(&priv->spi->dev, "skb buffer length = %d\n", msdulen);
drivers/net/ieee802154/ca8210.c:	dev_dbg(&priv->spi->dev, "security level: %#03x\n", hdr.sec.level);
drivers/net/ieee802154/ca8210.c:	dev_dbg(&priv->spi->dev, "srcAddrMode: %#03x\n", hdr.source.mode);
drivers/net/ieee802154/ca8210.c:	dev_dbg(&priv->spi->dev, "srcPanId: %#06x\n", hdr.source.pan_id);
drivers/net/ieee802154/ca8210.c:	dev_dbg(&priv->spi->dev, "dstAddrMode: %#03x\n", hdr.dest.mode);
drivers/net/ieee802154/ca8210.c:	dev_dbg(&priv->spi->dev, "dstPanId: %#06x\n", hdr.dest.pan_id);
drivers/net/ieee802154/ca8210.c:		dev_crit(&priv->spi->dev, "failed to push mac hdr onto skb!\n");
drivers/net/ieee802154/ca8210.c:	dev_dbg(&priv->spi->dev, "%s: CmdID = %d\n", __func__, command[0]);
drivers/net/ieee802154/ca8210.c:				&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:	dev_dbg(&priv->spi->dev, "%s called\n", __func__);
drivers/net/ieee802154/ca8210.c:			&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:			&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:	dev_dbg(&priv->spi->dev, "calling %s\n", __func__);
drivers/net/ieee802154/ca8210.c:			&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:				&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:				&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:				&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:			&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:			&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:			&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:			&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:			&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:			&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:			&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:			&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:			&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:				&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:			&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:			&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:	dev_dbg(&priv->spi->dev, "test_interface: Cmd len = %d\n", cmdlen);
drivers/net/ieee802154/ca8210.c:	dev_dbg(&priv->spi->dev, "test_interface: Read\n");
drivers/net/ieee802154/ca8210.c:		dev_dbg(&priv->spi->dev, "%#03x\n", fifo_buffer[i]);
drivers/net/ieee802154/ca8210.c:		dev_info(&spi->dev, "Switching external clock on\n");
drivers/net/ieee802154/ca8210.c:			dev_crit(&spi->dev, "Invalid extclock-freq\n");
drivers/net/ieee802154/ca8210.c:		dev_info(&spi->dev, "Switching external clock off\n");
drivers/net/ieee802154/ca8210.c:	struct device_node *np = spi->dev.of_node;
drivers/net/ieee802154/ca8210.c:	struct ca8210_platform_data *pdata = spi->dev.platform_data;
drivers/net/ieee802154/ca8210.c:		&spi->dev,
drivers/net/ieee802154/ca8210.c:		dev_crit(&spi->dev, "Failed to register external clk\n");
drivers/net/ieee802154/ca8210.c:			&spi->dev,
drivers/net/ieee802154/ca8210.c:		dev_info(&spi->dev, "External clock set as clock provider\n");
drivers/net/ieee802154/ca8210.c:	of_clk_del_provider(spi->dev.of_node);
drivers/net/ieee802154/ca8210.c:	dev_info(&spi->dev, "External clock unregistered\n");
drivers/net/ieee802154/ca8210.c:	struct ca8210_platform_data *pdata = spi->dev.platform_data;
drivers/net/ieee802154/ca8210.c:		spi->dev.of_node,
drivers/net/ieee802154/ca8210.c:			&spi->dev,
drivers/net/ieee802154/ca8210.c:	struct ca8210_platform_data *pdata = spi->dev.platform_data;
drivers/net/ieee802154/ca8210.c:		spi->dev.of_node,
drivers/net/ieee802154/ca8210.c:			&spi->dev,
drivers/net/ieee802154/ca8210.c:		dev_crit(&spi->dev, "request_irq %d failed\n", pdata->irq_id);
drivers/net/ieee802154/ca8210.c:		dev_crit(&priv->spi->dev, "alloc of mlme_workqueue failed!\n");
drivers/net/ieee802154/ca8210.c:		dev_crit(&priv->spi->dev, "alloc of irq_workqueue failed!\n");
drivers/net/ieee802154/ca8210.c:		priv->spi->master->bus_num,
drivers/net/ieee802154/ca8210.c:		priv->spi->chip_select
drivers/net/ieee802154/ca8210.c:			&priv->spi->dev,
drivers/net/ieee802154/ca8210.c:	dev_info(&priv->spi->dev, "Test interface removed\n");
drivers/net/ieee802154/ca8210.c:	priv->spi->dev.platform_data = pdata;
drivers/net/ieee802154/at86rf230.c:	dev_err(&lp->spi->dev, "spi_async error %d\n", rc);
drivers/net/ieee802154/at86rf230.c:		dev_warn(&lp->spi->dev, "unexcept state change from 0x%02x to 0x%02x. Actual state: 0x%02x\n",
drivers/net/ieee802154/at86rf230.c:		dev_vdbg(&lp->spi->dev, "corrupted frame received\n");
drivers/net/ieee802154/at86rf230.c:		dev_vdbg(&lp->spi->dev, "failed to allocate sk_buff\n");
drivers/net/ieee802154/at86rf230.c:	enable_irq(lp->spi->irq);
drivers/net/ieee802154/at86rf230.c:		dev_err(&lp->spi->dev, "not supported irq %02x received\n",
drivers/net/ieee802154/at86rf230.c:	state->irq = lp->spi->irq;
drivers/net/ieee802154/at86rf230.c:	enable_irq(lp->spi->irq);
drivers/net/ieee802154/at86rf230.c:	disable_irq(lp->spi->irq);
drivers/net/ieee802154/at86rf230.c:		dev_vdbg(&lp->spi->dev,
drivers/net/ieee802154/at86rf230.c:		dev_vdbg(&lp->spi->dev,
drivers/net/ieee802154/at86rf230.c:		dev_vdbg(&lp->spi->dev,
drivers/net/ieee802154/at86rf230.c:		dev_vdbg(&lp->spi->dev,
drivers/net/ieee802154/at86rf230.c:	irq_type = irq_get_trigger_type(lp->spi->irq);
drivers/net/ieee802154/at86rf230.c:		dev_err(&lp->spi->dev, "DVDD error\n");
drivers/net/ieee802154/at86rf230.c:	struct at86rf230_platform_data *pdata = spi->dev.platform_data;
drivers/net/ieee802154/at86rf230.c:	if (!IS_ENABLED(CONFIG_OF) || !spi->dev.of_node) {
drivers/net/ieee802154/at86rf230.c:	*rstn = of_get_named_gpio(spi->dev.of_node, "reset-gpio", 0);
drivers/net/ieee802154/at86rf230.c:	*slp_tr = of_get_named_gpio(spi->dev.of_node, "sleep-gpio", 0);
drivers/net/ieee802154/at86rf230.c:	ret = of_property_read_u8(spi->dev.of_node, "xtal-trim", xtal_trim);
drivers/net/ieee802154/at86rf230.c:		dev_err(&lp->spi->dev, "Non-Atmel dev found (MAN_ID %02x %02x)\n",
drivers/net/ieee802154/at86rf230.c:	dev_info(&lp->spi->dev, "Detected %s chip version %d\n", chip, version);
drivers/net/ieee802154/at86rf230.c:	strncat(debugfs_dir_name, dev_name(&lp->spi->dev), DNAME_INLINE_LEN);
drivers/net/ieee802154/at86rf230.c:	if (!spi->irq) {
drivers/net/ieee802154/at86rf230.c:		dev_err(&spi->dev, "no IRQ specified\n");
drivers/net/ieee802154/at86rf230.c:		dev_err(&spi->dev, "failed to parse platform_data: %d\n", rc);
drivers/net/ieee802154/at86rf230.c:		rc = devm_gpio_request_one(&spi->dev, rstn,
drivers/net/ieee802154/at86rf230.c:		rc = devm_gpio_request_one(&spi->dev, slp_tr,
drivers/net/ieee802154/at86rf230.c:	hw->parent = &spi->dev;
drivers/net/ieee802154/at86rf230.c:		dev_err(&spi->dev, "Failed to allocate register map: %d\n",
drivers/net/ieee802154/at86rf230.c:	irq_type = irq_get_trigger_type(spi->irq);
drivers/net/ieee802154/at86rf230.c:	rc = devm_request_irq(&spi->dev, spi->irq, at86rf230_isr,
drivers/net/ieee802154/at86rf230.c:			      IRQF_SHARED | irq_type, dev_name(&spi->dev), lp);
drivers/net/ieee802154/at86rf230.c:	disable_irq(spi->irq);
drivers/net/ieee802154/at86rf230.c:	dev_dbg(&spi->dev, "unregistered at86rf230\n");
drivers/net/wan/slic_ds26522.c:	spi->bits_per_word = 8;
drivers/net/wan/slic_ds26522.c:		pr_info("DS26522 cs%d configured\n", spi->chip_select);
drivers/net/dsa/b53/b53_spi.c:	dev = b53_switch_alloc(&spi->dev, &b53_spi_ops, spi);
drivers/net/dsa/b53/b53_spi.c:	if (spi->dev.platform_data)
drivers/net/dsa/b53/b53_spi.c:		dev->pdata = spi->dev.platform_data;
drivers/net/dsa/microchip/ksz_spi.c:	dev = ksz_switch_alloc(&spi->dev, &ksz_spi_ops, spi);
drivers/net/dsa/microchip/ksz_spi.c:	if (spi->dev.platform_data)
drivers/net/dsa/microchip/ksz_spi.c:		dev->pdata = spi->dev.platform_data;
drivers/net/phy/spi_ks8995.c:		dev_err(&ks->spi->dev, "chip family id mismatch: expected 0x%02x but 0x%02x read\n",
drivers/net/phy/spi_ks8995.c:			dev_err(&ks->spi->dev, "unsupported chip id for KS8995 family: 0x%02x\n",
drivers/net/phy/spi_ks8995.c:			dev_err(&ks->spi->dev, "unsupported chip id for KSZ8795 family: 0x%02x\n",
drivers/net/phy/spi_ks8995.c:		dev_err(&ks->spi->dev, "unsupported family id: 0x%02x\n", id0);
drivers/net/phy/spi_ks8995.c:	struct device_node *np = ks->spi->dev.of_node;
drivers/net/phy/spi_ks8995.c:		dev_err(&spi->dev, "bad chip variant %d\n", variant);
drivers/net/phy/spi_ks8995.c:	ks = devm_kzalloc(&spi->dev, sizeof(*ks), GFP_KERNEL);
drivers/net/phy/spi_ks8995.c:	if (ks->spi->dev.of_node) {
drivers/net/phy/spi_ks8995.c:		ks->pdata = devm_kzalloc(&spi->dev, sizeof(*ks->pdata),
drivers/net/phy/spi_ks8995.c:		ks->pdata = spi->dev.platform_data;
drivers/net/phy/spi_ks8995.c:		err = devm_gpio_request_one(&spi->dev,
drivers/net/phy/spi_ks8995.c:			dev_err(&spi->dev,
drivers/net/phy/spi_ks8995.c:	spi->mode = SPI_MODE_0;
drivers/net/phy/spi_ks8995.c:	spi->bits_per_word = 8;
drivers/net/phy/spi_ks8995.c:		dev_err(&spi->dev, "spi_setup failed, err=%d\n", err);
drivers/net/phy/spi_ks8995.c:	err = sysfs_create_bin_file(&spi->dev.kobj, &ks->regs_attr);
drivers/net/phy/spi_ks8995.c:		dev_err(&spi->dev, "unable to create sysfs file, err=%d\n",
drivers/net/phy/spi_ks8995.c:	dev_info(&spi->dev, "%s device found, Chip ID:%x, Revision:%x\n",
drivers/net/phy/spi_ks8995.c:	sysfs_remove_bin_file(&spi->dev.kobj, &ks->regs_attr);
drivers/net/phy/spi_ks8995.c:		.name	    = "spi-ks8995",
drivers/net/can/spi/hi311x.c:		dev_err(&spi->dev, "spi transfer failed: ret = %d\n", ret);
drivers/net/can/spi/hi311x.c:	dev_dbg(&spi->dev, "hi3110_cmd: %02X\n", command);
drivers/net/can/spi/hi311x.c:		dev_err(&spi->dev, "hard_xmit called while tx busy\n");
drivers/net/can/spi/hi311x.c:	dev_dbg(&spi->dev, "BT: 0x%02x 0x%02x\n",
drivers/net/can/spi/hi311x.c:	dev_dbg(&spi->dev, "statf: %02X\n", statf);
drivers/net/can/spi/hi311x.c:	free_irq(spi->irq, priv);
drivers/net/can/spi/hi311x.c:	ret = request_threaded_irq(spi->irq, NULL, hi3110_can_ist,
drivers/net/can/spi/hi311x.c:		dev_err(&spi->dev, "failed to acquire irq %d\n", spi->irq);
drivers/net/can/spi/hi311x.c:	free_irq(spi->irq, priv);
drivers/net/can/spi/hi311x.c:							   &spi->dev);
drivers/net/can/spi/hi311x.c:	clk = devm_clk_get(&spi->dev, NULL);
drivers/net/can/spi/hi311x.c:		dev_err(&spi->dev, "no CAN clock source defined\n");
drivers/net/can/spi/hi311x.c:	spi->bits_per_word = 8;
drivers/net/can/spi/hi311x.c:	priv->power = devm_regulator_get_optional(&spi->dev, "vdd");
drivers/net/can/spi/hi311x.c:	priv->transceiver = devm_regulator_get_optional(&spi->dev, "xceiver");
drivers/net/can/spi/hi311x.c:		spi->dev.coherent_dma_mask = ~0;
drivers/net/can/spi/hi311x.c:		priv->spi_tx_buf = dmam_alloc_coherent(&spi->dev,
drivers/net/can/spi/hi311x.c:		priv->spi_tx_buf = devm_kzalloc(&spi->dev, HI3110_RX_BUF_LEN,
drivers/net/can/spi/hi311x.c:		priv->spi_rx_buf = devm_kzalloc(&spi->dev, HI3110_RX_BUF_LEN,
drivers/net/can/spi/hi311x.c:	SET_NETDEV_DEV(net, &spi->dev);
drivers/net/can/spi/hi311x.c:			dev_err(&spi->dev, "Cannot initialize %x. Wrong wiring?\n",
drivers/net/can/spi/hi311x.c:	dev_err(&spi->dev, "Probe failed, err=%d\n", -ret);
drivers/net/can/spi/hi311x.c:	disable_irq(spi->irq);
drivers/net/can/spi/hi311x.c:	enable_irq(spi->irq);
drivers/net/can/spi/mcp251x.c:		dev_err(&spi->dev, "spi transfer failed: ret = %d\n", ret);
drivers/net/can/spi/mcp251x.c:		dev_err(&spi->dev, "cannot allocate RX skb\n");
drivers/net/can/spi/mcp251x.c:		dev_warn(&spi->dev, "hard_xmit called while tx busy\n");
drivers/net/can/spi/mcp251x.c:				dev_err(&spi->dev, "MCP251x didn't"
drivers/net/can/spi/mcp251x.c:	dev_dbg(&spi->dev, "CNF: 0x%02x 0x%02x 0x%02x\n",
drivers/net/can/spi/mcp251x.c:	dev_dbg(&spi->dev, "CANCTRL 0x%02x\n", ctrl);
drivers/net/can/spi/mcp251x.c:	free_irq(spi->irq, priv);
drivers/net/can/spi/mcp251x.c:	free_irq(spi->irq, priv);
drivers/net/can/spi/mcp251x.c:		dev_err(&spi->dev, "unable to set initial baudrate!\n");
drivers/net/can/spi/mcp251x.c:	ret = request_threaded_irq(spi->irq, NULL, mcp251x_can_ist,
drivers/net/can/spi/mcp251x.c:		dev_err(&spi->dev, "failed to acquire irq %d\n", spi->irq);
drivers/net/can/spi/mcp251x.c:							   &spi->dev);
drivers/net/can/spi/mcp251x.c:	struct mcp251x_platform_data *pdata = dev_get_platdata(&spi->dev);
drivers/net/can/spi/mcp251x.c:	clk = devm_clk_get(&spi->dev, NULL);
drivers/net/can/spi/mcp251x.c:	spi->bits_per_word = 8;
drivers/net/can/spi/mcp251x.c:		spi->max_speed_hz = spi->max_speed_hz ? : 5 * 1000 * 1000;
drivers/net/can/spi/mcp251x.c:		spi->max_speed_hz = spi->max_speed_hz ? : 10 * 1000 * 1000;
drivers/net/can/spi/mcp251x.c:	priv->power = devm_regulator_get_optional(&spi->dev, "vdd");
drivers/net/can/spi/mcp251x.c:	priv->transceiver = devm_regulator_get_optional(&spi->dev, "xceiver");
drivers/net/can/spi/mcp251x.c:		spi->dev.coherent_dma_mask = ~0;
drivers/net/can/spi/mcp251x.c:		priv->spi_tx_buf = dmam_alloc_coherent(&spi->dev,
drivers/net/can/spi/mcp251x.c:		priv->spi_tx_buf = devm_kzalloc(&spi->dev, SPI_TRANSFER_BUF_LEN,
drivers/net/can/spi/mcp251x.c:		priv->spi_rx_buf = devm_kzalloc(&spi->dev, SPI_TRANSFER_BUF_LEN,
drivers/net/can/spi/mcp251x.c:	SET_NETDEV_DEV(net, &spi->dev);
drivers/net/can/spi/mcp251x.c:			dev_err(&spi->dev, "Cannot initialize MCP%x. Wrong wiring?\n", priv->model);
drivers/net/can/spi/mcp251x.c:	dev_err(&spi->dev, "Probe failed, err=%d\n", -ret);
drivers/net/can/spi/mcp251x.c:	disable_irq(spi->irq);
drivers/net/can/spi/mcp251x.c:	enable_irq(spi->irq);
drivers/net/caif/caif_spi.c:	debugfs_remove(cfspi->dbgfs_frame);
drivers/net/caif/caif_spi.c:	debugfs_remove(cfspi->dbgfs_state);
drivers/net/caif/caif_spi.c:	debugfs_remove(cfspi->dbgfs_dir);
drivers/net/caif/caif_spi.c:			"STATE: %d\n", cfspi->dbg_state);
drivers/net/caif/caif_spi.c:			"Previous CMD: 0x%x\n", cfspi->pcmd);
drivers/net/caif/caif_spi.c:			"Current CMD: 0x%x\n", cfspi->cmd);
drivers/net/caif/caif_spi.c:			"Previous TX len: %d\n", cfspi->tx_ppck_len);
drivers/net/caif/caif_spi.c:			"Previous RX len: %d\n", cfspi->rx_ppck_len);
drivers/net/caif/caif_spi.c:			"Current TX len: %d\n", cfspi->tx_cpck_len);
drivers/net/caif/caif_spi.c:			"Current RX len: %d\n", cfspi->rx_cpck_len);
drivers/net/caif/caif_spi.c:			"Next TX len: %d\n", cfspi->tx_npck_len);
drivers/net/caif/caif_spi.c:			"Next RX len: %d\n", cfspi->rx_npck_len);
drivers/net/caif/caif_spi.c:			"Tx data (Len: %d):\n", cfspi->tx_cpck_len);
drivers/net/caif/caif_spi.c:			   cfspi->xfer.va_tx[0],
drivers/net/caif/caif_spi.c:			   (cfspi->tx_cpck_len + SPI_CMD_SZ), 100);
drivers/net/caif/caif_spi.c:			"Rx data (Len: %d):\n", cfspi->rx_cpck_len);
drivers/net/caif/caif_spi.c:			   cfspi->xfer.va_rx,
drivers/net/caif/caif_spi.c:			   (cfspi->rx_cpck_len + SPI_CMD_SZ), 100);
drivers/net/caif/caif_spi.c:	cfspi->dbgfs_dir = debugfs_create_dir(cfspi->pdev->name, dbgfs_root);
drivers/net/caif/caif_spi.c:	cfspi->dbgfs_state = debugfs_create_file("state", S_IRUGO,
drivers/net/caif/caif_spi.c:						 cfspi->dbgfs_dir, cfspi,
drivers/net/caif/caif_spi.c:	cfspi->dbgfs_frame = debugfs_create_file("frame", S_IRUGO,
drivers/net/caif/caif_spi.c:						 cfspi->dbgfs_dir, cfspi,
drivers/net/caif/caif_spi.c:	cfspi->dbg_state = state;
drivers/net/caif/caif_spi.c:	if (cfspi->slave && !cfspi->slave_talked)
drivers/net/caif/caif_spi.c:		cfspi->slave_talked = true;
drivers/net/caif/caif_spi.c:		skb = skb_dequeue(&cfspi->chead);
drivers/net/caif/caif_spi.c:		cfspi->ndev->stats.tx_packets++;
drivers/net/caif/caif_spi.c:		cfspi->ndev->stats.tx_bytes += skb->len;
drivers/net/caif/caif_spi.c:	 * skb_queue_splice_tail(&cfspi->chead,&cfspi->qhead)
drivers/net/caif/caif_spi.c:	while (skb_peek(&cfspi->chead)) {
drivers/net/caif/caif_spi.c:		skb = skb_dequeue_tail(&cfspi->chead);
drivers/net/caif/caif_spi.c:		skb_queue_head(&cfspi->qhead, skb);
drivers/net/caif/caif_spi.c:		skb = skb_dequeue(&cfspi->qhead);
drivers/net/caif/caif_spi.c:			skb_queue_tail(&cfspi->chead, skb);
drivers/net/caif/caif_spi.c:			skb_queue_head(&cfspi->qhead, skb);
drivers/net/caif/caif_spi.c:	if (cfspi->flow_off_sent && cfspi->qhead.qlen < cfspi->qd_low_mark &&
drivers/net/caif/caif_spi.c:		cfspi->cfdev.flowctrl) {
drivers/net/caif/caif_spi.c:		cfspi->flow_off_sent = 0;
drivers/net/caif/caif_spi.c:		cfspi->cfdev.flowctrl(cfspi->ndev, 1);
drivers/net/caif/caif_spi.c:	if (cfspi->slave && !cfspi->slave_talked) {
drivers/net/caif/caif_spi.c:		spin_lock(&cfspi->lock);
drivers/net/caif/caif_spi.c:		set_bit(SPI_SS_ON, &cfspi->state);
drivers/net/caif/caif_spi.c:		set_bit(SPI_XFER, &cfspi->state);
drivers/net/caif/caif_spi.c:		set_bit(SPI_SS_OFF, &cfspi->state);
drivers/net/caif/caif_spi.c:		spin_unlock(&cfspi->lock);
drivers/net/caif/caif_spi.c:		wake_up_interruptible(&cfspi->wait);
drivers/net/caif/caif_spi.c:	complete(&cfspi->comp);
drivers/net/caif/caif_spi.c:	skb_queue_tail(&cfspi->qhead, skb);
drivers/net/caif/caif_spi.c:	spin_lock_irqsave(&cfspi->lock, flags);
drivers/net/caif/caif_spi.c:	if (!test_and_set_bit(SPI_XFER, &cfspi->state)) {
drivers/net/caif/caif_spi.c:		wake_up_interruptible(&cfspi->wait);
drivers/net/caif/caif_spi.c:	spin_unlock_irqrestore(&cfspi->lock, flags);
drivers/net/caif/caif_spi.c:	if (!cfspi->flow_off_sent &&
drivers/net/caif/caif_spi.c:		cfspi->qhead.qlen > cfspi->qd_high_mark &&
drivers/net/caif/caif_spi.c:		cfspi->cfdev.flowctrl) {
drivers/net/caif/caif_spi.c:		cfspi->flow_off_sent = 1;
drivers/net/caif/caif_spi.c:		cfspi->cfdev.flowctrl(cfspi->ndev, 0);
drivers/net/caif/caif_spi.c:		skb = netdev_alloc_skb(cfspi->ndev, pkt_len + 1);
drivers/net/caif/caif_spi.c:			res = cfspi_xmit(skb, cfspi->ndev);
drivers/net/caif/caif_spi.c:			cfspi->ndev->stats.rx_packets++;
drivers/net/caif/caif_spi.c:			cfspi->ndev->stats.rx_bytes += pkt_len;
drivers/net/caif/caif_spi.c:			cfspi->ndev->stats.rx_dropped++;
drivers/net/caif/caif_spi.c:	cfspi->flow_off_sent = 0;
drivers/net/caif/caif_spi.c:	cfspi->qd_low_mark = LOW_WATER_MARK;
drivers/net/caif/caif_spi.c:	cfspi->qd_high_mark = HIGH_WATER_MARK;
drivers/net/caif/caif_spi.c:		cfspi->slave = true;
drivers/net/caif/caif_spi.c:		cfspi->slave_talked = false;
drivers/net/caif/caif_spi.c:		cfspi->slave = false;
drivers/net/caif/caif_spi.c:		cfspi->slave_talked = false;
drivers/net/caif/caif_spi.c:	cfspi->xfer.va_tx[0] = dma_alloc(&cfspi->xfer.pa_tx[0]);
drivers/net/caif/caif_spi.c:	if (!cfspi->xfer.va_tx[0]) {
drivers/net/caif/caif_spi.c:	cfspi->xfer.va_rx = dma_alloc(&cfspi->xfer.pa_rx);
drivers/net/caif/caif_spi.c:	if (!cfspi->xfer.va_rx) {
drivers/net/caif/caif_spi.c:	INIT_WORK(&cfspi->work, cfspi_xfer);
drivers/net/caif/caif_spi.c:	spin_lock_init(&cfspi->lock);
drivers/net/caif/caif_spi.c:	cfspi->flow_stop = false;
drivers/net/caif/caif_spi.c:	init_waitqueue_head(&cfspi->wait);
drivers/net/caif/caif_spi.c:	cfspi->wq = create_singlethread_workqueue(dev->name);
drivers/net/caif/caif_spi.c:	if (!cfspi->wq) {
drivers/net/caif/caif_spi.c:	init_completion(&cfspi->comp);
drivers/net/caif/caif_spi.c:	cfspi->ifc.ss_cb = cfspi_ss_cb;
drivers/net/caif/caif_spi.c:	cfspi->ifc.xfer_done_cb = cfspi_xfer_done_cb;
drivers/net/caif/caif_spi.c:	cfspi->ifc.priv = cfspi;
drivers/net/caif/caif_spi.c:	list_add_tail(&cfspi->list, &cfspi_list);
drivers/net/caif/caif_spi.c:	queue_work(cfspi->wq, &cfspi->work);
drivers/net/caif/caif_spi.c:	dma_free(cfspi->xfer.va_rx, cfspi->xfer.pa_rx);
drivers/net/caif/caif_spi.c:	dma_free(cfspi->xfer.va_tx[0], cfspi->xfer.pa_tx[0]);
drivers/net/caif/caif_spi.c:	list_del(&cfspi->list);
drivers/net/caif/caif_spi.c:	cfspi->ndev = NULL;
drivers/net/caif/caif_spi.c:	dma_free(cfspi->xfer.va_rx, cfspi->xfer.pa_rx);
drivers/net/caif/caif_spi.c:	dma_free(cfspi->xfer.va_tx[0], cfspi->xfer.pa_tx[0]);
drivers/net/caif/caif_spi.c:	set_bit(SPI_TERMINATE, &cfspi->state);
drivers/net/caif/caif_spi.c:	wake_up_interruptible(&cfspi->wait);
drivers/net/caif/caif_spi.c:	destroy_workqueue(cfspi->wq);
drivers/net/caif/caif_spi.c:	skb_queue_head_init(&cfspi->qhead);
drivers/net/caif/caif_spi.c:	skb_queue_head_init(&cfspi->chead);
drivers/net/caif/caif_spi.c:	cfspi->cfdev.link_select = CAIF_LINK_HIGH_BANDW;
drivers/net/caif/caif_spi.c:	cfspi->cfdev.use_frag = false;
drivers/net/caif/caif_spi.c:	cfspi->cfdev.use_stx = false;
drivers/net/caif/caif_spi.c:	cfspi->cfdev.use_fcs = false;
drivers/net/caif/caif_spi.c:	cfspi->ndev = dev;
drivers/net/caif/caif_spi.c:	cfspi->ndev = ndev;
drivers/net/caif/caif_spi.c:	cfspi->pdev = pdev;
drivers/net/caif/caif_spi.c:	cfspi->dev = dev;
drivers/net/caif/caif_spi.c:	dev->ifc = &cfspi->ifc;
drivers/net/caif/caif_spi.c:		unregister_netdev(cfspi->ndev);
drivers/net/caif/caif_spi_slave.c:	return cfspi->rx_cpck_len;
drivers/net/caif/caif_spi_slave.c:	cfspi->pcmd = cfspi->cmd;
drivers/net/caif/caif_spi_slave.c:	cfspi->tx_ppck_len = cfspi->tx_cpck_len;
drivers/net/caif/caif_spi_slave.c:	cfspi->rx_ppck_len = cfspi->rx_cpck_len;
drivers/net/caif/caif_spi_slave.c:	cfspi->cmd = SPI_CMD_EOT;
drivers/net/caif/caif_spi_slave.c:		wait_event_interruptible(cfspi->wait,
drivers/net/caif/caif_spi_slave.c:				 test_bit(SPI_XFER, &cfspi->state) ||
drivers/net/caif/caif_spi_slave.c:				 test_bit(SPI_TERMINATE, &cfspi->state));
drivers/net/caif/caif_spi_slave.c:		if (test_bit(SPI_TERMINATE, &cfspi->state))
drivers/net/caif/caif_spi_slave.c:		memset(cfspi->xfer.va_tx, 0xFF, SPI_DMA_BUF_LEN);
drivers/net/caif/caif_spi_slave.c:		memset(cfspi->xfer.va_rx, 0xFF, SPI_DMA_BUF_LEN);
drivers/net/caif/caif_spi_slave.c:		if (cfspi->tx_cpck_len) {
drivers/net/caif/caif_spi_slave.c:			ptr = (u8 *) cfspi->xfer.va_tx;
drivers/net/caif/caif_spi_slave.c:			len = cfspi_xmitfrm(cfspi, ptr, cfspi->tx_cpck_len);
drivers/net/caif/caif_spi_slave.c:			WARN_ON(len != cfspi->tx_cpck_len);
drivers/net/caif/caif_spi_slave.c:		cfspi->tx_npck_len = cfspi_xmitlen(cfspi);
drivers/net/caif/caif_spi_slave.c:		WARN_ON(cfspi->tx_npck_len > SPI_DMA_BUF_LEN);
drivers/net/caif/caif_spi_slave.c:		ptr = (u8 *) cfspi->xfer.va_tx;
drivers/net/caif/caif_spi_slave.c:		*ptr++ = cfspi->tx_npck_len & 0x00FF;
drivers/net/caif/caif_spi_slave.c:		*ptr++ = (cfspi->tx_npck_len & 0xFF00) >> 8;
drivers/net/caif/caif_spi_slave.c:		cfspi->xfer.tx_dma_len = cfspi->tx_cpck_len + SPI_IND_SZ;
drivers/net/caif/caif_spi_slave.c:		cfspi->xfer.rx_dma_len = cfspi->rx_cpck_len + SPI_CMD_SZ;
drivers/net/caif/caif_spi_slave.c:		if (cfspi->tx_cpck_len &&
drivers/net/caif/caif_spi_slave.c:			(cfspi->xfer.tx_dma_len % spi_frm_align)) {
drivers/net/caif/caif_spi_slave.c:			cfspi->xfer.tx_dma_len += spi_frm_align -
drivers/net/caif/caif_spi_slave.c:			    (cfspi->xfer.tx_dma_len % spi_frm_align);
drivers/net/caif/caif_spi_slave.c:		if (cfspi->rx_cpck_len &&
drivers/net/caif/caif_spi_slave.c:			(cfspi->xfer.rx_dma_len % spi_frm_align)) {
drivers/net/caif/caif_spi_slave.c:			cfspi->xfer.rx_dma_len += spi_frm_align -
drivers/net/caif/caif_spi_slave.c:			    (cfspi->xfer.rx_dma_len % spi_frm_align);
drivers/net/caif/caif_spi_slave.c:		ret = cfspi->dev->init_xfer(&cfspi->xfer, cfspi->dev);
drivers/net/caif/caif_spi_slave.c:		cfspi->dev->sig_xfer(true, cfspi->dev);
drivers/net/caif/caif_spi_slave.c:		wait_for_completion(&cfspi->comp);
drivers/net/caif/caif_spi_slave.c:		if (cfspi->cmd == SPI_CMD_EOT) {
drivers/net/caif/caif_spi_slave.c:			clear_bit(SPI_SS_ON, &cfspi->state);
drivers/net/caif/caif_spi_slave.c:		if (SPI_XFER_TIME_USEC(cfspi->xfer.tx_dma_len,
drivers/net/caif/caif_spi_slave.c:					cfspi->dev->clk_mhz) <
drivers/net/caif/caif_spi_slave.c:				(cfspi->xfer.tx_dma_len, cfspi->dev->clk_mhz));
drivers/net/caif/caif_spi_slave.c:		cfspi->dev->sig_xfer(false, cfspi->dev);
drivers/net/caif/caif_spi_slave.c:		if (cfspi->rx_cpck_len) {
drivers/net/caif/caif_spi_slave.c:			ptr = ((u8 *)(cfspi->xfer.va_rx + SPI_DATA_POS));
drivers/net/caif/caif_spi_slave.c:			len = cfspi_rxfrm(cfspi, ptr, cfspi->rx_cpck_len);
drivers/net/caif/caif_spi_slave.c:			WARN_ON(len != cfspi->rx_cpck_len);
drivers/net/caif/caif_spi_slave.c:		ptr = (u8 *) cfspi->xfer.va_rx;
drivers/net/caif/caif_spi_slave.c:		cfspi->cmd = *ptr++;
drivers/net/caif/caif_spi_slave.c:		cfspi->cmd |= ((*ptr++) << 8) & 0xFF00;
drivers/net/caif/caif_spi_slave.c:		cfspi->rx_npck_len = *ptr++;
drivers/net/caif/caif_spi_slave.c:		cfspi->rx_npck_len |= ((*ptr++) << 8) & 0xFF00;
drivers/net/caif/caif_spi_slave.c:		WARN_ON(cfspi->rx_npck_len > SPI_DMA_BUF_LEN);
drivers/net/caif/caif_spi_slave.c:		WARN_ON(cfspi->cmd > SPI_CMD_EOT);
drivers/net/caif/caif_spi_slave.c:		if (cfspi->cmd == SPI_CMD_EOT) {
drivers/net/caif/caif_spi_slave.c:			cfspi->tx_cpck_len = 0;
drivers/net/caif/caif_spi_slave.c:			cfspi->rx_cpck_len = 0;
drivers/net/caif/caif_spi_slave.c:			cfspi->tx_cpck_len = cfspi->tx_npck_len;
drivers/net/caif/caif_spi_slave.c:			cfspi->rx_cpck_len = cfspi->rx_npck_len;
drivers/net/caif/caif_spi_slave.c:		spin_lock_irqsave(&cfspi->lock, flags);
drivers/net/caif/caif_spi_slave.c:		if (cfspi->cmd == SPI_CMD_EOT && !cfspi_xmitlen(cfspi)
drivers/net/caif/caif_spi_slave.c:			&& !test_bit(SPI_SS_ON, &cfspi->state))
drivers/net/caif/caif_spi_slave.c:			clear_bit(SPI_XFER, &cfspi->state);
drivers/net/caif/caif_spi_slave.c:		spin_unlock_irqrestore(&cfspi->lock, flags);
drivers/net/wireless/st/cw1200/Makefile:cw1200_wlan_spi-y := cw1200_spi.o
drivers/net/wireless/marvell/libertas/if_spi.c:		err = lbs_get_firmware(&card->spi->dev, card->card_id,
drivers/net/wireless/marvell/libertas/if_spi.c:				"spi->max_speed_hz=%d\n",
drivers/net/wireless/marvell/libertas/if_spi.c:				card->spi->master->bus_num,
drivers/net/wireless/marvell/libertas/if_spi.c:				card->spi->chip_select,
drivers/net/wireless/marvell/libertas/if_spi.c:				card->spi->max_speed_hz);
drivers/net/wireless/marvell/libertas/if_spi.c:		enable_irq(card->spi->irq);
drivers/net/wireless/marvell/libertas/if_spi.c:	struct libertas_spi_platform_data *pdata = dev_get_platdata(&spi->dev);
drivers/net/wireless/marvell/libertas/if_spi.c:	priv = lbs_add_card(card, &spi->dev);
drivers/net/wireless/marvell/libertas/if_spi.c:	err = request_irq(spi->irq, if_spi_host_interrupt,
drivers/net/wireless/marvell/libertas/if_spi.c:	free_irq(spi->irq, card);
drivers/net/wireless/marvell/libertas/if_spi.c:	free_irq(spi->irq, card);
drivers/net/wireless/marvell/libertas/if_spi.c:		disable_irq(spi->irq);
drivers/net/wireless/marvell/libertas/Makefile:libertas_spi-objs += if_spi.o
drivers/net/wireless/intersil/p54/p54spi.c:		dev_err(&priv->spi->dev, "spi_write_dma not allowed "
drivers/net/wireless/intersil/p54/p54spi.c:	ret = request_firmware(&priv->firmware, "3826.arm", &priv->spi->dev);
drivers/net/wireless/intersil/p54/p54spi.c:		dev_err(&priv->spi->dev, "request_firmware() failed: %d", ret);
drivers/net/wireless/intersil/p54/p54spi.c:	ret = request_firmware_direct(&eeprom, "3826.eeprom", &priv->spi->dev);
drivers/net/wireless/intersil/p54/p54spi.c:		dev_info(&priv->spi->dev, "loading default eeprom...\n");
drivers/net/wireless/intersil/p54/p54spi.c:		dev_err(&priv->spi->dev, "Failed to request user eeprom\n");
drivers/net/wireless/intersil/p54/p54spi.c:		dev_info(&priv->spi->dev, "loading user eeprom...\n");
drivers/net/wireless/intersil/p54/p54spi.c:		dev_err(&priv->spi->dev, "INT_READY timeout\n");
drivers/net/wireless/intersil/p54/p54spi.c:		dev_err(&priv->spi->dev, "rx request of zero bytes\n");
drivers/net/wireless/intersil/p54/p54spi.c:		dev_err(&priv->spi->dev, "could not alloc skb");
drivers/net/wireless/intersil/p54/p54spi.c:		dev_err(&priv->spi->dev, "WR_READY timeout\n");
drivers/net/wireless/intersil/p54/p54spi.c:		dev_err(&priv->spi->dev, "firmware boot failed");
drivers/net/wireless/intersil/p54/p54spi.c:		dev_err(&spi->dev, "could not alloc ieee80211_hw");
drivers/net/wireless/intersil/p54/p54spi.c:	spi->bits_per_word = 16;
drivers/net/wireless/intersil/p54/p54spi.c:	spi->max_speed_hz = 24000000;
drivers/net/wireless/intersil/p54/p54spi.c:		dev_err(&priv->spi->dev, "spi_setup failed");
drivers/net/wireless/intersil/p54/p54spi.c:		dev_err(&priv->spi->dev, "power GPIO request failed: %d", ret);
drivers/net/wireless/intersil/p54/p54spi.c:		dev_err(&priv->spi->dev, "irq GPIO request failed: %d", ret);
drivers/net/wireless/intersil/p54/p54spi.c:		dev_err(&priv->spi->dev, "request_irq() failed");
drivers/net/wireless/intersil/p54/p54spi.c:	SET_IEEE80211_DEV(hw, &spi->dev);
drivers/net/wireless/intersil/p54/p54spi.c:	ret = p54_register_common(hw, &priv->spi->dev);
drivers/net/wireless/ti/wlcore/spi.c:	spi->mode ^= SPI_CS_HIGH;
drivers/net/wireless/ti/wlcore/spi.c:	spi->mode ^= SPI_CS_HIGH;
drivers/net/wireless/ti/wlcore/spi.c:	struct device_node *dt_node = spi->dev.of_node;
drivers/net/wireless/ti/wlcore/spi.c:	dev_info(&spi->dev, "selected chip family is %s\n",
drivers/net/wireless/ti/wlcore/spi.c:	pdev_data = devm_kzalloc(&spi->dev, sizeof(*pdev_data), GFP_KERNEL);
drivers/net/wireless/ti/wlcore/spi.c:	glue = devm_kzalloc(&spi->dev, sizeof(*glue), GFP_KERNEL);
drivers/net/wireless/ti/wlcore/spi.c:		dev_err(&spi->dev, "can't allocate glue\n");
drivers/net/wireless/ti/wlcore/spi.c:	glue->dev = &spi->dev;
drivers/net/wireless/ti/wlcore/spi.c:	spi->bits_per_word = 32;
drivers/net/wireless/ti/wlcore/spi.c:	glue->reg = devm_regulator_get(&spi->dev, "vwlan");
drivers/net/wireless/ti/wlcore/spi.c:	glue->core->dev.parent = &spi->dev;
drivers/net/wireless/ti/wlcore/spi.c:	res[0].start = spi->irq;
drivers/net/wireless/ti/wlcore/spi.c:	res[0].flags = IORESOURCE_IRQ | irq_get_trigger_type(spi->irq);
drivers/net/wireless/ti/wlcore/Makefile:wlcore_spi-objs 	= spi.o
drivers/net/wireless/ti/wl1251/spi.c:	struct wl1251_platform_data *pdata = dev_get_platdata(&spi->dev);
drivers/net/wireless/ti/wl1251/spi.c:	struct device_node *np = spi->dev.of_node;
drivers/net/wireless/ti/wl1251/spi.c:	SET_IEEE80211_DEV(hw, &spi->dev);
drivers/net/wireless/ti/wl1251/spi.c:	spi->bits_per_word = 32;
drivers/net/wireless/ti/wl1251/spi.c:		ret = devm_gpio_request_one(&spi->dev, wl->power_gpio,
drivers/net/wireless/ti/wl1251/spi.c:	wl->irq = spi->irq;
drivers/net/wireless/ti/wl1251/spi.c:	ret = devm_request_irq(&spi->dev, wl->irq, wl1251_irq, 0,
drivers/net/wireless/ti/wl1251/spi.c:	wl->vio = devm_regulator_get(&spi->dev, "vio");
drivers/net/wireless/ti/wl1251/Makefile:wl1251_spi-objs		+= spi.o
drivers/media/rc/ir-spi.c:		dev_err(&idata->spi->dev, "unable to deliver the signal\n");
drivers/media/rc/ir-spi.c:	idata = devm_kzalloc(&spi->dev, sizeof(*idata), GFP_KERNEL);
drivers/media/rc/ir-spi.c:	idata->regulator = devm_regulator_get(&spi->dev, "irda_regulator");
drivers/media/rc/ir-spi.c:	idata->rc = devm_rc_allocate_device(&spi->dev, RC_DRIVER_IR_RAW_TX);
drivers/media/rc/ir-spi.c:	idata->negated = of_property_read_bool(spi->dev.of_node,
drivers/media/rc/ir-spi.c:	ret = of_property_read_u8(spi->dev.of_node, "duty-cycle", &dc);
drivers/media/rc/ir-spi.c:	return devm_rc_register_device(&spi->dev, idata->rc);
drivers/media/rc/ir-spi.c:	{ .compatible = "ir-spi-led" },
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:	spin_lock_irqsave(&spi->lock, flags);
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:	reg = readw(&spi->regs->control_stat);
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:		spin_unlock_irqrestore(&spi->lock, flags);
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:		dev_dbg(&spi->master->dev,
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:	writew(reg | NETUP_SPI_CTRL_IRQ, &spi->regs->control_stat);
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:	reg = readw(&spi->regs->control_stat);
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:	writew(reg & ~NETUP_SPI_CTRL_IMASK, &spi->regs->control_stat);
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:	spi->state = SPI_STATE_DONE;
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:	wake_up(&spi->waitq);
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:	spin_unlock_irqrestore(&spi->lock, flags);
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:	dev_dbg(&spi->master->dev,
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:	writew(NETUP_SPI_CTRL_LAST_CS, &spi->regs->control_stat);
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:	writew(0, &spi->regs->control_stat);
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:			u32 frag_size = (tr_size > sizeof(spi->regs->data)) ?
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:					sizeof(spi->regs->data) : tr_size;
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:				memcpy_toio(spi->regs->data,
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:				memset_io(spi->regs->data,
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:			spi->state = SPI_STATE_START;
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:				&spi->regs->control_stat);
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:			dev_dbg(&spi->master->dev,
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:				__func__, readw(&spi->regs->control_stat));
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:			wait_event_timeout(spi->waitq,
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:				spi->state != SPI_STATE_START,
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:			if (spi->state == SPI_STATE_DONE) {
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:						spi->regs->data, frag_size);
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:				if (spi->state == SPI_STATE_START) {
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:					dev_dbg(&spi->master->dev,
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:					dev_dbg(&spi->master->dev,
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:						__func__, spi->state);
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:	spin_lock_init(&nspi->lock);
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:	init_waitqueue_head(&nspi->waitq);
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:	nspi->master = master;
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:	nspi->regs = (struct netup_spi_regs __iomem *)(ndev->bmmio0 + 0x4000);
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:	writew(2, &nspi->regs->clock_divider);
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:	spin_lock_irqsave(&spi->lock, flags);
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:	reg = readw(&spi->regs->control_stat);
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:	writew(reg | NETUP_SPI_CTRL_IRQ, &spi->regs->control_stat);
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:	reg = readw(&spi->regs->control_stat);
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:	writew(reg & ~NETUP_SPI_CTRL_IMASK, &spi->regs->control_stat);
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:	spin_unlock_irqrestore(&spi->lock, flags);
drivers/media/pci/netup_unidvb/netup_unidvb_spi.c:	spi_unregister_master(spi->master);
drivers/media/tuners/msi001.c:	dev_dbg(&spi->dev, "lna=%d mixer=%d if=%d\n",
drivers/media/tuners/msi001.c:	dev_dbg(&spi->dev, "failed %d\n", ret);
drivers/media/tuners/msi001.c:	dev_dbg(&spi->dev, "f_rf=%d f_if=%d\n", f_rf, f_if);
drivers/media/tuners/msi001.c:	dev_dbg(&spi->dev, "bandwidth selected=%d\n", bandwidth_lut[i].freq);
drivers/media/tuners/msi001.c:	dev_dbg(&spi->dev,
drivers/media/tuners/msi001.c:	dev_dbg(&spi->dev, "failed %d\n", ret);
drivers/media/tuners/msi001.c:	dev_dbg(&spi->dev, "on=%d\n", on);
drivers/media/tuners/msi001.c:	dev_dbg(&spi->dev, "index=%d\n", v->index);
drivers/media/tuners/msi001.c:	dev_dbg(&spi->dev, "index=%d\n", v->index);
drivers/media/tuners/msi001.c:	dev_dbg(&spi->dev, "tuner=%d\n", f->tuner);
drivers/media/tuners/msi001.c:	dev_dbg(&spi->dev, "tuner=%d type=%d frequency=%u\n",
drivers/media/tuners/msi001.c:	dev_dbg(&spi->dev, "tuner=%d type=%d index=%d\n",
drivers/media/tuners/msi001.c:	dev_dbg(&spi->dev, "id=%d name=%s val=%d min=%lld max=%lld step=%lld\n",
drivers/media/tuners/msi001.c:		dev_dbg(&spi->dev, "unknown control %d\n", ctrl->id);
drivers/media/tuners/msi001.c:	dev_dbg(&spi->dev, "\n");
drivers/media/tuners/msi001.c:		dev_err(&spi->dev, "Could not initialize controls\n");
drivers/media/tuners/msi001.c:	dev_dbg(&spi->dev, "\n");
drivers/media/i2c/s5c73m3/s5c73m3-spi.c:	struct s5c73m3 *state = container_of(spi->dev.driver, struct s5c73m3,
drivers/media/i2c/s5c73m3/s5c73m3-spi.c:	spi->bits_per_word = 32;
drivers/media/i2c/s5c73m3/s5c73m3-spi.c:		dev_err(&spi->dev, "spi_setup() failed\n");
drivers/media/spi/gs1662.c:	gs = devm_kzalloc(&spi->dev, sizeof(struct gs), GFP_KERNEL);
drivers/media/spi/gs1662.c:	spi->mode = SPI_MODE_0;
drivers/media/spi/gs1662.c:	spi->irq = -1;
drivers/media/spi/gs1662.c:	spi->max_speed_hz = 10000000;
drivers/media/spi/gs1662.c:	spi->bits_per_word = 16;
drivers/media/v4l2-core/v4l2-device.c:			if (spi && !spi->dev.of_node && !spi->dev.fwnode)
drivers/media/v4l2-core/v4l2-common.c:	sd->owner = spi->dev.driver->owner;
drivers/media/v4l2-core/v4l2-common.c:	sd->dev = &spi->dev;
drivers/media/v4l2-core/v4l2-common.c:	strlcpy(sd->name, spi->dev.driver->name, sizeof(sd->name));
drivers/media/v4l2-core/v4l2-common.c:	if (spi == NULL || spi->dev.driver == NULL)
drivers/media/v4l2-core/v4l2-common.c:	if (!try_module_get(spi->dev.driver->owner))
drivers/media/v4l2-core/v4l2-common.c:	module_put(spi->dev.driver->owner);
Documentation/blackfin/00-INDEX:bfin-spi-notes.txt
Documentation/gpio/drivers-on-gpio.txt:- spi_gpio: drivers/spi/spi-gpio.c is used to drive an SPI bus (variable number
Documentation/spi/spi-sc18is602:Kernel driver spi-sc18is602
Documentation/spi/00-INDEX:spi-lm70llp
Documentation/spi/00-INDEX:spi-sc18is602
Documentation/spi/00-INDEX:spi-summary
Documentation/spi/pxa2xx:(see Documentation/spi/spi-summary). The driver has the following features
Documentation/spi/pxa2xx:"Documentation/spi/spi-summary" for additional information.
Documentation/spi/spi-summary:		pdata = &spi->dev.platform_data;
Documentation/networking/caif/spi_porting.txt:	sspi->xfer = xfer;
Documentation/mtd/spi-nor.txt:drivers/mtd/spi-nor/spi-nor.c for detail. Please also refer to fsl-quadspi.c
Documentation/devicetree/bindings/security/tpm/st33zp24-spi.txt:- spi-max-frequency: Maximum SPI frequency (<= 10000000).
Documentation/devicetree/bindings/security/tpm/st33zp24-spi.txt:                spi-max-frequency = <10000000>;
Documentation/devicetree/bindings/security/tpm/tpm_tis_spi.txt:- spi-max-frequency: Maximum SPI frequency (depends on TPMs).
Documentation/devicetree/bindings/security/tpm/tpm_tis_spi.txt:                spi-max-frequency = <10000000>;
Documentation/devicetree/bindings/interrupt-controller/marvell,odmi-controller.txt:- marvell,spi-base     : List of GIC base SPI interrupts, one for each
Documentation/devicetree/bindings/interrupt-controller/marvell,odmi-controller.txt:                         i.e marvell,spi-base = <128> will use SPI #96.
Documentation/devicetree/bindings/interrupt-controller/marvell,odmi-controller.txt:		marvell,spi-base = <128>, <136>, <144>, <152>;
Documentation/devicetree/bindings/interrupt-controller/marvell,gicp.txt:- marvell,spi-ranges: tuples of GIC SPI interrupts ranges available
Documentation/devicetree/bindings/interrupt-controller/marvell,gicp.txt:	marvell,spi-ranges = <64 64>, <288 64>;
Documentation/devicetree/bindings/interrupt-controller/socionext,synquacer-exiu.txt:- socionext,spi-base   : The SPI number of the first SPI of the 32 adjacent
Documentation/devicetree/bindings/interrupt-controller/socionext,synquacer-exiu.txt:		socionext,spi-base = <112>;
Documentation/devicetree/bindings/mfd/sprd,sc27xx-pmic.txt:- spi-max-frequency: Typically set to 26000000.
Documentation/devicetree/bindings/mfd/sprd,sc27xx-pmic.txt:	spi-max-frequency = <26000000>;
Documentation/devicetree/bindings/mfd/altera-a10sr.txt:- spi-max-frequency	: Maximum SPI frequency.
Documentation/devicetree/bindings/mfd/altera-a10sr.txt:		spi-max-frequency = <100000>;
Documentation/devicetree/bindings/mfd/cros-ec.txt:- google,cros-ec-spi-pre-delay: Some implementations of the EC need a little
Documentation/devicetree/bindings/mfd/cros-ec.txt:- google,cros-ec-spi-msg-delay: Some implementations of the EC require some
Documentation/devicetree/bindings/mfd/cros-ec.txt:		spi-max-frequency = <5000000>;
Documentation/devicetree/bindings/mfd/cros-ec.txt:		samsung,spi-cs;
Documentation/devicetree/bindings/mfd/cros-ec.txt:		samsung,spi-feedback-delay = <2>;
Documentation/devicetree/bindings/mfd/motorola-cpcap.txt:- spi-max-frequency	: Typically set to 3000000
Documentation/devicetree/bindings/mfd/motorola-cpcap.txt:- spi-cs-high		: SPI chip select direction
Documentation/devicetree/bindings/mfd/motorola-cpcap.txt:		spi-max-frequency = <3000000>;
Documentation/devicetree/bindings/mfd/motorola-cpcap.txt:		spi-cs-high;
Documentation/devicetree/bindings/mfd/mc13xxx.txt:		spi-max-frequency = <6000000>;
Documentation/devicetree/bindings/mfd/atmel-flexcom.txt:			spi-max-frequency = <20000000>;
Documentation/devicetree/bindings/misc/ge-achc.txt:- spi-max-frequency : Maximum SPI clocking speed of device in Hz, should be
Documentation/devicetree/bindings/misc/ge-achc.txt:	spi-max-frequency = <1000000>;
Documentation/devicetree/bindings/misc/eeprom-93xx46.txt:Property rules described in Documentation/devicetree/bindings/spi/spi-bus.txt
Documentation/devicetree/bindings/misc/eeprom-93xx46.txt:apply.  In particular, "reg" and "spi-max-frequency" properties must be given.
Documentation/devicetree/bindings/misc/eeprom-93xx46.txt:		spi-max-frequency = <1000000>;
Documentation/devicetree/bindings/misc/eeprom-93xx46.txt:		spi-cs-high;
Documentation/devicetree/bindings/fpga/altera-passive-serial.txt:		spi-max-frequency = <20000000>;
Documentation/devicetree/bindings/fpga/lattice-ice40-fpga-mgr.txt:- spi-max-frequency:	Maximum SPI frequency (>=1000000, <=25000000)
Documentation/devicetree/bindings/fpga/lattice-ice40-fpga-mgr.txt:		spi-max-frequency = <1000000>;
Documentation/devicetree/bindings/fpga/xilinx-slave-serial.txt:			spi-max-frequency = <60000000>;
Documentation/devicetree/bindings/fpga/xilinx-slave-serial.txt:			spi-cpha;
Documentation/devicetree/bindings/iio/pressure/zpa2326.txt:- spi-max-frequency: maximum SPI bus frequency as documented in
Documentation/devicetree/bindings/iio/pressure/zpa2326.txt:  Documentation/devicetree/bindings/spi/spi-bus.txt
Documentation/devicetree/bindings/iio/accel/adxl345.txt: - spi-max-frequency : set maximum clock frequency, must be 5000000
Documentation/devicetree/bindings/iio/accel/adxl345.txt: - spi-cpol and spi-cpha : must be defined for adxl345 to enable SPI mode 3
Documentation/devicetree/bindings/iio/accel/adxl345.txt:		spi-max-frequency = <5000000>;
Documentation/devicetree/bindings/iio/accel/adxl345.txt:		spi-cpol;
Documentation/devicetree/bindings/iio/accel/adxl345.txt:		spi-cpha;
Documentation/devicetree/bindings/iio/accel/lis302.txt: - spi-max-frequency:	maximal bus speed, should be set to 1000000 unless
Documentation/devicetree/bindings/iio/accel/lis302.txt:		spi-max-frequency = <1000000>;
Documentation/devicetree/bindings/iio/temperature/maxim_thermocouple.txt:	- spi-max-frequency: must be 4300000
Documentation/devicetree/bindings/iio/temperature/maxim_thermocouple.txt:	- spi-cpha: must be defined for max6675 to enable SPI mode 1
Documentation/devicetree/bindings/iio/temperature/maxim_thermocouple.txt:	Refer to spi/spi-bus.txt for generic SPI slave bindings.
Documentation/devicetree/bindings/iio/temperature/maxim_thermocouple.txt:		spi-max-frequency = <4300000>;
Documentation/devicetree/bindings/iio/potentiometer/max5481.txt:        Documentation/devicetree/bindings/spi/spi-bus.txt
Documentation/devicetree/bindings/iio/potentiometer/max5481.txt:	spi-max-frequency = <7000000>;
Documentation/devicetree/bindings/iio/potentiometer/mcp4131.txt:        Documentation/devicetree/bindings/spi/spi-bus.txt
Documentation/devicetree/bindings/iio/potentiometer/mcp4131.txt:	spi-max-frequency = <500000>;
Documentation/devicetree/bindings/iio/proximity/as3935.txt:	- spi-max-frequency: specifies maximum SPI clock frequency
Documentation/devicetree/bindings/iio/proximity/as3935.txt:	- spi-cpha: SPI Mode 1. Refer to spi/spi-bus.txt for generic SPI
Documentation/devicetree/bindings/iio/proximity/as3935.txt:	spi-max-frequency = <400000>;
Documentation/devicetree/bindings/iio/proximity/as3935.txt:	spi-cpha;
Documentation/devicetree/bindings/iio/adc/ti-ads7950.txt: - spi-max-frequency: Definition as per
Documentation/devicetree/bindings/iio/adc/ti-ads7950.txt:		Documentation/devicetree/bindings/spi/spi-bus.txt
Documentation/devicetree/bindings/iio/adc/ti-ads7950.txt:	spi-max-frequency = <10000000>;
Documentation/devicetree/bindings/iio/adc/ti-adc161s626.txt: - spi-max-frequency: Definition as per
Documentation/devicetree/bindings/iio/adc/ti-adc161s626.txt:		Documentation/devicetree/bindings/spi/spi-bus.txt
Documentation/devicetree/bindings/iio/adc/ti-adc161s626.txt:	spi-max-frequency = <4300000>;
Documentation/devicetree/bindings/iio/adc/ti-adc0832.txt: - spi-max-frequency: Max SPI frequency to use (< 400000)
Documentation/devicetree/bindings/iio/adc/ti-adc0832.txt:	spi-max-frequency = <200000>;
Documentation/devicetree/bindings/iio/adc/max11100.txt:  - spi-max-frequency: SPI maximum frequency
Documentation/devicetree/bindings/iio/adc/max11100.txt:        spi-max-frequency = <240000>;
Documentation/devicetree/bindings/iio/adc/ti-adc108s102.txt: - spi-max-frequency: Definition as per
Documentation/devicetree/bindings/iio/adc/ti-adc108s102.txt:		Documentation/devicetree/bindings/spi/spi-bus.txt
Documentation/devicetree/bindings/iio/adc/ti-adc108s102.txt:	spi-max-frequency = <1000000>;
Documentation/devicetree/bindings/iio/adc/ti-adc128s052.txt: - spi-max-frequency: Definition as per
Documentation/devicetree/bindings/iio/adc/ti-adc128s052.txt:		Documentation/devicetree/bindings/spi/spi-bus.txt
Documentation/devicetree/bindings/iio/adc/ti-adc128s052.txt:	spi-max-frequency = <1000000>;
Documentation/devicetree/bindings/iio/adc/st,stm32-dfsdm-adc.txt:- spi-max-frequency: Requested only for SPI master mode.
Documentation/devicetree/bindings/iio/adc/mcp320x.txt:        Documentation/devicetree/bindings/spi/spi-bus.txt
Documentation/devicetree/bindings/iio/adc/mcp320x.txt:	- spi-cpha, spi-cpol (boolean):
Documentation/devicetree/bindings/iio/adc/mcp320x.txt:			none or both of spi-cpha, spi-cpol.  The MCP3550/1/3
Documentation/devicetree/bindings/iio/adc/mcp320x.txt:		spi-max-frequency = <1000000>;
Documentation/devicetree/bindings/iio/adc/ti-adc12138.txt: - spi-max-frequency: Definision as per
Documentation/devicetree/bindings/iio/adc/ti-adc12138.txt:	Documentation/devicetree/bindings/spi/spi-bus.txt
Documentation/devicetree/bindings/iio/adc/ti-adc12138.txt:	spi-max-frequency = <5000000>;
Documentation/devicetree/bindings/iio/adc/max1118.txt: - spi-max-frequency: Definition as per
Documentation/devicetree/bindings/iio/adc/max1118.txt:		Documentation/devicetree/bindings/spi/spi-bus.txt
Documentation/devicetree/bindings/iio/adc/max1118.txt:	spi-max-frequency = <1000000>;
Documentation/devicetree/bindings/iio/adc/ti-adc084s021.txt: - spi-cpol          : Per spi-bus bindings
Documentation/devicetree/bindings/iio/adc/ti-adc084s021.txt: - spi-cpha          : Per spi-bus bindings
Documentation/devicetree/bindings/iio/adc/ti-adc084s021.txt: - spi-max-frequency : Per spi-bus bindings
Documentation/devicetree/bindings/iio/adc/ti-adc084s021.txt:	spi-cpol;
Documentation/devicetree/bindings/iio/adc/ti-adc084s021.txt:	spi-cpha;
Documentation/devicetree/bindings/iio/adc/ti-adc084s021.txt:	spi-max-frequency = <16000000>;
Documentation/devicetree/bindings/iio/adc/max1027-adc.txt:- spi-max-frequency: Definition as per
Documentation/devicetree/bindings/iio/adc/max1027-adc.txt:                     Documentation/devicetree/bindings/spi/spi-bus.txt
Documentation/devicetree/bindings/iio/adc/max1027-adc.txt:	spi-max-frequency = <1000000>;
Documentation/devicetree/bindings/iio/adc/hi8435.txt: - spi-max-frequency: definition as per
Documentation/devicetree/bindings/iio/adc/hi8435.txt:		Documentation/devicetree/bindings/spi/spi-bus.txt
Documentation/devicetree/bindings/iio/adc/hi8435.txt:	spi-max-frequency = <1000000>;
Documentation/devicetree/bindings/iio/adc/ti-ads8688.txt: - spi-max-frequency: Definition as per
Documentation/devicetree/bindings/iio/adc/ti-ads8688.txt:		Documentation/devicetree/bindings/spi/spi-bus.txt
Documentation/devicetree/bindings/iio/adc/ti-ads8688.txt:	spi-max-frequency = <1000000>;
Documentation/devicetree/bindings/iio/dac/ti-dac082s085.txt: - spi-cpha, spi-cpol:	SPI mode (0,1) or (1,0) must be used, so specify
Documentation/devicetree/bindings/iio/dac/ti-dac082s085.txt:			either spi-cpha or spi-cpol (but not both).
Documentation/devicetree/bindings/iio/dac/ti-dac082s085.txt:../../spi/spi-bus.txt.
Documentation/devicetree/bindings/iio/dac/ti-dac082s085.txt:		spi-max-frequency = <40000000>;
Documentation/devicetree/bindings/iio/dac/ti-dac082s085.txt:		spi-cpol;
Documentation/devicetree/bindings/iio/dac/ad5592r.txt:	- spi-max-frequency: Max SPI frequency to use (< 30000000)
Documentation/devicetree/bindings/iio/dac/ad5592r.txt:	- spi-cpol: The AD5592R requires inverse clock polarity (CPOL) mode
Documentation/devicetree/bindings/iio/dac/ad5592r.txt:		spi-max-frequency = <1000000>;
Documentation/devicetree/bindings/iio/dac/ad5592r.txt:		spi-cpol;
Documentation/devicetree/bindings/iio/dac/ti,dac7512.txt:Property rules described in Documentation/devicetree/bindings/spi/spi-bus.txt
Documentation/devicetree/bindings/iio/dac/ti,dac7512.txt:apply. In particular, "reg" and "spi-max-frequency" properties must be given.
Documentation/devicetree/bindings/iio/dac/ti,dac7512.txt:			spi-max-frequency = <1000000>;
Documentation/devicetree/bindings/iio/dac/ad5755.txt: - spi-cpha or spi-cpol: is the only modes that is supported
Documentation/devicetree/bindings/iio/dac/ad5755.txt: - spi-max-frequency: Definition as per
Documentation/devicetree/bindings/iio/dac/ad5755.txt:		Documentation/devicetree/bindings/spi/spi-bus.txt
Documentation/devicetree/bindings/iio/dac/ad5755.txt:	spi-max-frequency = <1000000>;
Documentation/devicetree/bindings/iio/dac/ad5755.txt:	spi-cpha;
Documentation/devicetree/bindings/iio/dac/ltc2632.txt:Property rules described in Documentation/devicetree/bindings/spi/spi-bus.txt
Documentation/devicetree/bindings/iio/dac/ltc2632.txt:apply. In particular, "reg" and "spi-max-frequency" properties must be given.
Documentation/devicetree/bindings/iio/dac/ltc2632.txt:			spi-max-frequency = <1000000>;
Documentation/devicetree/bindings/iio/dac/ad7303.txt:	- spi-max-frequency: Max SPI frequency to use (< 30000000)
Documentation/devicetree/bindings/iio/dac/ad7303.txt:			spi-max-frequency = <10000000>;
Documentation/devicetree/bindings/iio/sensorhub.txt:- spi-max-frequency: max SPI clock frequency
Documentation/devicetree/bindings/iio/sensorhub.txt:		spi-max-frequency = <5000000>;
Documentation/devicetree/bindings/iio/health/afe4403.txt:please refer to ../../spi/spi-bus.txt.
Documentation/devicetree/bindings/iio/health/afe4403.txt:		spi-max-frequency = <10000000>;
Documentation/devicetree/bindings/iio/frequency/adf4350.txt:	- spi-max-frequency: Max SPI frequency to use (< 20000000)
Documentation/devicetree/bindings/iio/frequency/adf4350.txt:			spi-max-frequency = <10000000>;
Documentation/devicetree/bindings/iio/imu/bmi160.txt: - spi-max-frequency : set maximum clock frequency (only for SPI)
Documentation/devicetree/bindings/iio/imu/bmi160.txt:	spi-max-frequency = <10000000>;
Documentation/devicetree/bindings/hwmon/lm70.txt:See Documentation/devicetree/bindings/spi/spi-bus.txt for more required and
Documentation/devicetree/bindings/hwmon/lm70.txt:		spi-max-frequency = <1000000>;
Documentation/devicetree/bindings/gpio/gpio-pisosr.txt:nodes please refer to ../spi/spi-bus.txt.
Documentation/devicetree/bindings/gpio/gpio-pisosr.txt:		spi-max-frequency = <1000000>;
Documentation/devicetree/bindings/gpio/gpio-pisosr.txt:		spi-cpol;
Documentation/devicetree/bindings/gpio/gpio-max3191x.txt:../spi/spi-bus.txt.
Documentation/devicetree/bindings/gpio/gpio-max3191x.txt:		spi-max-frequency = <25000000>;
Documentation/devicetree/bindings/gpio/gpio-74x164.txt:	spi-max-frequency = <100000>;
Documentation/devicetree/bindings/gpio/gpio-xra1403.txt:		spi-max-frequency = <1000000>;
Documentation/devicetree/bindings/sound/pcm179x.txt:Documentation/devicetree/bindings/spi/spi-bus.txt
Documentation/devicetree/bindings/sound/pcm179x.txt:		spi-max-frequency = <600000>;
Documentation/devicetree/bindings/sound/ak4104.txt:	spi-max-frequency = <5000000>;
Documentation/devicetree/bindings/sound/cs4271.txt:Documentation/devicetree/bindings/spi/spi-bus.txt
Documentation/devicetree/bindings/sound/cs4271.txt:		spi-max-frequency = <6000000>;
Documentation/devicetree/bindings/dma/qcom_adm.txt:		spi-max-frequency = <50000000>;
Documentation/devicetree/bindings/display/ilitek,ili9225.txt:all mandatory properties described in ../spi/spi-bus.txt must be specified.
Documentation/devicetree/bindings/display/ilitek,ili9225.txt:		spi-max-frequency = <12000000>;
Documentation/devicetree/bindings/display/panel/samsung,ld9040.txt:[2]: Documentation/devicetree/bindings/spi/spi-bus.txt
Documentation/devicetree/bindings/display/panel/samsung,ld9040.txt:		spi-max-frequency = <1200000>;
Documentation/devicetree/bindings/display/panel/samsung,ld9040.txt:		spi-cpol;
Documentation/devicetree/bindings/display/panel/samsung,ld9040.txt:		spi-cpha;
Documentation/devicetree/bindings/display/panel/sitronix,st7789v.txt:[1]: Documentation/devicetree/bindings/spi/spi-bus.txt
Documentation/devicetree/bindings/display/panel/sitronix,st7789v.txt:	spi-max-frequency = <100000>;
Documentation/devicetree/bindings/display/panel/sitronix,st7789v.txt:	spi-cpol;
Documentation/devicetree/bindings/display/panel/sitronix,st7789v.txt:	spi-cpha;
Documentation/devicetree/bindings/display/panel/tpo,td028ttec1.txt:	spi-max-frequency = <100000>;
Documentation/devicetree/bindings/display/panel/tpo,td028ttec1.txt:	spi-cpol;
Documentation/devicetree/bindings/display/panel/tpo,td028ttec1.txt:	spi-cpha;
Documentation/devicetree/bindings/display/panel/sony,acx565akm.txt:	spi-max-frequency = <6000000>;
Documentation/devicetree/bindings/display/panel/tpo,td043mtea1.txt:	spi-max-frequency = <100000>;
Documentation/devicetree/bindings/display/panel/tpo,td043mtea1.txt:	spi-cpol;
Documentation/devicetree/bindings/display/panel/tpo,td043mtea1.txt:	spi-cpha;
Documentation/devicetree/bindings/display/panel/lgphilips,lb035q02.txt:	spi-max-frequency = <100000>;
Documentation/devicetree/bindings/display/panel/lgphilips,lb035q02.txt:	spi-cpol;
Documentation/devicetree/bindings/display/panel/lgphilips,lb035q02.txt:	spi-cpha;
Documentation/devicetree/bindings/display/panel/ilitek,ili9322.txt:spi/spi-bus.txt
Documentation/devicetree/bindings/display/panel/lg,lg4573.txt:[1]: Documentation/devicetree/bindings/spi/spi-bus.txt
Documentation/devicetree/bindings/display/panel/lg,lg4573.txt:		spi-max-frequency = <10000000>;
Documentation/devicetree/bindings/display/sitronix,st7586.txt:all mandatory properties described in ../spi/spi-bus.txt must be specified.
Documentation/devicetree/bindings/display/sitronix,st7586.txt:		spi-max-frequency = <10000000>;
Documentation/devicetree/bindings/display/sitronix,st7735r.txt:all mandatory properties described in ../spi/spi-bus.txt must be specified.
Documentation/devicetree/bindings/display/sitronix,st7735r.txt:		spi-max-frequency = <32000000>;
Documentation/devicetree/bindings/display/repaper.txt:all mandatory properties described in ../spi/spi-bus.txt must be specified.
Documentation/devicetree/bindings/display/repaper.txt:		spi-max-frequency = <8000000>;
Documentation/devicetree/bindings/display/multi-inno,mi0283qt.txt:all mandatory properties described in ../spi/spi-bus.txt must be specified.
Documentation/devicetree/bindings/display/multi-inno,mi0283qt.txt:		spi-max-frequency = <32000000>;
Documentation/devicetree/bindings/mmc/cavium-mmc.txt:- spi-max-frequency : use max-frequency instead
Documentation/devicetree/bindings/mmc/mmc-spi-slot.txt:- spi-max-frequency : maximum frequency for this device (Hz).
Documentation/devicetree/bindings/mmc/mmc-spi-slot.txt:			     "mmc-spi-slot";
Documentation/devicetree/bindings/mmc/mmc-spi-slot.txt:		spi-max-frequency = <50000000>;
Documentation/devicetree/bindings/usb/maxim,max3421.txt: - spi-max-frequency: maximum frequency for this device must not exceed 26 MHz.
Documentation/devicetree/bindings/usb/maxim,max3421.txt:		spi-max-frequency = <26000000>;
Documentation/devicetree/bindings/pinctrl/pinctrl-mcp23s08.txt:        microchip,spi-present-mask below.
Documentation/devicetree/bindings/pinctrl/pinctrl-mcp23s08.txt:- mcp,spi-present-mask (DEPRECATED)
Documentation/devicetree/bindings/pinctrl/pinctrl-mcp23s08.txt:- microchip,spi-present-mask : This is a present flag, that makes only sense for SPI
Documentation/devicetree/bindings/pinctrl/pinctrl-mcp23s08.txt:- spi-max-frequency = The maximum frequency this chip is able to handle
Documentation/devicetree/bindings/pinctrl/pinctrl-mcp23s08.txt:        spi-present-mask = <0x01>;
Documentation/devicetree/bindings/pinctrl/pinctrl-mcp23s08.txt:        spi-max-frequency = <1000000>;
Documentation/devicetree/bindings/pinctrl/marvell,kirkwood-pinctrl.txt:mpp24         24       gpio, ge1(rxd0), ts(mp4), tdm(spi-cs0), audio(sdo)
Documentation/devicetree/bindings/pinctrl/marvell,kirkwood-pinctrl.txt:mpp25         25       gpio, ge1(rxd1), ts(mp5), tdm(spi-sck), audio(lrclk)
Documentation/devicetree/bindings/pinctrl/marvell,kirkwood-pinctrl.txt:mpp26         26       gpio, ge1(rxd2), ts(mp6), tdm(spi-miso), audio(mclk)
Documentation/devicetree/bindings/pinctrl/marvell,kirkwood-pinctrl.txt:mpp27         27       gpio, ge1(rxd3), ts(mp7), tdm(spi-mosi), audio(sdi)
Documentation/devicetree/bindings/pinctrl/marvell,kirkwood-pinctrl.txt:mpp34         34       gpio, ge1(txen), tdm(spi-cs1)
Documentation/devicetree/bindings/pinctrl/marvell,kirkwood-pinctrl.txt:mpp24         24       gpio, ge1(rxd0), ts(mp4), tdm(spi-cs0), audio(sdo)
Documentation/devicetree/bindings/pinctrl/marvell,kirkwood-pinctrl.txt:mpp25         25       gpio, ge1(rxd1), ts(mp5), tdm(spi-sck), audio(lrclk)
Documentation/devicetree/bindings/pinctrl/marvell,kirkwood-pinctrl.txt:mpp26         26       gpio, ge1(rxd2), ts(mp6), tdm(spi-miso), audio(mclk)
Documentation/devicetree/bindings/pinctrl/marvell,kirkwood-pinctrl.txt:mpp27         27       gpio, ge1(rxd3), ts(mp7), tdm(spi-mosi), audio(sdi)
Documentation/devicetree/bindings/pinctrl/marvell,kirkwood-pinctrl.txt:mpp34         34       gpio, ge1(txen), tdm(spi-cs1), sata1(act)
Documentation/devicetree/bindings/pinctrl/marvell,kirkwood-pinctrl.txt:mpp36         36       gpio, ts(mp0), tdm(spi-cs1), audio(spdifi)
Documentation/devicetree/bindings/pinctrl/marvell,kirkwood-pinctrl.txt:mpp39         39       gpio, ts(mp3), tdm(spi-cs0), audio(bclk)
Documentation/devicetree/bindings/pinctrl/marvell,kirkwood-pinctrl.txt:mpp40         40       gpio, ts(mp4), tdm(spi-sck), audio(sdo)
Documentation/devicetree/bindings/pinctrl/marvell,kirkwood-pinctrl.txt:mpp41         41       gpio, ts(mp5), tdm(spi-miso), audio(lrclk)
Documentation/devicetree/bindings/pinctrl/marvell,kirkwood-pinctrl.txt:mpp42         42       gpio, ts(mp6), tdm(spi-mosi), audio(mclk)
Documentation/devicetree/bindings/pinctrl/marvell,kirkwood-pinctrl.txt:mpp24         24       gpio, ge1(rxd0), ts(mp4), tdm(spi-cs0), audio(sdo),
Documentation/devicetree/bindings/pinctrl/marvell,kirkwood-pinctrl.txt:mpp25         25       gpio, ge1(rxd1), ts(mp5), tdm(spi-sck), audio(lrclk),
Documentation/devicetree/bindings/pinctrl/marvell,kirkwood-pinctrl.txt:mpp26         26       gpio, ge1(rxd2), ts(mp6), tdm(spi-miso), audio(mclk),
Documentation/devicetree/bindings/pinctrl/marvell,kirkwood-pinctrl.txt:mpp27         27       gpio, ge1(rxd3), ts(mp7), tdm(spi-mosi), audio(sdi),
Documentation/devicetree/bindings/pinctrl/marvell,kirkwood-pinctrl.txt:mpp34         34       gpio, ge1(txen), tdm(spi-cs1), sata1(act), lcd(d14)
Documentation/devicetree/bindings/pinctrl/marvell,kirkwood-pinctrl.txt:mpp36         36       gpio, ts(mp0), tdm(spi-cs1), audio(spdifi), twsi1(sda)
Documentation/devicetree/bindings/pinctrl/marvell,kirkwood-pinctrl.txt:mpp39         39       gpio, ts(mp3), tdm(spi-cs0), audio(bclk), lcd(d19)
Documentation/devicetree/bindings/pinctrl/marvell,kirkwood-pinctrl.txt:mpp40         40       gpio, ts(mp4), tdm(spi-sck), audio(sdo), lcd(d20)
Documentation/devicetree/bindings/pinctrl/marvell,kirkwood-pinctrl.txt:mpp41         41       gpio, ts(mp5), tdm(spi-miso), audio(lrclk), lcd(d21)
Documentation/devicetree/bindings/pinctrl/marvell,kirkwood-pinctrl.txt:mpp42         42       gpio, ts(mp6), tdm(spi-mosi), audio(mclk), lcd(d22)
Documentation/devicetree/bindings/rtc/maxim-ds1302.txt:- spi-max-frequency : DS-1302 has 500 kHz if powered at 2.2V,
Documentation/devicetree/bindings/rtc/maxim-ds1302.txt:- spi-3wire : The device has a shared signal IN/OUT line.
Documentation/devicetree/bindings/rtc/maxim-ds1302.txt:- spi-lsb-first : DS-1302 requires least significant bit first
Documentation/devicetree/bindings/rtc/maxim-ds1302.txt:- spi-cs-high: DS-1302 has active high chip select line. This is
Documentation/devicetree/bindings/rtc/maxim-ds1302.txt:	compatible = "icpdas,lp8841-spi-rtc";
Documentation/devicetree/bindings/rtc/maxim-ds1302.txt:		spi-max-frequency = <500000>;
Documentation/devicetree/bindings/rtc/maxim-ds1302.txt:		spi-3wire;
Documentation/devicetree/bindings/rtc/maxim-ds1302.txt:		spi-lsb-first;
Documentation/devicetree/bindings/rtc/maxim-ds1302.txt:		spi-cs-high;
Documentation/devicetree/bindings/rtc/sprd,sc27xx-rtc.txt:		spi-max-frequency = <26000000>;
Documentation/devicetree/bindings/rtc/epson,rx6110.txt:  - spi-cs-high: RX6110 needs chipselect high
Documentation/devicetree/bindings/rtc/epson,rx6110.txt:  - spi-cpha: RX6110 works with SPI shifted clock phase
Documentation/devicetree/bindings/rtc/epson,rx6110.txt:  - spi-cpol: RX6110 works with SPI inverse clock polarity
Documentation/devicetree/bindings/rtc/epson,rx6110.txt:		spi-cs-high;
Documentation/devicetree/bindings/rtc/epson,rx6110.txt:		spi-cpha;
Documentation/devicetree/bindings/rtc/epson,rx6110.txt:		spi-cpol;
Documentation/devicetree/bindings/rtc/nxp,rtc-2123.txt:- spi-cs-high: PCF2123 needs chipselect high
Documentation/devicetree/bindings/rtc/nxp,rtc-2123.txt:	spi-cs-high;
Documentation/devicetree/bindings/spi/spi-xlp.txt:properties described in Documentation/devicetree/bindings/spi/spi-bus.txt.
Documentation/devicetree/bindings/spi/spi-xlp.txt:			spi-max-frequency = <40000000>;
Documentation/devicetree/bindings/spi/spi-meson.txt:See ../spi/spi-bus.txt for more details on SPI bus master and slave devices
Documentation/devicetree/bindings/spi/spi-zynqmp-qspi.txt:- compatible		: Should be "xlnx,zynqmp-qspi-1.0".
Documentation/devicetree/bindings/spi/spi-zynqmp-qspi.txt:		compatible = "xlnx,zynqmp-qspi-1.0";
Documentation/devicetree/bindings/spi/brcm,bcm2835-aux-spi.txt:	    see also spi-bus.txt
Documentation/devicetree/bindings/spi/spi-davinci.txt:- ti,davinci-spi-intr-line: interrupt line used to connect the SPI
Documentation/devicetree/bindings/spi/spi-davinci.txt:- ti,spi-wdelay : delay between transmission of words
Documentation/devicetree/bindings/spi/spi-davinci.txt:"ti,spi-wdelay" parameter.
Documentation/devicetree/bindings/spi/spi-davinci.txt:	ti,davinci-spi-intr-line	= <0>;
Documentation/devicetree/bindings/spi/spi-davinci.txt:		spi-max-frequency = <25000000>;
Documentation/devicetree/bindings/spi/spi-davinci.txt:		ti,spi-wdelay = <8>;
Documentation/devicetree/bindings/spi/spi-dw.txt:- #address-cells: see spi-bus.txt
Documentation/devicetree/bindings/spi/spi-dw.txt:- #size-cells: see spi-bus.txt
Documentation/devicetree/bindings/spi/spi-dw.txt:- num-cs: see spi-bus.txt
Documentation/devicetree/bindings/spi/spi-dw.txt:- cs-gpios: see spi-bus.txt
Documentation/devicetree/bindings/spi/fsl-imx-cspi.txt:- cs-gpios : GPIOs to use as chip selects, see spi-bus.txt.  While the native chip
Documentation/devicetree/bindings/spi/fsl-imx-cspi.txt:- num-cs :  Number of total chip selects, see spi-bus.txt.
Documentation/devicetree/bindings/spi/fsl-imx-cspi.txt:- fsl,spi-rdy-drctl: Integer, representing the value of DRCTL, the register
Documentation/devicetree/bindings/spi/fsl-imx-cspi.txt:- fsl,spi-num-chipselects : Contains the number of the chipselect
Documentation/devicetree/bindings/spi/fsl-imx-cspi.txt:	fsl,spi-rdy-drctl = <1>;
Documentation/devicetree/bindings/spi/nvidia,tegra20-slink.txt:- spi-max-frequency: Definition as per
Documentation/devicetree/bindings/spi/nvidia,tegra20-slink.txt:                     Documentation/devicetree/bindings/spi/spi-bus.txt
Documentation/devicetree/bindings/spi/nvidia,tegra20-slink.txt:	spi-max-frequency = <25000000>;
Documentation/devicetree/bindings/spi/efm32-spi.txt:- #address-cells: see spi-bus.txt
Documentation/devicetree/bindings/spi/efm32-spi.txt:- #size-cells: see spi-bus.txt
Documentation/devicetree/bindings/spi/efm32-spi.txt:- cs-gpios: see spi-bus.txt
Documentation/devicetree/bindings/spi/efm32-spi.txt:		spi-max-frequency = <6000000>;
Documentation/devicetree/bindings/spi/adi,axi-spi-engine.txt:- compatible		: Must be "adi,axi-spi-engine-1.00.a""
Documentation/devicetree/bindings/spi/adi,axi-spi-engine.txt:	master. They follow the generic SPI bindings as outlined in spi-bus.txt.
Documentation/devicetree/bindings/spi/adi,axi-spi-engine.txt:		compatible = "adi,axi-spi-engine-1.00.a";
Documentation/devicetree/bindings/spi/qcom,spi-qup.txt:		  "qcom,spi-qup-v1.1.1" for 8660, 8960 and 8064.
Documentation/devicetree/bindings/spi/qcom,spi-qup.txt:		  "qcom,spi-qup-v2.1.1" for 8974 and later
Documentation/devicetree/bindings/spi/qcom,spi-qup.txt:		  "qcom,spi-qup-v2.2.1" for 8974 v2 and later.
Documentation/devicetree/bindings/spi/qcom,spi-qup.txt:- spi-max-frequency: Specifies maximum SPI clock frequency,
Documentation/devicetree/bindings/spi/qcom,spi-qup.txt:                     Documentation/devicetree/bindings/spi/spi-bus.txt
Documentation/devicetree/bindings/spi/qcom,spi-qup.txt:properties described in Documentation/devicetree/bindings/spi/spi-bus.txt
Documentation/devicetree/bindings/spi/qcom,spi-qup.txt:		compatible = "qcom,spi-qup-v2";
Documentation/devicetree/bindings/spi/qcom,spi-qup.txt:		spi-max-frequency = <19200000>;
Documentation/devicetree/bindings/spi/qcom,spi-qup.txt:			spi-max-frequency = <19200000>;
Documentation/devicetree/bindings/spi/qcom,spi-qup.txt:			spi-cpol;
Documentation/devicetree/bindings/spi/qcom,spi-qup.txt:			spi-max-frequency = <9600000>;
Documentation/devicetree/bindings/spi/qcom,spi-qup.txt:			spi-cpha;
Documentation/devicetree/bindings/spi/qcom,spi-qup.txt:			spi-max-frequency = <19200000>;
Documentation/devicetree/bindings/spi/qcom,spi-qup.txt:			spi-cpol;
Documentation/devicetree/bindings/spi/qcom,spi-qup.txt:			spi-cpha;
Documentation/devicetree/bindings/spi/qcom,spi-qup.txt:			spi-max-frequency = <19200000>;
Documentation/devicetree/bindings/spi/qcom,spi-qup.txt:			spi-cpol;
Documentation/devicetree/bindings/spi/qcom,spi-qup.txt:			spi-cpha;
Documentation/devicetree/bindings/spi/qcom,spi-qup.txt:			spi-cs-high;
Documentation/devicetree/bindings/spi/spi_altera.txt:- compatible : should be "ALTR,spi-1.0". <DEPRECATED>
Documentation/devicetree/bindings/spi/spi_altera.txt:- compatible : should be "altr,spi-1.0".
Documentation/devicetree/bindings/spi/spi_atmel.txt:		compatible = "mmc-spi-slot";
Documentation/devicetree/bindings/spi/spi_atmel.txt:		spi-max-frequency = <25000000>;
Documentation/devicetree/bindings/spi/spi-samsung.txt:  "samsung,spi-src-clk"), while Exynos5433 should specify a third clock
Documentation/devicetree/bindings/spi/spi-samsung.txt:- samsung,spi-src-clk: If the spi controller includes a internal clock mux to
Documentation/devicetree/bindings/spi/spi-samsung.txt:- cs-gpios: should specify GPIOs used for chipselects (see spi-bus.txt)
Documentation/devicetree/bindings/spi/spi-samsung.txt:  - samsung,spi-feedback-delay: The sampling phase shift to be applied on the
Documentation/devicetree/bindings/spi/spi-samsung.txt:			spi-max-frequency = <10000>;
Documentation/devicetree/bindings/spi/spi-samsung.txt:				samsung,spi-feedback-delay = <0>;
Documentation/devicetree/bindings/spi/spi-rspi.txt:		     "renesas,rspi-<soctype>", "renesas,rspi" as fallback.
Documentation/devicetree/bindings/spi/spi-rspi.txt:		     "renesas,rspi-<soctype>", "renesas,rspi-rz" as fallback.
Documentation/devicetree/bindings/spi/spi-rspi.txt:		     "renesas,qspi-<soctype>", "renesas,qspi" as fallback.
Documentation/devicetree/bindings/spi/spi-rspi.txt:		        - "renesas,rspi-sh7757" (SH)
Documentation/devicetree/bindings/spi/spi-rspi.txt:			- "renesas,rspi-r7s72100" (RZ/A1H)
Documentation/devicetree/bindings/spi/spi-rspi.txt:			- "renesas,qspi-r8a7743" (RZ/G1M)
Documentation/devicetree/bindings/spi/spi-rspi.txt:			- "renesas,qspi-r8a7745" (RZ/G1E)
Documentation/devicetree/bindings/spi/spi-rspi.txt:			- "renesas,qspi-r8a7790" (R-Car H2)
Documentation/devicetree/bindings/spi/spi-rspi.txt:			- "renesas,qspi-r8a7791" (R-Car M2-W)
Documentation/devicetree/bindings/spi/spi-rspi.txt:			- "renesas,qspi-r8a7792" (R-Car V2H)
Documentation/devicetree/bindings/spi/spi-rspi.txt:			- "renesas,qspi-r8a7793" (R-Car M2-N)
Documentation/devicetree/bindings/spi/spi-rspi.txt:			- "renesas,qspi-r8a7794" (R-Car E2)
Documentation/devicetree/bindings/spi/spi-rspi.txt:		compatible = "renesas,rspi-r7s72100", "renesas,rspi-rz";
Documentation/devicetree/bindings/spi/spi-rspi.txt:		compatible = "renesas,qspi-r8a7791", "renesas,qspi";
Documentation/devicetree/bindings/spi/icpdas-lp8841-spi-rtc.txt:- compatible: should be "icpdas,lp8841-spi-rtc"
Documentation/devicetree/bindings/spi/icpdas-lp8841-spi-rtc.txt:  - spi-3wire: The master itself has only 3 wire. It cannor work in
Documentation/devicetree/bindings/spi/icpdas-lp8841-spi-rtc.txt:  - spi-cs-high: DS-1302 has active high chip select line. The master
Documentation/devicetree/bindings/spi/icpdas-lp8841-spi-rtc.txt:  - spi-lsb-first: DS-1302 requires least significant bit first
Documentation/devicetree/bindings/spi/icpdas-lp8841-spi-rtc.txt:	compatible = "icpdas,lp8841-spi-rtc";
Documentation/devicetree/bindings/spi/icpdas-lp8841-spi-rtc.txt:		spi-max-frequency = <500000>;
Documentation/devicetree/bindings/spi/icpdas-lp8841-spi-rtc.txt:		spi-3wire;
Documentation/devicetree/bindings/spi/icpdas-lp8841-spi-rtc.txt:		spi-lsb-first;
Documentation/devicetree/bindings/spi/icpdas-lp8841-spi-rtc.txt:		spi-cs-high;
Documentation/devicetree/bindings/spi/nvidia,tegra114-spi.txt:- spi-max-frequency: Definition as per
Documentation/devicetree/bindings/spi/nvidia,tegra114-spi.txt:                     Documentation/devicetree/bindings/spi/spi-bus.txt
Documentation/devicetree/bindings/spi/nvidia,tegra114-spi.txt:	spi-max-frequency = <25000000>;
Documentation/devicetree/bindings/spi/spi_oc_tiny.txt:- compatible : should be "opencores,tiny-spi-rtlsvn2".
Documentation/devicetree/bindings/spi/omap-spi.txt:- ti,spi-num-cs : Number of chipselect supported  by the instance.
Documentation/devicetree/bindings/spi/omap-spi.txt:    ti,spi-num-cs = <4>;
Documentation/devicetree/bindings/spi/omap-spi.txt:    ti,spi-num-cs = <2>;
Documentation/devicetree/bindings/spi/spi-lantiq-ssc.txt:- #address-cells: see spi-bus.txt
Documentation/devicetree/bindings/spi/spi-lantiq-ssc.txt:- #size-cells: see spi-bus.txt
Documentation/devicetree/bindings/spi/spi-lantiq-ssc.txt:- num-cs: see spi-bus.txt, set to 8 if unset
Documentation/devicetree/bindings/spi/spi-octeon.txt:			spi-max-frequency = <5000000>;
Documentation/devicetree/bindings/spi/spi-octeon.txt:			spi-cpha;
Documentation/devicetree/bindings/spi/spi-octeon.txt:			spi-cpol;
Documentation/devicetree/bindings/spi/spi-clps711x.txt:	    See: Documentation/devicetree/bindings/spi/spi-bus.txt
Documentation/devicetree/bindings/spi/jcore,spi.txt:See spi-bus.txt for additional properties not specific to this device.
Documentation/devicetree/bindings/spi/jcore,spi.txt:	spi-max-frequency = <25000000>;
Documentation/devicetree/bindings/spi/spi-st-ssc.txt:		    See ../spi/spi-bus.txt
Documentation/devicetree/bindings/spi/spi-st-ssc.txt:  See ../spi/spi-bus.txt
Documentation/devicetree/bindings/spi/spi-st-ssc.txt:			spi-max-frequency	= <1000000>;
Documentation/devicetree/bindings/spi/spi_pl022.txt:			spi-max-frequency = <12000000>;
Documentation/devicetree/bindings/spi/spi_pl022.txt:			spi-cpol;
Documentation/devicetree/bindings/spi/spi_pl022.txt:			spi-cpha;
Documentation/devicetree/bindings/spi/sh-msiof.txt:			     same spi-cs-high configuration.  Use cs-gpios to
Documentation/devicetree/bindings/spi/sh-msiof.txt:- spi-slave            : Empty property indicating the SPI controller is used
Documentation/devicetree/bindings/spi/microchip,spi-pic32.txt:            See: Documentation/devicetree/bindings/spi/spi-bus.txt
Documentation/devicetree/bindings/spi/microchip,spi-pic32.txt:             named "spi-tx" for transmit and named "spi-rx" for receive.
Documentation/devicetree/bindings/spi/microchip,spi-pic32.txt:        dma-names = "spi-rx", "spi-tx";
Documentation/devicetree/bindings/spi/brcm,spi-bcm-qspi.txt:    "brcm,spi-bcm-qspi", "brcm,spi-brcmstb-qspi" : MSPI+BSPI on BRCMSTB SoCs
Documentation/devicetree/bindings/spi/brcm,spi-bcm-qspi.txt:    "brcm,spi-bcm-qspi", "brcm,spi-brcmstb-mspi" : Second Instance of MSPI
Documentation/devicetree/bindings/spi/brcm,spi-bcm-qspi.txt:    "brcm,spi-bcm-qspi", "brcm,spi-nsp-qspi"     : MSPI+BSPI on Cygnus, NSP
Documentation/devicetree/bindings/spi/brcm,spi-bcm-qspi.txt:    "brcm,spi-bcm-qspi", "brcm,spi-ns2-qspi"     : NS2 SoCs
Documentation/devicetree/bindings/spi/brcm,spi-bcm-qspi.txt:		   "spi-brcmstb-mspi"
Documentation/devicetree/bindings/spi/brcm,spi-bcm-qspi.txt:- spi-rx-bus-width: Definition as per
Documentation/devicetree/bindings/spi/brcm,spi-bcm-qspi.txt:                    Documentation/devicetree/bindings/spi/spi-bus.txt
Documentation/devicetree/bindings/spi/brcm,spi-bcm-qspi.txt:		compatible = "brcm,spi-brcmstb-qspi", "brcm,spi-brcmstb-qspi";
Documentation/devicetree/bindings/spi/brcm,spi-bcm-qspi.txt:			spi-max-frequency = <0x2625a00>;
Documentation/devicetree/bindings/spi/brcm,spi-bcm-qspi.txt:			spi-cpol;
Documentation/devicetree/bindings/spi/brcm,spi-bcm-qspi.txt:			spi-cpha;
Documentation/devicetree/bindings/spi/brcm,spi-bcm-qspi.txt:		compatible = "brcm,spi-brcmstb-qspi", "brcm,spi-brcmstb-mspi";
Documentation/devicetree/bindings/spi/brcm,spi-bcm-qspi.txt:	compatible = "brcm,spi-bcm-qspi", "brcm,spi-nsp-qspi";
Documentation/devicetree/bindings/spi/brcm,spi-bcm-qspi.txt:		       compatible = "brcm,spi-bcm-qspi", "brcm,spi-ns2-qspi";
Documentation/devicetree/bindings/spi/brcm,spi-bcm-qspi.txt:		      spi-max-frequency = <12500000>;
Documentation/devicetree/bindings/spi/brcm,spi-bcm-qspi.txt:		      spi-cpol;
Documentation/devicetree/bindings/spi/brcm,spi-bcm-qspi.txt:		      spi-cpha;
Documentation/devicetree/bindings/spi/ti_qspi.txt:- spi-max-frequency: Definition as per
Documentation/devicetree/bindings/spi/ti_qspi.txt:                     Documentation/devicetree/bindings/spi/spi-bus.txt
Documentation/devicetree/bindings/spi/ti_qspi.txt:operation. Hence, "spi-cpol" and "spi-cpha" DT properties cannot be
Documentation/devicetree/bindings/spi/ti_qspi.txt:	spi-max-frequency = <25000000>;
Documentation/devicetree/bindings/spi/ti_qspi.txt:	spi-max-frequency = <48000000>;
Documentation/devicetree/bindings/spi/spi-xilinx.txt:- compatible		: Should be "xlnx,xps-spi-2.00.a", "xlnx,xps-spi-2.00.b" or "xlnx,axi-quad-spi-1.00.a"
Documentation/devicetree/bindings/spi/spi-xilinx.txt:			compatible = "xlnx,xps-spi-2.00.a";
Documentation/devicetree/bindings/spi/spi-mt65xx.txt:  muxes clock, and "spi-clk" for the clock gate.
Documentation/devicetree/bindings/spi/spi-mt65xx.txt:-cs-gpios: see spi-bus.txt.
Documentation/devicetree/bindings/spi/spi-mt65xx.txt:	clock-names = "parent-clk", "sel-clk", "spi-clk";
Documentation/devicetree/bindings/spi/spi-fsl-dspi.txt:- spi-num-chipselects : the number of the chipselect signals.
Documentation/devicetree/bindings/spi/spi-fsl-dspi.txt:- fsl,spi-cs-sck-delay: a delay in nanoseconds between activating chip
Documentation/devicetree/bindings/spi/spi-fsl-dspi.txt:- fsl,spi-sck-cs-delay: a delay in nanoseconds between stopping the clock
Documentation/devicetree/bindings/spi/spi-fsl-dspi.txt:	spi-num-chipselects = <5>;
Documentation/devicetree/bindings/spi/spi-fsl-dspi.txt:		spi-max-frequency = <16000000>;
Documentation/devicetree/bindings/spi/spi-fsl-dspi.txt:		spi-cpol;
Documentation/devicetree/bindings/spi/spi-fsl-dspi.txt:		spi-cpha;
Documentation/devicetree/bindings/spi/spi-fsl-dspi.txt:		fsl,spi-cs-sck-delay = <100>;
Documentation/devicetree/bindings/spi/spi-fsl-dspi.txt:		fsl,spi-sck-cs-delay = <50>;
Documentation/devicetree/bindings/spi/spi-stm32.txt:  Documentation/devicetree/bindings/spi/spi-bus.txt
Documentation/devicetree/bindings/spi/spi-stm32.txt:  See ../spi/spi-bus.txt
Documentation/devicetree/bindings/spi/spi-stm32.txt:- st,spi-midi-ns: (Master Inter-Data Idleness) minimum time delay in
Documentation/devicetree/bindings/spi/spi-stm32.txt:			spi-max-frequency = <4000000>;
Documentation/devicetree/bindings/spi/spi-stm32.txt:			st,spi-midi-ns = <4000>;
Documentation/devicetree/bindings/spi/spi-sirf.txt:- spi-max-frequency: Specifies maximum SPI clock frequency,
Documentation/devicetree/bindings/spi/spi-sirf.txt:                     Documentation/devicetree/bindings/spi/spi-bus.txt
Documentation/devicetree/bindings/spi/fsl-spi.txt:- fsl,espi-num-chipselects : the number of the chipselect signals.
Documentation/devicetree/bindings/spi/fsl-spi.txt:		fsl,espi-num-chipselects = <4>;
Documentation/devicetree/bindings/spi/spi-cadence.txt:- compatible		: Should be "cdns,spi-r1p6" or "xlnx,zynq-spi-r1p6".
Documentation/devicetree/bindings/spi/spi-cadence.txt:		compatible = "xlnx,zynq-spi-r1p6";
Documentation/devicetree/bindings/spi/nvidia,tegra20-sflash.txt:- spi-max-frequency: Definition as per
Documentation/devicetree/bindings/spi/nvidia,tegra20-sflash.txt:                     Documentation/devicetree/bindings/spi/spi-bus.txt
Documentation/devicetree/bindings/spi/nvidia,tegra20-sflash.txt:	spi-max-frequency = <25000000>;
Documentation/devicetree/bindings/spi/spi-gpio.txt: - compatible: should be set to "spi-gpio"
Documentation/devicetree/bindings/spi/spi-gpio.txt:		compatible = "spi-gpio";
Documentation/devicetree/bindings/spi/spi-sprd-adi.txt:properties described in Documentation/devicetree/bindings/spi/spi-bus.txt.
Documentation/devicetree/bindings/spi/sh-hspi.txt:- compatible       : "renesas,hspi-<soctype>", "renesas,hspi" as fallback.
Documentation/devicetree/bindings/spi/sh-hspi.txt:		       - "renesas,hspi-r8a7778" (R-Car M1)
Documentation/devicetree/bindings/spi/sh-hspi.txt:		       - "renesas,hspi-r8a7779" (R-Car H1)
Documentation/devicetree/bindings/spi/sh-hspi.txt:		compatible = "renesas,hspi-r8a7778", "renesas,hspi";
Documentation/devicetree/bindings/spi/spi-bus.txt:- spi-slave       - Empty property.
Documentation/devicetree/bindings/spi/spi-bus.txt:- spi-max-frequency - Maximum SPI clocking speed of device in Hz.
Documentation/devicetree/bindings/spi/spi-bus.txt:- spi-cpol        - Empty property indicating device requires inverse clock
Documentation/devicetree/bindings/spi/spi-bus.txt:- spi-cpha        - Empty property indicating device requires shifted clock
Documentation/devicetree/bindings/spi/spi-bus.txt:- spi-cs-high     - Empty property indicating device requires chip select
Documentation/devicetree/bindings/spi/spi-bus.txt:- spi-3wire       - Empty property indicating device requires 3-wire mode.
Documentation/devicetree/bindings/spi/spi-bus.txt:- spi-lsb-first   - Empty property indicating device requires LSB first mode.
Documentation/devicetree/bindings/spi/spi-bus.txt:- spi-tx-bus-width - The bus width (number of data wires) that is used for MOSI.
Documentation/devicetree/bindings/spi/spi-bus.txt:- spi-rx-bus-width - The bus width (number of data wires) that is used for MISO.
Documentation/devicetree/bindings/spi/spi-bus.txt:- spi-rx-delay-us - Microsecond delay after a read transfer.
Documentation/devicetree/bindings/spi/spi-bus.txt:- spi-tx-delay-us - Microsecond delay after a write transfer.
Documentation/devicetree/bindings/spi/spi-bus.txt:Now the value that spi-tx-bus-width and spi-rx-bus-width can receive is
Documentation/devicetree/bindings/spi/spi-bus.txt:			spi-max-frequency = <1000000>;
Documentation/devicetree/bindings/spi/spi-bus.txt:			spi-max-frequency = <100000>;
Documentation/devicetree/bindings/arm/altera/socfpga-eccmgr.txt:- compatible      : Should be "altr,socfpga-qspi-ecc"
Documentation/devicetree/bindings/arm/altera/socfpga-eccmgr.txt:		qspi-ecc@ff8c8400 {
Documentation/devicetree/bindings/arm/altera/socfpga-eccmgr.txt:			compatible = "altr,socfpga-qspi-ecc";
Documentation/devicetree/bindings/input/rmi4/rmi_spi.txt:- spi-rx-delay-us: microsecond delay after a read transfer.
Documentation/devicetree/bindings/input/rmi4/rmi_spi.txt:- spi-tx-delay-us: microsecond delay after a write transfer.
Documentation/devicetree/bindings/input/rmi4/rmi_spi.txt:		rmi4-spi-dev@0 {
Documentation/devicetree/bindings/input/rmi4/rmi_spi.txt:			spi-max-frequency = <4000000>;
Documentation/devicetree/bindings/input/rmi4/rmi_spi.txt:			spi-cpha;
Documentation/devicetree/bindings/input/rmi4/rmi_spi.txt:			spi-cpol;
Documentation/devicetree/bindings/input/rmi4/rmi_spi.txt:			spi-rx-delay-us = <30>;
Documentation/devicetree/bindings/input/touchscreen/ad7879.txt:				  See spi-bus.txt for more SPI slave properties
Documentation/devicetree/bindings/input/touchscreen/ad7879.txt:		spi-max-frequency = <5000000>;
Documentation/devicetree/bindings/input/touchscreen/ad7879.txt:		spi-cpol;
Documentation/devicetree/bindings/input/touchscreen/ad7879.txt:		spi-cpha;
Documentation/devicetree/bindings/input/touchscreen/ads7846.txt:	Documentation/devicetree/bindings/spi/spi-bus.txt
Documentation/devicetree/bindings/input/touchscreen/ads7846.txt:			spi-max-frequency = <1000000>;
Documentation/devicetree/bindings/input/touchscreen/cyttsp.txt: - spi-max-frequency	: Maximum SPI clocking speed of the device (for cyttsp-spi)
Documentation/devicetree/bindings/input/touchscreen/cyttsp.txt:			spi-max-frequency = <6000000>;
Documentation/devicetree/bindings/input/touchscreen/tsc2005.txt: - spi-max-frequency	      : Maximum SPI clocking speed of the device
Documentation/devicetree/bindings/input/touchscreen/tsc2005.txt:		spi-max-frequency = <6000000>;
Documentation/devicetree/bindings/leds/leds-bcm6358.txt:which can either be controlled by software (exporting the 74x164 as spi-gpio.
Documentation/devicetree/bindings/leds/irled/spi-ir-led.txt:	- compatible: should be "ir-spi-led".
Documentation/devicetree/bindings/leds/irled/spi-ir-led.txt:		compatible = "ir-spi-led";
Documentation/devicetree/bindings/leds/irled/spi-ir-led.txt:		spi-max-frequency = <5000000>;
Documentation/devicetree/bindings/leds/leds-bcm6328.txt:as spi-gpio. See Documentation/devicetree/bindings/gpio/gpio-74x164.txt), or
Documentation/devicetree/bindings/leds/leds-bcm6328.txt:exporting the 74x164 as spi-gpio prevents those LEDs to be hardware
Documentation/devicetree/bindings/eeprom/at25.txt:- spi-max-frequency : max spi frequency to use
Documentation/devicetree/bindings/eeprom/at25.txt:- spi-cpha : SPI shifted clock phase, as per spi-bus bindings.
Documentation/devicetree/bindings/eeprom/at25.txt:- spi-cpol : SPI inverse clock polarity, as per spi-bus bindings.
Documentation/devicetree/bindings/eeprom/at25.txt:		spi-max-frequency = <5000000>;
Documentation/devicetree/bindings/eeprom/at25.txt:		spi-cpha;
Documentation/devicetree/bindings/eeprom/at25.txt:		spi-cpol;
Documentation/devicetree/bindings/mtd/jedec,spi-nor.txt:               Must also include "jedec,spi-nor" for any SPI NOR flash that can
Documentation/devicetree/bindings/mtd/jedec,spi-nor.txt:- spi-max-frequency : Maximum frequency of the SPI bus the chip can operate at
Documentation/devicetree/bindings/mtd/jedec,spi-nor.txt:		compatible = "spansion,m25p80", "jedec,spi-nor";
Documentation/devicetree/bindings/mtd/jedec,spi-nor.txt:		spi-max-frequency = <40000000>;
Documentation/devicetree/bindings/mtd/mtk-quadspi.txt:compatible property. Also see jedec,spi-nor.txt.
Documentation/devicetree/bindings/mtd/mtk-quadspi.txt:		  and name of the chip. Must also include "jedec,spi-nor" for any
Documentation/devicetree/bindings/mtd/mtk-quadspi.txt:		compatible = "jedec,spi-nor";
Documentation/devicetree/bindings/mtd/st-fsm.txt:  - compatible : Should be "st,spi-fsm"
Documentation/devicetree/bindings/mtd/st-fsm.txt:  - reg-names  : Should contain the reg names "spi-fsm"
Documentation/devicetree/bindings/mtd/st-fsm.txt:	        compatible         = "st,spi-fsm";
Documentation/devicetree/bindings/mtd/st-fsm.txt:	        reg-names          = "spi-fsm";
Documentation/devicetree/bindings/mtd/stm32-quadspi.txt:properties. Also see jedec,spi-nor.txt.
Documentation/devicetree/bindings/mtd/stm32-quadspi.txt:- spi-max-frequency: max frequency of spi bus
Documentation/devicetree/bindings/mtd/stm32-quadspi.txt:- spi-rx-bus-width: see ../spi/spi-bus.txt for the description
Documentation/devicetree/bindings/mtd/stm32-quadspi.txt:		spi-rx-bus-width = <4>;
Documentation/devicetree/bindings/mtd/stm32-quadspi.txt:		spi-max-frequency = <108000000>;
Documentation/devicetree/bindings/mtd/cadence-quadspi.txt:	Generic default - "cdns,qspi-nor".
Documentation/devicetree/bindings/mtd/cadence-quadspi.txt:	For TI 66AK2G SoC - "ti,k2g-qspi", "cdns,qspi-nor".
Documentation/devicetree/bindings/mtd/cadence-quadspi.txt:		compatible = "cdns,qspi-nor";
Documentation/devicetree/bindings/mtd/nxp-spifi.txt:compatible property as specified in bindings/mtd/jedec,spi-nor.txt
Documentation/devicetree/bindings/mtd/nxp-spifi.txt: - spi-cpol : Controller only supports mode 0 and 3 so either
Documentation/devicetree/bindings/mtd/nxp-spifi.txt:              both spi-cpol and spi-cpha should be present or
Documentation/devicetree/bindings/mtd/nxp-spifi.txt: - spi-cpha : See above
Documentation/devicetree/bindings/mtd/nxp-spifi.txt: - spi-rx-bus-width : Used to select how many pins that are used
Documentation/devicetree/bindings/mtd/nxp-spifi.txt:See bindings/spi/spi-bus.txt for more information.
Documentation/devicetree/bindings/mtd/nxp-spifi.txt:		compatible = "jedec,spi-nor";
Documentation/devicetree/bindings/mtd/nxp-spifi.txt:		spi-cpol;
Documentation/devicetree/bindings/mtd/nxp-spifi.txt:		spi-cpha;
Documentation/devicetree/bindings/mtd/nxp-spifi.txt:		spi-rx-bus-width = <4>;
Documentation/devicetree/bindings/mtd/fsl-quadspi.txt:  - fsl,qspi-has-second-chip: The controller has two buses, bus A and bus B.
Documentation/devicetree/bindings/mtd/microchip,mchp23k256.txt:- spi-max-frequency : Maximum frequency of the SPI bus the chip can operate at
Documentation/devicetree/bindings/mtd/microchip,mchp23k256.txt:	spi-sram@0 {
Documentation/devicetree/bindings/mtd/microchip,mchp23k256.txt:		spi-max-frequency = <20000000>;
Documentation/devicetree/bindings/mtd/aspeed-smc.txt:property as specified in bindings/mtd/jedec,spi-nor.txt
Documentation/devicetree/bindings/mtd/aspeed-smc.txt:  - spi-max-frequency - max frequency of spi bus
Documentation/devicetree/bindings/mtd/aspeed-smc.txt:		compatible = "jedec,spi-nor";
Documentation/devicetree/bindings/mtd/aspeed-smc.txt:		/* spi-max-frequency = <>; */
Documentation/devicetree/bindings/mtd/hisilicon,fmc-spi-nor.txt:- compatible : Should be "hisilicon,fmc-spi-nor" and one of the following strings:
Documentation/devicetree/bindings/mtd/hisilicon,fmc-spi-nor.txt:		"hisilicon,hi3519-spi-nor"
Documentation/devicetree/bindings/mtd/hisilicon,fmc-spi-nor.txt:- clocks : handle to spi-nor flash controller clock.
Documentation/devicetree/bindings/mtd/hisilicon,fmc-spi-nor.txt:spi-nor-controller@10000000 {
Documentation/devicetree/bindings/mtd/hisilicon,fmc-spi-nor.txt:	compatible = "hisilicon,hi3519-spi-nor", "hisilicon,fmc-spi-nor";
Documentation/devicetree/bindings/mtd/hisilicon,fmc-spi-nor.txt:	spi-nor@0 {
Documentation/devicetree/bindings/mtd/hisilicon,fmc-spi-nor.txt:		compatible = "jedec,spi-nor";
Documentation/devicetree/bindings/mtd/atmel-dataflash.txt:	spi-max-frequency = <25000000>;
Documentation/devicetree/bindings/soc/qcom/qcom,gsbi.txt:Documentation/devicetree/bindings/spi/qcom,spi-qup.txt
Documentation/devicetree/bindings/net/qca,qca7000.txt:- spi-cpha	    : Must be set
Documentation/devicetree/bindings/net/qca,qca7000.txt:- spi-cpol	    : Must be set
Documentation/devicetree/bindings/net/qca,qca7000.txt:- spi-max-frequency : Maximum frequency of the SPI bus the chip can operate at.
Documentation/devicetree/bindings/net/qca,qca7000.txt:		spi-cpha;                         /* SPI mode: CPHA=1 */
Documentation/devicetree/bindings/net/qca,qca7000.txt:		spi-cpol;                         /* SPI mode: CPOL=1 */
Documentation/devicetree/bindings/net/qca,qca7000.txt:		spi-max-frequency = <8000000>;    /* freq: 8 MHz */
Documentation/devicetree/bindings/net/maxim,ds26522.txt:- spi-max-frequency: SPI clock.
Documentation/devicetree/bindings/net/maxim,ds26522.txt:		spi-max-frequency = <2000000>; /* input clock */
Documentation/devicetree/bindings/net/ieee802154/cc2520.txt:	- spi-max-frequency:	maximal bus speed (8000000), should be set to 4000000 depends
Documentation/devicetree/bindings/net/ieee802154/cc2520.txt:		spi-max-frequency = <4000000>;
Documentation/devicetree/bindings/net/ieee802154/ca8210.txt:	- spi-max-frequency:    Maximum clock speed, should be *less than*
Documentation/devicetree/bindings/net/ieee802154/ca8210.txt:	- spi-cpol:             Requires inverted clock polarity
Documentation/devicetree/bindings/net/ieee802154/ca8210.txt:		spi-max-frequency = <3000000>;
Documentation/devicetree/bindings/net/ieee802154/ca8210.txt:		spi-cpol;
Documentation/devicetree/bindings/net/ieee802154/mrf24j40.txt:  - spi-max-frequency:	maximal bus speed, should be set something under or equal
Documentation/devicetree/bindings/net/ieee802154/mrf24j40.txt:		spi-max-frequency = <8500000>;
Documentation/devicetree/bindings/net/ieee802154/adf7242.txt:  - spi-max-frequency:	maximal bus speed (12.5 MHz)
Documentation/devicetree/bindings/net/ieee802154/adf7242.txt:		spi-max-frequency = <10000000>;
Documentation/devicetree/bindings/net/ieee802154/at86rf230.txt:  - spi-max-frequency:	maximal bus speed, should be set to 7500000 depends
Documentation/devicetree/bindings/net/ieee802154/at86rf230.txt:		spi-max-frequency = <7500000>;
Documentation/devicetree/bindings/net/micrel-ks8995.txt:Required properties (according to spi-bus.txt):
Documentation/devicetree/bindings/net/micrel-ks8995.txt:spi-master {
Documentation/devicetree/bindings/net/micrel-ks8995.txt:		spi-max-frequency = <50000000>;
Documentation/devicetree/bindings/net/nfc/nfcmrvl.txt:		spi-max-frequency = <3000000>;
Documentation/devicetree/bindings/net/nfc/nfcmrvl.txt:		spi-cpha;
Documentation/devicetree/bindings/net/nfc/nfcmrvl.txt:		spi-cpol;
Documentation/devicetree/bindings/net/nfc/trf7970a.txt:- spi-max-frequency: Maximum SPI frequency (<= 2000000).
Documentation/devicetree/bindings/net/nfc/trf7970a.txt:		spi-max-frequency = <2000000>;
Documentation/devicetree/bindings/net/nfc/st-nci-spi.txt:- spi-max-frequency: Maximum SPI frequency (<= 4000000).
Documentation/devicetree/bindings/net/nfc/st95hf.txt:- spi-max-frequency: Max. operating SPI frequency for ST95HF
Documentation/devicetree/bindings/net/nfc/st95hf.txt:		spi-max-frequency = <1000000>;
Documentation/devicetree/bindings/net/microchip,enc28j60.txt:- spi-max-frequency: Maximum frequency of the SPI bus when accessing the ENC28J60.
Documentation/devicetree/bindings/net/microchip,enc28j60.txt:                        spi-max-frequency = <12000000>;
Documentation/devicetree/bindings/net/dsa/ksz.txt:                                                             spi-max-frequency = <44000000>;
Documentation/devicetree/bindings/net/dsa/ksz.txt:                                                             spi-cpha;
Documentation/devicetree/bindings/net/dsa/ksz.txt:                                                             spi-cpol;
Documentation/devicetree/bindings/net/wireless/ti,wlcore,spi.txt:- spi-max-frequency :   Maximum SPI clocking speed of device in Hz
Documentation/devicetree/bindings/net/wireless/ti,wlcore,spi.txt:- Please consult Documentation/devicetree/bindings/spi/spi-bus.txt
Documentation/devicetree/bindings/net/wireless/ti,wlcore,spi.txt:		spi-max-frequency = <48000000>;
Documentation/devicetree/bindings/net/wireless/ti,wlcore,spi.txt:		spi-max-frequency = <48000000>;
Documentation/devicetree/bindings/net/wireless/ti,wl1251.txt:- spi-max-frequency : Maximum SPI clocking speed of device in Hz
Documentation/devicetree/bindings/net/wireless/ti,wl1251.txt:- Please consult Documentation/devicetree/bindings/spi/spi-bus.txt
Documentation/devicetree/bindings/net/wireless/ti,wl1251.txt:		spi-max-frequency = <48000000>;
Documentation/devicetree/bindings/net/wireless/ti,wl1251.txt:		spi-cpol;
Documentation/devicetree/bindings/net/wireless/ti,wl1251.txt:		spi-cpha;
Documentation/devicetree/bindings/media/samsung-s5c73m3.txt:(../spi/spi-bus.txt) and bindings of a specific bus controller.
Documentation/acpi/enumeration.txt:	status = acpi_evaluate_object(ACPI_HANDLE(&spi->dev), "_DSM",
sound/spi/at73c213.c:	dev_info(&chip->spi->dev,
sound/spi/at73c213.c:		dev_dbg(&chip->spi->dev, "spurious command %x\n", cmd);
sound/spi/at73c213.c:		dev_dbg(&chip->spi->dev, "unable to request irq %d\n", irq);
sound/spi/at73c213.c:	board = spi->dev.platform_data;
sound/spi/at73c213.c:		dev_dbg(&spi->dev, "no platform_data\n");
sound/spi/at73c213.c:		dev_dbg(&spi->dev, "no DAC clk\n");
sound/spi/at73c213.c:		dev_dbg(&spi->dev, "no DAC clk\n");
sound/spi/at73c213.c:	retval = snd_card_new(&spi->dev, -1, id, THIS_MODULE,
sound/spi/at73c213.c:		dev_dbg(&spi->dev, "could not get ssc%d device\n",
sound/spi/at73c213.c:	dev_set_drvdata(&spi->dev, card);
sound/spi/at73c213.c:	struct snd_card *card = dev_get_drvdata(&spi->dev);
sound/soc/codecs/wm8741.c:	wm8741 = devm_kzalloc(&spi->dev, sizeof(struct wm8741_priv),
sound/soc/codecs/wm8741.c:	ret = devm_regulator_bulk_get(&spi->dev, ARRAY_SIZE(wm8741->supplies),
sound/soc/codecs/wm8741.c:		dev_err(&spi->dev, "Failed to request supplies: %d\n", ret);
sound/soc/codecs/wm8741.c:		dev_err(&spi->dev, "Failed to init regmap: %d\n", ret);
sound/soc/codecs/wm8741.c:	ret = wm8741_set_pdata(&spi->dev, wm8741);
sound/soc/codecs/wm8741.c:		dev_err(&spi->dev, "Failed to set pdata: %d\n", ret);
sound/soc/codecs/wm8741.c:	ret = snd_soc_register_codec(&spi->dev,
sound/soc/codecs/wm8741.c:	snd_soc_unregister_codec(&spi->dev);
sound/soc/codecs/wm8753.c:	wm8753 = devm_kzalloc(&spi->dev, sizeof(struct wm8753_priv),
sound/soc/codecs/wm8753.c:		dev_err(&spi->dev, "Failed to allocate register map: %d\n",
sound/soc/codecs/wm8753.c:	ret = snd_soc_register_codec(&spi->dev, &soc_codec_dev_wm8753,
sound/soc/codecs/wm8753.c:		dev_err(&spi->dev, "Failed to register CODEC: %d\n", ret);
sound/soc/codecs/wm8753.c:	snd_soc_unregister_codec(&spi->dev);
sound/soc/codecs/ad193x-spi.c:	return ad193x_probe(&spi->dev, devm_regmap_init_spi(spi, &config),
sound/soc/codecs/ad193x-spi.c:	snd_soc_unregister_codec(&spi->dev);
sound/soc/codecs/wm8728.c:	wm8728 = devm_kzalloc(&spi->dev, sizeof(struct wm8728_priv),
sound/soc/codecs/wm8728.c:	ret = snd_soc_register_codec(&spi->dev,
sound/soc/codecs/wm8728.c:	snd_soc_unregister_codec(&spi->dev);
sound/soc/codecs/pcm512x-spi.c:	return pcm512x_probe(&spi->dev, regmap);
sound/soc/codecs/pcm512x-spi.c:	pcm512x_remove(&spi->dev);
sound/soc/codecs/ak4104.c:	struct device_node *np = spi->dev.of_node;
sound/soc/codecs/ak4104.c:	spi->bits_per_word = 8;
sound/soc/codecs/ak4104.c:	spi->mode = SPI_MODE_0;
sound/soc/codecs/ak4104.c:	ak4104 = devm_kzalloc(&spi->dev, sizeof(struct ak4104_private),
sound/soc/codecs/ak4104.c:	ak4104->regulator = devm_regulator_get(&spi->dev, "vdd");
sound/soc/codecs/ak4104.c:		dev_err(&spi->dev, "Unable to get Vdd regulator: %d\n", ret);
sound/soc/codecs/ak4104.c:			ret = devm_gpio_request_one(&spi->dev, gpio,
sound/soc/codecs/ak4104.c:	ret = snd_soc_register_codec(&spi->dev,
sound/soc/codecs/ak4104.c:	snd_soc_unregister_codec(&spi->dev);
sound/soc/codecs/pcm3168a-spi.c:	return pcm3168a_probe(&spi->dev, regmap);
sound/soc/codecs/pcm3168a-spi.c:	pcm3168a_remove(&spi->dev);
sound/soc/codecs/wm8988.c:	wm8988 = devm_kzalloc(&spi->dev, sizeof(struct wm8988_priv),
sound/soc/codecs/wm8988.c:		dev_err(&spi->dev, "Failed to init regmap: %d\n", ret);
sound/soc/codecs/wm8988.c:	ret = snd_soc_register_codec(&spi->dev,
sound/soc/codecs/wm8988.c:	snd_soc_unregister_codec(&spi->dev);
sound/soc/codecs/wm8711.c:	wm8711 = devm_kzalloc(&spi->dev, sizeof(struct wm8711_priv),
sound/soc/codecs/wm8711.c:	ret = snd_soc_register_codec(&spi->dev,
sound/soc/codecs/wm8711.c:	snd_soc_unregister_codec(&spi->dev);
sound/soc/codecs/wm8770.c:	wm8770 = devm_kzalloc(&spi->dev, sizeof(struct wm8770_priv),
sound/soc/codecs/wm8770.c:	ret = devm_regulator_bulk_get(&spi->dev, ARRAY_SIZE(wm8770->supplies),
sound/soc/codecs/wm8770.c:		dev_err(&spi->dev, "Failed to request supplies: %d\n", ret);
sound/soc/codecs/wm8770.c:			dev_err(&spi->dev,
sound/soc/codecs/wm8770.c:	ret = snd_soc_register_codec(&spi->dev,
sound/soc/codecs/wm8770.c:	snd_soc_unregister_codec(&spi->dev);
sound/soc/codecs/ssm2602-spi.c:	return ssm2602_probe(&spi->dev, SSM2602,
sound/soc/codecs/ssm2602-spi.c:	snd_soc_unregister_codec(&spi->dev);
sound/soc/codecs/wm8804-spi.c:	return wm8804_probe(&spi->dev, regmap);
sound/soc/codecs/wm8804-spi.c:	wm8804_remove(&spi->dev);
sound/soc/codecs/adau1781-spi.c:	return adau1781_probe(&spi->dev,
sound/soc/codecs/adau1781-spi.c:	adau17x1_remove(&spi->dev);
sound/soc/codecs/tlv320aic23-spi.c:	dev_dbg(&spi->dev, "probing tlv320aic23 spi device\n");
sound/soc/codecs/tlv320aic23-spi.c:	spi->mode = SPI_MODE_0;
sound/soc/codecs/tlv320aic23-spi.c:	return tlv320aic23_probe(&spi->dev, regmap);
sound/soc/codecs/tlv320aic23-spi.c:	snd_soc_unregister_codec(&spi->dev);
sound/soc/codecs/rt5514-spi.c:	rt5514_dsp->dev = &rt5514_spi->dev;
sound/soc/codecs/rt5514-spi.c:	if (rt5514_spi->irq) {
sound/soc/codecs/rt5514-spi.c:		ret = devm_request_threaded_irq(&rt5514_spi->dev,
sound/soc/codecs/rt5514-spi.c:			rt5514_spi->irq, NULL, rt5514_spi_irq,
sound/soc/codecs/rt5514-spi.c:			dev_err(&rt5514_spi->dev,
sound/soc/codecs/rt5514-spi.c:	.name		= "rt5514-spi-dai",
sound/soc/codecs/rt5514-spi.c:	ret = devm_snd_soc_register_platform(&spi->dev, &rt5514_spi_platform);
sound/soc/codecs/rt5514-spi.c:		dev_err(&spi->dev, "Failed to register platform.\n");
sound/soc/codecs/rt5514-spi.c:	ret = devm_snd_soc_register_component(&spi->dev,
sound/soc/codecs/rt5514-spi.c:		dev_err(&spi->dev, "Failed to register component.\n");
sound/soc/codecs/wm8731.c:	wm8731 = devm_kzalloc(&spi->dev, sizeof(*wm8731), GFP_KERNEL);
sound/soc/codecs/wm8731.c:	wm8731->mclk = devm_clk_get(&spi->dev, "mclk");
sound/soc/codecs/wm8731.c:			dev_warn(&spi->dev, "Assuming static MCLK\n");
sound/soc/codecs/wm8731.c:			dev_err(&spi->dev, "Failed to get MCLK: %d\n",
sound/soc/codecs/wm8731.c:	ret = wm8731_request_supplies(&spi->dev, wm8731);
sound/soc/codecs/wm8731.c:		dev_err(&spi->dev, "Failed to allocate register map: %d\n",
sound/soc/codecs/wm8731.c:	ret = wm8731_hw_init(&spi->dev, wm8731);
sound/soc/codecs/wm8731.c:	ret = snd_soc_register_codec(&spi->dev,
sound/soc/codecs/wm8731.c:		dev_err(&spi->dev, "Failed to register CODEC: %d\n", ret);
sound/soc/codecs/wm8731.c:	snd_soc_unregister_codec(&spi->dev);
sound/soc/codecs/rt5677-spi.c:		dev_err(&g_spi->dev, "Bad read align 0x%x(%zu)\n", addr, len);
sound/soc/codecs/rt5677-spi.c:		dev_err(&g_spi->dev, "Bad write align 0x%x(%zu)\n", addr, len);
sound/soc/codecs/ad1836.c:	ad1836 = devm_kzalloc(&spi->dev, sizeof(struct ad1836_priv),
sound/soc/codecs/ad1836.c:	ret = snd_soc_register_codec(&spi->dev,
sound/soc/codecs/ad1836.c:	snd_soc_unregister_codec(&spi->dev);
sound/soc/codecs/da7210.c:	da7210 = devm_kzalloc(&spi->dev, sizeof(struct da7210_priv),
sound/soc/codecs/da7210.c:		dev_err(&spi->dev, "Failed to register regmap: %d\n", ret);
sound/soc/codecs/da7210.c:		dev_warn(&spi->dev, "Failed to apply regmap patch: %d\n", ret);
sound/soc/codecs/da7210.c:	ret = snd_soc_register_codec(&spi->dev,
sound/soc/codecs/da7210.c:	snd_soc_unregister_codec(&spi->dev);
sound/soc/codecs/pcm186x-spi.c:	int irq = spi->irq;
sound/soc/codecs/pcm186x-spi.c:	return pcm186x_probe(&spi->dev, type, irq, regmap);
sound/soc/codecs/pcm186x-spi.c:	pcm186x_remove(&spi->dev);
sound/soc/codecs/wm8900.c:	wm8900 = devm_kzalloc(&spi->dev, sizeof(struct wm8900_priv),
sound/soc/codecs/wm8900.c:	ret = snd_soc_register_codec(&spi->dev,
sound/soc/codecs/wm8900.c:	snd_soc_unregister_codec(&spi->dev);
sound/soc/codecs/adau1977-spi.c:	return adau1977_probe(&spi->dev,
sound/soc/codecs/adau1977-spi.c:	snd_soc_unregister_codec(&spi->dev);
sound/soc/codecs/es8328-spi.c:	return es8328_probe(&spi->dev,
sound/soc/codecs/es8328-spi.c:	snd_soc_unregister_codec(&spi->dev);
sound/soc/codecs/pcm179x-spi.c:		dev_err(&spi->dev, "Failed to allocate regmap: %d\n", ret);
sound/soc/codecs/pcm179x-spi.c:	return pcm179x_common_init(&spi->dev, regmap);
sound/soc/codecs/pcm179x-spi.c:	return pcm179x_common_exit(&spi->dev);
sound/soc/codecs/wm8510.c:	wm8510 = devm_kzalloc(&spi->dev, sizeof(struct wm8510_priv),
sound/soc/codecs/wm8510.c:	ret = snd_soc_register_codec(&spi->dev,
sound/soc/codecs/wm8510.c:	snd_soc_unregister_codec(&spi->dev);
sound/soc/codecs/adav801.c:	return adav80x_bus_probe(&spi->dev, devm_regmap_init_spi(spi, &config));
sound/soc/codecs/adav801.c:	snd_soc_unregister_codec(&spi->dev);
sound/soc/codecs/cs4271-spi.c:	return cs4271_probe(&spi->dev, devm_regmap_init_spi(spi, &config));
sound/soc/codecs/cs4271-spi.c:	snd_soc_unregister_codec(&spi->dev);
sound/soc/codecs/adau1761-spi.c:	return adau1761_probe(&spi->dev,
sound/soc/codecs/adau1761-spi.c:	adau17x1_remove(&spi->dev);
sound/soc/codecs/tlv320aic26.c:	dev_dbg(&aic26->spi->dev, "aic26_hw_params(substream=%p, params=%p)\n",
sound/soc/codecs/tlv320aic26.c:	dev_dbg(&aic26->spi->dev, "rate=%i width=%d\n", params_rate(params),
sound/soc/codecs/tlv320aic26.c:		dev_dbg(&aic26->spi->dev, "bad rate\n"); return -EINVAL;
sound/soc/codecs/tlv320aic26.c:		dev_dbg(&aic26->spi->dev, "bad format\n"); return -EINVAL;
sound/soc/codecs/tlv320aic26.c:	dev_dbg(&aic26->spi->dev, "Setting PLLM to %d.%04d\n", jval, dval);
sound/soc/codecs/tlv320aic26.c:	dev_dbg(&aic26->spi->dev, "aic26_mute(dai=%p, mute=%i)\n",
sound/soc/codecs/tlv320aic26.c:	dev_dbg(&aic26->spi->dev, "aic26_set_sysclk(dai=%p, clk_id==%i,"
sound/soc/codecs/tlv320aic26.c:	dev_dbg(&aic26->spi->dev, "aic26_set_fmt(dai=%p, fmt==%i)\n",
sound/soc/codecs/tlv320aic26.c:		dev_dbg(&aic26->spi->dev, "bad master\n"); return -EINVAL;
sound/soc/codecs/tlv320aic26.c:		dev_dbg(&aic26->spi->dev, "bad format\n"); return -EINVAL;
sound/soc/codecs/tlv320aic26.c:	dev_dbg(&spi->dev, "probing tlv320aic26 spi device\n");
sound/soc/codecs/tlv320aic26.c:	aic26 = devm_kzalloc(&spi->dev, sizeof *aic26, GFP_KERNEL);
sound/soc/codecs/tlv320aic26.c:	dev_set_drvdata(&spi->dev, aic26);
sound/soc/codecs/tlv320aic26.c:	ret = snd_soc_register_codec(&spi->dev,
sound/soc/codecs/tlv320aic26.c:	snd_soc_unregister_codec(&spi->dev);
sound/soc/codecs/tlv320aic32x4-spi.c:	return aic32x4_probe(&spi->dev, regmap);
sound/soc/codecs/tlv320aic32x4-spi.c:	return aic32x4_remove(&spi->dev);
sound/soc/codecs/wm0010.c:		dev_err(&spi->dev, "Failed to enable core supplies: %d\n",
sound/soc/codecs/wm0010.c:		dev_err(&spi->dev, "Failed to enable DBVDD: %d\n", ret);
sound/soc/codecs/wm0010.c:	wm0010 = devm_kzalloc(&spi->dev, sizeof(*wm0010),
sound/soc/codecs/wm0010.c:	wm0010->dev = &spi->dev;
sound/soc/codecs/wm0010.c:	if (dev_get_platdata(&spi->dev))
sound/soc/codecs/wm0010.c:		memcpy(&wm0010->pdata, dev_get_platdata(&spi->dev),
sound/soc/codecs/wm0010.c:	irq = spi->irq;
sound/soc/codecs/wm0010.c:	if (spi->max_speed_hz)
sound/soc/codecs/wm0010.c:		wm0010->board_max_spi_speed = spi->max_speed_hz;
sound/soc/codecs/wm0010.c:	ret = snd_soc_register_codec(&spi->dev,
sound/soc/codecs/wm0010.c:	snd_soc_unregister_codec(&spi->dev);
sound/soc/codecs/wm8750.c:	wm8750 = devm_kzalloc(&spi->dev, sizeof(struct wm8750_priv),
sound/soc/codecs/wm8750.c:	ret = snd_soc_register_codec(&spi->dev,
sound/soc/codecs/wm8750.c:	snd_soc_unregister_codec(&spi->dev);
sound/soc/codecs/wm8776.c:	wm8776 = devm_kzalloc(&spi->dev, sizeof(struct wm8776_priv),
sound/soc/codecs/wm8776.c:	ret = snd_soc_register_codec(&spi->dev,
sound/soc/codecs/wm8776.c:	snd_soc_unregister_codec(&spi->dev);
sound/soc/codecs/wm8737.c:	wm8737 = devm_kzalloc(&spi->dev, sizeof(struct wm8737_priv),
sound/soc/codecs/wm8737.c:	ret = devm_regulator_bulk_get(&spi->dev, ARRAY_SIZE(wm8737->supplies),
sound/soc/codecs/wm8737.c:		dev_err(&spi->dev, "Failed to request supplies: %d\n", ret);
sound/soc/codecs/wm8737.c:	ret = snd_soc_register_codec(&spi->dev,
sound/soc/codecs/wm8737.c:	snd_soc_unregister_codec(&spi->dev);
sound/soc/codecs/Makefile:snd-soc-ad193x-spi-objs := ad193x-spi.o
sound/soc/codecs/Makefile:snd-soc-adau1761-spi-objs := adau1761-spi.o
sound/soc/codecs/Makefile:snd-soc-adau1781-spi-objs := adau1781-spi.o
sound/soc/codecs/Makefile:snd-soc-adau1977-spi-objs := adau1977-spi.o
sound/soc/codecs/Makefile:snd-soc-cs4271-spi-objs := cs4271-spi.o
sound/soc/codecs/Makefile:snd-soc-es8328-spi-objs := es8328-spi.o
sound/soc/codecs/Makefile:snd-soc-pcm179x-spi-objs := pcm179x-spi.o
sound/soc/codecs/Makefile:snd-soc-pcm186x-spi-objs := pcm186x-spi.o
sound/soc/codecs/Makefile:snd-soc-pcm3168a-spi-objs := pcm3168a-spi.o
sound/soc/codecs/Makefile:snd-soc-pcm512x-spi-objs := pcm512x-spi.o
sound/soc/codecs/Makefile:snd-soc-rt5514-spi-objs := rt5514-spi.o
sound/soc/codecs/Makefile:snd-soc-rt5677-spi-objs := rt5677-spi.o
sound/soc/codecs/Makefile:snd-soc-ssm2602-spi-objs := ssm2602-spi.o
sound/soc/codecs/Makefile:snd-soc-tlv320aic23-spi-objs := tlv320aic23-spi.o
sound/soc/codecs/Makefile:snd-soc-tlv320aic32x4-spi-objs := tlv320aic32x4-spi.o
sound/soc/codecs/Makefile:snd-soc-wm8804-spi-objs := wm8804-spi.o
sound/soc/codecs/wm8985.c:	wm8985 = devm_kzalloc(&spi->dev, sizeof *wm8985, GFP_KERNEL);
sound/soc/codecs/wm8985.c:		dev_err(&spi->dev, "Failed to allocate register map: %d\n",
sound/soc/codecs/wm8985.c:	ret = snd_soc_register_codec(&spi->dev,
sound/soc/codecs/wm8985.c:	snd_soc_unregister_codec(&spi->dev);
sound/soc/codecs/wm8995.c:	wm8995 = devm_kzalloc(&spi->dev, sizeof(*wm8995), GFP_KERNEL);
sound/soc/codecs/wm8995.c:		dev_err(&spi->dev, "Failed to register regmap: %d\n", ret);
sound/soc/codecs/wm8995.c:	ret = snd_soc_register_codec(&spi->dev,
sound/soc/codecs/wm8995.c:	snd_soc_unregister_codec(&spi->dev);
sound/soc/codecs/wm8983.c:	wm8983 = devm_kzalloc(&spi->dev, sizeof *wm8983, GFP_KERNEL);
sound/soc/codecs/wm8983.c:		dev_err(&spi->dev, "Failed to init regmap: %d\n", ret);
sound/soc/codecs/wm8983.c:	ret = snd_soc_register_codec(&spi->dev,
sound/soc/codecs/wm8983.c:	snd_soc_unregister_codec(&spi->dev);
sound/soc/intel/boards/kbl_rt5663_rt5514_max98927.c:		.cpu_dai_name = "spi-PRP0001:00",
sound/soc/intel/boards/kbl_rt5663_rt5514_max98927.c:		.platform_name = "spi-PRP0001:00",
arch/blackfin/mach-bf533/boards/ip0x.c:	.name = "bfin-spi-master",
arch/blackfin/mach-bf533/boards/stamp.c:		"mmc-spi-detect", data);
arch/blackfin/mach-bf537/boards/stamp.c:		IRQF_TRIGGER_FALLING, "mmc-spi-detect", data);
arch/arm64/boot/dts/mediatek/mt8173.dtsi:			clock-names = "parent-clk", "sel-clk", "spi-clk";
arch/arm64/boot/dts/amlogic/meson-gxbb.dtsi:		spi_ss0_pins: spi-ss0 {
arch/arm64/boot/dts/amlogic/meson-gxl.dtsi:		spi_ss0_pins: spi-ss0 {
arch/arm64/boot/dts/amlogic/meson-gxm-khadas-vim2.dts:	w25q32: spi-flash@0 {
arch/arm64/boot/dts/amlogic/meson-gxm-khadas-vim2.dts:		compatible = "winbond,w25q16", "jedec,spi-nor";
arch/arm64/boot/dts/amlogic/meson-gxm-khadas-vim2.dts:		spi-max-frequency = <3000000>;
arch/arm64/boot/dts/marvell/armada-37xx.dtsi:				spi_quad_pins: spi-quad-pins {
arch/arm64/boot/dts/marvell/armada-ap806.dtsi:				marvell,spi-base = <128>, <136>, <144>, <152>;
arch/arm64/boot/dts/marvell/armada-ap806.dtsi:				marvell,spi-ranges = <64 64>, <288 64>;
arch/arm64/boot/dts/marvell/armada-8040-db.dts:	spi-flash@0 {
arch/arm64/boot/dts/marvell/armada-8040-db.dts:		compatible = "jedec,spi-nor";
arch/arm64/boot/dts/marvell/armada-8040-db.dts:		spi-max-frequency = <10000000>;
arch/arm64/boot/dts/marvell/armada-8040-db.dts:	spi-flash@0 {
arch/arm64/boot/dts/marvell/armada-8040-db.dts:		compatible = "jedec,spi-nor";
arch/arm64/boot/dts/marvell/armada-8040-db.dts:		spi-max-frequency = <20000000>;
arch/arm64/boot/dts/marvell/armada-7040-db.dts:	spi-flash@0 {
arch/arm64/boot/dts/marvell/armada-7040-db.dts:		compatible = "jedec,spi-nor";
arch/arm64/boot/dts/marvell/armada-7040-db.dts:		spi-max-frequency = <10000000>;
arch/arm64/boot/dts/marvell/armada-7040-db.dts:	spi-flash@0 {
arch/arm64/boot/dts/marvell/armada-7040-db.dts:		compatible = "jedec,spi-nor";
arch/arm64/boot/dts/marvell/armada-7040-db.dts:		spi-max-frequency = <20000000>;
arch/arm64/boot/dts/marvell/armada-3720-db.dts:		compatible = "jedec,spi-nor";
arch/arm64/boot/dts/marvell/armada-3720-db.dts:		spi-max-frequency = <108000000>;
arch/arm64/boot/dts/marvell/armada-3720-db.dts:		spi-rx-bus-width = <4>;
arch/arm64/boot/dts/marvell/armada-3720-db.dts:		spi-tx-bus-width = <4>;
arch/arm64/boot/dts/marvell/armada-8040-mcbin.dts:	spi-flash@0 {
arch/arm64/boot/dts/marvell/armada-8040-mcbin.dts:		spi-max-frequency = <50000000>;
arch/arm64/boot/dts/xilinx/zynqmp-ep108.dts:		spi-max-frequency = <50000000>;
arch/arm64/boot/dts/xilinx/zynqmp-ep108.dts:		spi-max-frequency = <50000000>;
arch/arm64/boot/dts/xilinx/zynqmp.dtsi:			compatible = "cdns,spi-r1p6";
arch/arm64/boot/dts/xilinx/zynqmp.dtsi:			compatible = "cdns,spi-r1p6";
arch/arm64/boot/dts/qcom/msm8996.dtsi:			compatible = "qcom,spi-qup-v2.2.1";
arch/arm64/boot/dts/qcom/msm8996.dtsi:			compatible = "qcom,spi-qup-v2.2.1";
arch/arm64/boot/dts/qcom/msm8916.dtsi:			compatible = "qcom,spi-qup-v2.2.1";
arch/arm64/boot/dts/qcom/msm8916.dtsi:			compatible = "qcom,spi-qup-v2.2.1";
arch/arm64/boot/dts/qcom/msm8916.dtsi:			compatible = "qcom,spi-qup-v2.2.1";
arch/arm64/boot/dts/qcom/msm8916.dtsi:			compatible = "qcom,spi-qup-v2.2.1";
arch/arm64/boot/dts/qcom/msm8916.dtsi:			compatible = "qcom,spi-qup-v2.2.1";
arch/arm64/boot/dts/qcom/msm8916.dtsi:			compatible = "qcom,spi-qup-v2.2.1";
arch/arm64/boot/dts/rockchip/rk3399-puma.dtsi:		compatible = "jedec,spi-nor";
arch/arm64/boot/dts/rockchip/rk3399-puma.dtsi:		spi-max-frequency = <50000000>;
arch/arm64/boot/dts/rockchip/rk3399-gru.dtsi:		compatible = "jedec,spi-nor";
arch/arm64/boot/dts/rockchip/rk3399-gru.dtsi:		spi-max-frequency = <10000000>;
arch/arm64/boot/dts/rockchip/rk3399-gru.dtsi:		spi-max-frequency = <10000000>;
arch/arm64/boot/dts/rockchip/rk3399-gru.dtsi:		spi-max-frequency = <3000000>;
arch/arm64/boot/dts/broadcom/stingray/bcm958742k.dts:	spi-flash@0 {
arch/arm64/boot/dts/broadcom/stingray/bcm958742k.dts:		compatible = "jedec,spi-nor";
arch/arm64/boot/dts/broadcom/stingray/bcm958742k.dts:		spi-max-frequency = <20000000>;
arch/arm64/boot/dts/broadcom/stingray/bcm958742k.dts:	spi-flash@0 {
arch/arm64/boot/dts/broadcom/stingray/bcm958742k.dts:		compatible = "jedec,spi-nor";
arch/arm64/boot/dts/broadcom/stingray/bcm958742k.dts:		spi-max-frequency = <20000000>;
arch/arm64/boot/dts/broadcom/northstar2/ns2-svk.dts:		spi-max-frequency = <5000000>;
arch/arm64/boot/dts/broadcom/northstar2/ns2-svk.dts:		spi-cpha = <1>;
arch/arm64/boot/dts/broadcom/northstar2/ns2-svk.dts:		spi-cpol = <1>;
arch/arm64/boot/dts/broadcom/northstar2/ns2-svk.dts:		spi-max-frequency = <5000000>;
arch/arm64/boot/dts/broadcom/northstar2/ns2-svk.dts:		spi-cpha = <1>;
arch/arm64/boot/dts/broadcom/northstar2/ns2-svk.dts:		spi-cpol = <1>;
arch/arm64/boot/dts/broadcom/northstar2/ns2-svk.dts:	bspi-sel = <0>;
arch/arm64/boot/dts/broadcom/northstar2/ns2-svk.dts:		spi-max-frequency = <12500000>;
arch/arm64/boot/dts/broadcom/northstar2/ns2-svk.dts:		spi-cpol;
arch/arm64/boot/dts/broadcom/northstar2/ns2-svk.dts:		spi-cpha;
arch/arm64/boot/dts/broadcom/northstar2/ns2-xmc.dts:		spi-max-frequency = <62500000>;
arch/arm64/boot/dts/broadcom/northstar2/ns2.dtsi:			compatible = "brcm,spi-bcm-qspi", "brcm,spi-ns2-qspi";
arch/arm64/boot/dts/exynos/exynos5433.dtsi:			samsung,spi-src-clk = <0>;
arch/arm64/boot/dts/exynos/exynos5433.dtsi:			samsung,spi-src-clk = <0>;
arch/arm64/boot/dts/exynos/exynos5433.dtsi:			samsung,spi-src-clk = <0>;
arch/arm64/boot/dts/exynos/exynos5433.dtsi:			samsung,spi-src-clk = <0>;
arch/arm64/boot/dts/exynos/exynos5433.dtsi:			samsung,spi-src-clk = <0>;
arch/arm64/boot/dts/exynos/exynos5433-tm2-common.dtsi:		spi-max-frequency = <20000000>;
arch/arm64/boot/dts/exynos/exynos5433-tm2-common.dtsi:			samsung,spi-feedback-delay = <0>;
arch/arm64/boot/dts/exynos/exynos5433-tm2-common.dtsi:		compatible = "ir-spi-led";
arch/arm64/boot/dts/exynos/exynos5433-tm2-common.dtsi:		spi-max-frequency = <5000000>;
arch/arm64/boot/dts/exynos/exynos5433-tm2-common.dtsi:			samsung,spi-feedback-delay = <0>;
arch/arm64/boot/dts/exynos/exynos5433-pinctrl.dtsi:	fimc_is_spi_pin0: fimc-is-spi-pin0 {
arch/arm64/boot/dts/exynos/exynos5433-pinctrl.dtsi:	fimc_is_spi_pin1: fimc-is-spi-pin1 {
arch/arm64/boot/dts/amd/amd-overdrive-rev-b1.dts:		compatible = "mmc-spi-slot";
arch/arm64/boot/dts/amd/amd-overdrive-rev-b1.dts:		spi-max-frequency = <20000000>;
arch/arm64/boot/dts/amd/husky.dts:		compatible = "mmc-spi-slot";
arch/arm64/boot/dts/amd/husky.dts:		spi-max-frequency = <20000000>;
arch/arm64/boot/dts/amd/amd-overdrive-rev-b0.dts:		compatible = "mmc-spi-slot";
arch/arm64/boot/dts/amd/amd-overdrive-rev-b0.dts:		spi-max-frequency = <20000000>;
arch/arm64/boot/dts/amd/amd-seattle-soc.dtsi:			spi-controller;
arch/arm64/boot/dts/amd/amd-seattle-soc.dtsi:			spi-controller;
arch/arm64/boot/dts/amd/amd-overdrive.dts:		compatible = "mmc-spi-slot";
arch/arm64/boot/dts/amd/amd-overdrive.dts:		spi-max-frequency = <20000000>;
arch/arm64/boot/dts/nvidia/tegra132-norrin.dts:			spi-max-frequency = <3000000>;
arch/arm64/boot/dts/nvidia/tegra132-norrin.dts:			google,cros-ec-spi-msg-delay = <2000>;
arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb.dts:		spi-max-frequency = <20000000>;
arch/arm64/boot/dts/freescale/fsl-ls1046a-rdb.dts:		spi-max-frequency = <20000000>;
arch/arm64/boot/dts/freescale/fsl-ls208xa-qds.dtsi:		spi-max-frequency = <3000000>;
arch/arm64/boot/dts/freescale/fsl-ls208xa-qds.dtsi:		spi-max-frequency = <3000000>;
arch/arm64/boot/dts/freescale/fsl-ls208xa-qds.dtsi:		spi-max-frequency = <3000000>;
arch/arm64/boot/dts/freescale/fsl-ls208xa-qds.dtsi:		spi-max-frequency = <20000000>;
arch/arm64/boot/dts/freescale/fsl-ls208xa-qds.dtsi:		spi-max-frequency = <20000000>;
arch/arm64/boot/dts/freescale/fsl-ls1046a-qds.dts:		compatible = "n25q128a11", "jedec,spi-nor";
arch/arm64/boot/dts/freescale/fsl-ls1046a-qds.dts:		spi-max-frequency = <10000000>;
arch/arm64/boot/dts/freescale/fsl-ls1046a-qds.dts:		compatible = "sst25wf040b", "jedec,spi-nor";
arch/arm64/boot/dts/freescale/fsl-ls1046a-qds.dts:		spi-cpol;
arch/arm64/boot/dts/freescale/fsl-ls1046a-qds.dts:		spi-cpha;
arch/arm64/boot/dts/freescale/fsl-ls1046a-qds.dts:		spi-max-frequency = <10000000>;
arch/arm64/boot/dts/freescale/fsl-ls1046a-qds.dts:		compatible = "en25s64", "jedec,spi-nor";
arch/arm64/boot/dts/freescale/fsl-ls1046a-qds.dts:		spi-cpol;
arch/arm64/boot/dts/freescale/fsl-ls1046a-qds.dts:		spi-cpha;
arch/arm64/boot/dts/freescale/fsl-ls1046a-qds.dts:		spi-max-frequency = <10000000>;
arch/arm64/boot/dts/freescale/fsl-ls1046a-qds.dts:		spi-max-frequency = <20000000>;
arch/arm64/boot/dts/freescale/fsl-ls208xa-rdb.dtsi:		spi-max-frequency = <3000000>;
arch/arm64/boot/dts/freescale/fsl-ls1043a-qds.dts:		spi-max-frequency = <20000000>;
arch/arm64/boot/dts/freescale/fsl-ls1012a.dtsi:			spi-num-chipselects = <5>;
arch/arm64/boot/dts/freescale/fsl-ls1012a-qds.dts:		compatible = "n25q128a11", "jedec,spi-nor";
arch/arm64/boot/dts/freescale/fsl-ls1012a-qds.dts:		spi-max-frequency = <10000000>;
arch/arm64/boot/dts/freescale/fsl-ls1012a-qds.dts:		compatible = "sst25wf040b", "jedec,spi-nor";
arch/arm64/boot/dts/freescale/fsl-ls1012a-qds.dts:		spi-cpol;
arch/arm64/boot/dts/freescale/fsl-ls1012a-qds.dts:		spi-cpha;
arch/arm64/boot/dts/freescale/fsl-ls1012a-qds.dts:		spi-max-frequency = <10000000>;
arch/arm64/boot/dts/freescale/fsl-ls1012a-qds.dts:		compatible = "en25s64", "jedec,spi-nor";
arch/arm64/boot/dts/freescale/fsl-ls1012a-qds.dts:		spi-cpol;
arch/arm64/boot/dts/freescale/fsl-ls1012a-qds.dts:		spi-cpha;
arch/arm64/boot/dts/freescale/fsl-ls1012a-qds.dts:		spi-max-frequency = <10000000>;
arch/arm64/boot/dts/freescale/fsl-ls1043a-rdb.dts:		compatible = "n25q128a13", "jedec,spi-nor";  /* 16MB */
arch/arm64/boot/dts/freescale/fsl-ls1043a-rdb.dts:		spi-max-frequency = <1000000>; /* input clock */
arch/arm64/boot/dts/freescale/fsl-ls1043a.dtsi:			spi-num-chipselects = <5>;
arch/arm64/boot/dts/freescale/fsl-ls1043a.dtsi:			spi-num-chipselects = <5>;
arch/arm64/boot/dts/freescale/fsl-ls1046a.dtsi:			fsl,qspi-has-second-chip;
arch/arm64/boot/dts/freescale/fsl-ls1046a.dtsi:			spi-num-chipselects = <5>;
arch/arm64/boot/dts/freescale/fsl-ls208xa.dtsi:			spi-num-chipselects = <5>;
arch/sh/boot/dts/j2_mimas_v2.dts:			spi-max-frequency = <25000000>;
arch/sh/boot/dts/j2_mimas_v2.dts:				compatible = "mmc-spi-slot";
arch/sh/boot/dts/j2_mimas_v2.dts:				spi-max-frequency = <25000000>;
arch/x86/platform/ce4100/falconfalls.dts:				spi-controller@b,4 {
arch/x86/platform/ce4100/falconfalls.dts:						spi-max-frequency = <115200>;
arch/x86/platform/ce4100/falconfalls.dts:						spi-max-frequency = <115200>;
arch/x86/platform/ce4100/falconfalls.dts:						spi-max-frequency = <115200>;
arch/xtensa/boot/dts/xtfpga.dtsi:		spi0: spi-master@0d0a0000 {
arch/xtensa/boot/dts/xtfpga.dtsi:				spi-max-frequency = <12500000>;
arch/mips/txx9/generic/setup.c:		error = clk_hw_register_clkdev(hw, "spi-baseclk", NULL);
arch/mips/txx9/generic/spi_eeprom.c:	dev_info(&spi->dev, "spiclk %u KHz.\n",
arch/mips/txx9/generic/spi_eeprom.c:		 (spi->max_speed_hz + 500) / 1000);
arch/mips/txx9/generic/spi_eeprom.c:	if (read_param->busid != spi->master->bus_num ||
arch/mips/txx9/generic/spi_eeprom.c:	    read_param->chipid != spi->chip_select)
arch/mips/boot/dts/brcm/bcm97425svmb.dts:		spi-max-frequency = <40000000>;
arch/mips/boot/dts/brcm/bcm97425svmb.dts:		spi-cpol;
arch/mips/boot/dts/brcm/bcm97425svmb.dts:		spi-cpha;
arch/mips/boot/dts/brcm/bcm7362.dtsi:			compatible = "brcm,spi-bcm-qspi",
arch/mips/boot/dts/brcm/bcm7362.dtsi:				     "brcm,spi-brcmstb-qspi";
arch/mips/boot/dts/brcm/bcm7362.dtsi:			compatible = "brcm,spi-bcm-qspi",
arch/mips/boot/dts/brcm/bcm7362.dtsi:				     "brcm,spi-brcmstb-mspi";
arch/mips/boot/dts/brcm/bcm7346.dtsi:			compatible = "brcm,spi-bcm-qspi",
arch/mips/boot/dts/brcm/bcm7346.dtsi:				     "brcm,spi-brcmstb-qspi";
arch/mips/boot/dts/brcm/bcm7346.dtsi:			compatible = "brcm,spi-bcm-qspi",
arch/mips/boot/dts/brcm/bcm7346.dtsi:				     "brcm,spi-brcmstb-mspi";
arch/mips/boot/dts/brcm/bcm97360svmb.dts:		spi-max-frequency = <40000000>;
arch/mips/boot/dts/brcm/bcm97360svmb.dts:		spi-cpol;
arch/mips/boot/dts/brcm/bcm97360svmb.dts:		spi-cpha;
arch/mips/boot/dts/brcm/bcm7360.dtsi:			compatible = "brcm,spi-bcm-qspi",
arch/mips/boot/dts/brcm/bcm7360.dtsi:				     "brcm,spi-brcmstb-qspi";
arch/mips/boot/dts/brcm/bcm7360.dtsi:			compatible = "brcm,spi-bcm-qspi",
arch/mips/boot/dts/brcm/bcm7360.dtsi:				     "brcm,spi-brcmstb-mspi";
arch/mips/boot/dts/brcm/bcm97358svmb.dts:		spi-max-frequency = <40000000>;
arch/mips/boot/dts/brcm/bcm97358svmb.dts:		spi-cpol;
arch/mips/boot/dts/brcm/bcm97358svmb.dts:		spi-cpha;
arch/mips/boot/dts/brcm/bcm7420.dtsi:			compatible = "brcm,spi-bcm-qspi",
arch/mips/boot/dts/brcm/bcm7420.dtsi:				     "brcm,spi-brcmstb-qspi";
arch/mips/boot/dts/brcm/bcm7420.dtsi:			compatible = "brcm,spi-bcm-qspi",
arch/mips/boot/dts/brcm/bcm7420.dtsi:				     "brcm,spi-brcmstb-mspi";
arch/mips/boot/dts/brcm/bcm7435.dtsi:			compatible = "brcm,spi-bcm-qspi",
arch/mips/boot/dts/brcm/bcm7435.dtsi:				     "brcm,spi-brcmstb-qspi";
arch/mips/boot/dts/brcm/bcm7435.dtsi:			compatible = "brcm,spi-bcm-qspi",
arch/mips/boot/dts/brcm/bcm7435.dtsi:				     "brcm,spi-brcmstb-mspi";
arch/mips/boot/dts/brcm/bcm7358.dtsi:			compatible = "brcm,spi-bcm-qspi",
arch/mips/boot/dts/brcm/bcm7358.dtsi:				     "brcm,spi-brcmstb-qspi";
arch/mips/boot/dts/brcm/bcm7358.dtsi:			compatible = "brcm,spi-bcm-qspi",
arch/mips/boot/dts/brcm/bcm7358.dtsi:				     "brcm,spi-brcmstb-mspi";
arch/mips/boot/dts/brcm/bcm7125.dtsi:			compatible = "brcm,spi-bcm-qspi",
arch/mips/boot/dts/brcm/bcm7125.dtsi:				     "brcm,spi-brcmstb-qspi";
arch/mips/boot/dts/brcm/bcm7125.dtsi:			compatible = "brcm,spi-bcm-qspi",
arch/mips/boot/dts/brcm/bcm7125.dtsi:				     "brcm,spi-brcmstb-mspi";
arch/mips/boot/dts/brcm/bcm7425.dtsi:			compatible = "brcm,spi-bcm-qspi",
arch/mips/boot/dts/brcm/bcm7425.dtsi:				     "brcm,spi-brcmstb-qspi";
arch/mips/boot/dts/brcm/bcm7425.dtsi:			compatible = "brcm,spi-bcm-qspi",
arch/mips/boot/dts/brcm/bcm7425.dtsi:				     "brcm,spi-brcmstb-mspi";
arch/mips/boot/dts/img/pistachio_marduk.dts:		compatible = "spansion,s25fl016k", "jedec,spi-nor";
arch/mips/boot/dts/img/pistachio_marduk.dts:		spi-max-frequency = <50000000>;
arch/mips/boot/dts/qca/ar9331_dragino_ms14.dts:		compatible = "winbond,w25q128", "jedec,spi-nor";
arch/mips/boot/dts/qca/ar9331_dragino_ms14.dts:		spi-max-frequency = <104000000>;
arch/mips/boot/dts/qca/ar9331_dpt_module.dts:		compatible = "winbond,w25q128", "jedec,spi-nor";
arch/mips/boot/dts/qca/ar9331_dpt_module.dts:		spi-max-frequency = <104000000>;
arch/mips/boot/dts/qca/ar9132_tl_wr1043nd_v1.dts:		spi-max-frequency = <25000000>;
arch/mips/boot/dts/qca/ar9331_tl_mr3020.dts:		compatible = "spansion,s25sl032p", "jedec,spi-nor";
arch/mips/boot/dts/qca/ar9331_tl_mr3020.dts:		spi-max-frequency = <104000000>;
arch/mips/boot/dts/qca/ar9331_omega.dts:		compatible = "winbond,w25q128", "jedec,spi-nor";
arch/mips/boot/dts/qca/ar9331_omega.dts:		spi-max-frequency = <104000000>;
arch/cris/boot/dts/dev88.dts:		compatible = "spi-gpio";
arch/cris/boot/dts/dev88.dts:			spi-max-frequency = <100000>;
arch/arm/mach-s3c24xx/mach-qt2410.c:	.name		= "spi-gpio",
arch/arm/mach-s3c24xx/mach-jive.c:	.name		= "spi-gpio",
arch/arm/mach-s3c24xx/mach-jive.c:	.name		= "spi-gpio",
arch/arm/mach-s3c24xx/s3c2416.c:#include "spi-core.h"
arch/arm/mach-s3c24xx/s3c2443.c:#include "spi-core.h"
arch/arm/plat-samsung/devs.c:#include <linux/platform_data/spi-s3c64xx.h>
arch/arm/mach-w90x900/dev.c:#include <linux/platform_data/spi-nuc900.h>
arch/arm/mach-ep93xx/edb93xx.c:#include <linux/platform_data/spi-ep93xx.h>
arch/arm/mach-ep93xx/vision_ep9307.c:#include <linux/platform_data/spi-ep93xx.h>
arch/arm/mach-ep93xx/ts72xx.c:#include <linux/platform_data/spi-ep93xx.h>
arch/arm/mach-ep93xx/simone.c:#include <linux/platform_data/spi-ep93xx.h>
arch/arm/mach-ep93xx/core.c:#include <linux/platform_data/spi-ep93xx.h>
arch/arm/mach-imx/devices/devices-common.h:#include <linux/platform_data/spi-imx.h>
arch/arm/mach-davinci/board-da830-evm.c:#include <linux/platform_data/spi-davinci.h>
arch/arm/mach-davinci/board-da850-evm.c:#include <linux/platform_data/spi-davinci.h>
arch/arm/mach-davinci/dm365.c:#include <linux/platform_data/spi-davinci.h>
arch/arm/mach-davinci/board-mityomapl138.c:#include <linux/platform_data/spi-davinci.h>
arch/arm/mach-davinci/dm355.c:#include <linux/platform_data/spi-davinci.h>
arch/arm/mach-davinci/include/mach/da8xx.h:#include <linux/platform_data/spi-davinci.h>
arch/arm/mach-u300/dummyspichip.c:	struct dummy *p_dummy = dev_get_drvdata(&spi->dev);
arch/arm/mach-u300/dummyspichip.c:	spi->bits_per_word = 8;
arch/arm/mach-u300/dummyspichip.c:	spi->master->setup(spi);
arch/arm/mach-u300/dummyspichip.c:	spi->bits_per_word = 16;
arch/arm/mach-u300/dummyspichip.c:	spi->master->setup(spi);
arch/arm/mach-u300/dummyspichip.c:	dev_info(&spi->dev, "probing dummy SPI device\n");
arch/arm/mach-u300/dummyspichip.c:	dev_set_drvdata(&spi->dev, p_dummy);
arch/arm/mach-u300/dummyspichip.c:	status = device_create_file(&spi->dev, &dev_attr_looptest);
arch/arm/mach-u300/dummyspichip.c:		dev_dbg(&spi->dev, "device_create_file looptest failure.\n");
arch/arm/mach-u300/dummyspichip.c:	dev_set_drvdata(&spi->dev, NULL);
arch/arm/mach-u300/dummyspichip.c:	struct dummy *p_dummy = dev_get_drvdata(&spi->dev);
arch/arm/mach-u300/dummyspichip.c:	dev_info(&spi->dev, "removing dummy SPI device\n");
arch/arm/mach-u300/dummyspichip.c:	device_remove_file(&spi->dev, &dev_attr_looptest);
arch/arm/mach-u300/dummyspichip.c:	dev_set_drvdata(&spi->dev, NULL);
arch/arm/mach-u300/dummyspichip.c:		.name	= "spi-dummy",
arch/arm/mach-s3c64xx/mach-smartq.c:	.name			= "spi-gpio",
arch/arm/mach-s3c64xx/mach-crag6410.c:#include <linux/platform_data/spi-s3c64xx.h>
arch/arm/mach-s3c64xx/mach-crag6410-module.c:#include <linux/platform_data/spi-s3c64xx.h>
arch/arm/mach-omap2/board-n8x0.c:#include <linux/platform_data/spi-omap2-mcspi.h>
arch/arm/mach-omap2/omap_hwmod_7xx_data.c:#include <linux/platform_data/spi-omap2-mcspi.h>
arch/arm/mach-omap2/omap_hwmod_43xx_data.c:#include <linux/platform_data/spi-omap2-mcspi.h>
arch/arm/mach-omap2/omap_hwmod_54xx_data.c:#include <linux/platform_data/spi-omap2-mcspi.h>
arch/arm/mach-omap2/omap_hwmod_81xx_data.c:#include <linux/platform_data/spi-omap2-mcspi.h>
arch/arm/mach-omap2/omap_hwmod_3xxx_data.c:#include <linux/platform_data/spi-omap2-mcspi.h>
arch/arm/mach-omap2/omap_hwmod_44xx_data.c:#include <linux/platform_data/spi-omap2-mcspi.h>
arch/arm/mach-omap2/omap_hwmod_2430_data.c:#include <linux/platform_data/spi-omap2-mcspi.h>
arch/arm/mach-omap2/omap_hwmod_33xx_data.c:#include <linux/platform_data/spi-omap2-mcspi.h>
arch/arm/mach-omap2/omap_hwmod_33xx_43xx_ipblock_data.c:#include <linux/platform_data/spi-omap2-mcspi.h>
arch/arm/mach-omap2/omap_hwmod_2xxx_ipblock_data.c:#include <linux/platform_data/spi-omap2-mcspi.h>
arch/arm/mach-omap2/omap_hwmod_2420_data.c:#include <linux/platform_data/spi-omap2-mcspi.h>
arch/arm/boot/dts/armada-370-seagate-personal-cloud.dtsi:	spi-flash@0 {
arch/arm/boot/dts/armada-370-seagate-personal-cloud.dtsi:		compatible = "mxicy,mx25l8005", "jedec,spi-nor";
arch/arm/boot/dts/armada-370-seagate-personal-cloud.dtsi:		spi-max-frequency = <50000000>;
arch/arm/boot/dts/r8a7745-iwg22m.dtsi:		compatible = "sst,sst25vf016b", "jedec,spi-nor";
arch/arm/boot/dts/r8a7745-iwg22m.dtsi:		spi-max-frequency = <50000000>;
arch/arm/boot/dts/r8a7745-iwg22m.dtsi:		spi-tx-bus-width = <1>;
arch/arm/boot/dts/r8a7745-iwg22m.dtsi:		spi-rx-bus-width = <1>;
arch/arm/boot/dts/r8a7745-iwg22m.dtsi:		spi-cpol;
arch/arm/boot/dts/r8a7745-iwg22m.dtsi:		spi-cpha;
arch/arm/boot/dts/exynos4210-smdkv310.dts:		spi-max-frequency = <1000000>;
arch/arm/boot/dts/exynos4210-smdkv310.dts:			samsung,spi-feedback-delay = <0>;
arch/arm/boot/dts/armada-388-clearfog.dtsi:	mikro_spi_pins: mikro-spi-pins {
arch/arm/boot/dts/imx51-zii-rdu1.dts:	spi_gpio: spi-gpio {
arch/arm/boot/dts/imx51-zii-rdu1.dts:		compatible = "spi-gpio";
arch/arm/boot/dts/imx51-zii-rdu1.dts:			spi-max-frequency = <1000000>;
arch/arm/boot/dts/imx51-zii-rdu1.dts:			spi-cs-high;
arch/arm/boot/dts/imx51-zii-rdu1.dts:		spi-max-frequency = <6000000>;
arch/arm/boot/dts/imx51-zii-rdu1.dts:		spi-cs-high;
arch/arm/boot/dts/imx51-zii-rdu1.dts:		spi-max-frequency = <25000000>;
arch/arm/boot/dts/am574x-idk.dts:	spi-max-frequency = <96000000>;
arch/arm/boot/dts/am574x-idk.dts:		spi-max-frequency = <96000000>;
arch/arm/boot/dts/dm814x.dtsi:				ti,spi-num-cs = <4>;
arch/arm/boot/dts/at91sam9rlek.dts:					spi-max-frequency = <15000000>;
arch/arm/boot/dts/rk3288-veyron-chromebook.dtsi:		google,cros-ec-spi-pre-delay = <30>;
arch/arm/boot/dts/rk3288-veyron-chromebook.dtsi:		spi-max-frequency = <3000000>;
arch/arm/boot/dts/gemini-dlink-dir-685.dts:		compatible = "spi-gpio";
arch/arm/boot/dts/gemini-dlink-dir-685.dts:			spi-max-frequency = <20000000>;
arch/arm/boot/dts/gemini-dlink-dir-685.dts:			spi-cpol; /* Clock active low */
arch/arm/boot/dts/exynos5250-spring.dts:	samsung,spi-src-clk = <0>;
arch/arm/boot/dts/dove-d3plug.dts:	spi-flash@0 {
arch/arm/boot/dts/dove-d3plug.dts:		spi-max-frequency = <86000000>;
arch/arm/boot/dts/omap3-panel-sharp-ls037v7dw01.dtsi:		spi-max-frequency = <1000000>;
arch/arm/boot/dts/armada-xp-lenovo-ix4-300d.dts:		compatible = "spi-gpio";
arch/arm/boot/dts/armada-xp-lenovo-ix4-300d.dts:			spi-max-frequency = <100000>;
arch/arm/boot/dts/imx6dl-colibri-eval-v3.dts:		spi-max-frequency = <10000000>;
arch/arm/boot/dts/am335x-sl50.dts:		spi-max-frequency = <5000000>;
arch/arm/boot/dts/omap3-tao3530.dtsi:		spi-max-frequency = <48000000>;
arch/arm/boot/dts/omap3-tao3530.dtsi:		spi-cpha;
arch/arm/boot/dts/omap3-tao3530.dtsi:		spi-max-frequency = <48000000>;
arch/arm/boot/dts/omap3-tao3530.dtsi:		spi-cpha;
arch/arm/boot/dts/socfpga_cyclone5_sodia.dts:		spi-max-frequency = <100000000>;
arch/arm/boot/dts/omap4.dtsi:			ti,spi-num-cs = <4>;
arch/arm/boot/dts/omap4.dtsi:			ti,spi-num-cs = <2>;
arch/arm/boot/dts/omap4.dtsi:			ti,spi-num-cs = <2>;
arch/arm/boot/dts/omap4.dtsi:			ti,spi-num-cs = <1>;
arch/arm/boot/dts/at91-vinco.dts:					compatible = "n25q32b", "jedec,spi-nor";
arch/arm/boot/dts/at91-vinco.dts:					spi-max-frequency = <50000000>;
arch/arm/boot/dts/imx6ul-14x14-evk.dts:		spi-max-frequency = <29000000>;
arch/arm/boot/dts/armada-38x.dtsi:				spi0_pins: spi-pins-0 {
arch/arm/boot/dts/armada-38x.dtsi:				spi1_pins: spi-pins-1 {
arch/arm/boot/dts/kirkwood-rd88f6192.dts:				compatible = "st,m25p128", "jedec,spi-nor";
arch/arm/boot/dts/kirkwood-rd88f6192.dts:				spi-max-frequency = <20000000>;
arch/arm/boot/dts/tegra124-jetson-tk1.dts:		spi-max-frequency = <25000000>;
arch/arm/boot/dts/tegra124-jetson-tk1.dts:		spi-flash@0 {
arch/arm/boot/dts/tegra124-jetson-tk1.dts:			spi-max-frequency = <20000000>;
arch/arm/boot/dts/ls1021a.dtsi:			spi-num-chipselects = <6>;
arch/arm/boot/dts/ls1021a.dtsi:			spi-num-chipselects = <6>;
arch/arm/boot/dts/imx6qdl-ts7970.dtsi:		compatible = "micron,n25q064", "jedec,spi-nor";
arch/arm/boot/dts/imx6qdl-ts7970.dtsi:		spi-max-frequency = <20000000>;
arch/arm/boot/dts/imx28-cfa10049.dts:		compatible = "spi-gpio";
arch/arm/boot/dts/imx28-cfa10049.dts:			spi-max-frequency = <100000>;
arch/arm/boot/dts/imx28-cfa10049.dts:			spi-cpol;
arch/arm/boot/dts/imx28-cfa10049.dts:			spi-cpha;
arch/arm/boot/dts/imx28-cfa10049.dts:		compatible = "spi-gpio";
arch/arm/boot/dts/imx28-cfa10049.dts:			spi-max-frequency = <100000>;
arch/arm/boot/dts/imx28-cfa10049.dts:			spi-max-frequency = <100000>;
arch/arm/boot/dts/imx28-cfa10049.dts:			spi-max-frequency = <100000>;
arch/arm/boot/dts/r8a7743-iwg20m.dtsi:		compatible = "sst,sst25vf016b", "jedec,spi-nor";
arch/arm/boot/dts/r8a7743-iwg20m.dtsi:		spi-max-frequency = <50000000>;
arch/arm/boot/dts/r8a7743-iwg20m.dtsi:		spi-tx-bus-width = <1>;
arch/arm/boot/dts/r8a7743-iwg20m.dtsi:		spi-rx-bus-width = <1>;
arch/arm/boot/dts/r8a7743-iwg20m.dtsi:		spi-cpol;
arch/arm/boot/dts/r8a7743-iwg20m.dtsi:		spi-cpha;
arch/arm/boot/dts/armada-388-db.dts:	spi-flash@0 {
arch/arm/boot/dts/armada-388-db.dts:		compatible = "w25q32", "jedec,spi-nor";
arch/arm/boot/dts/armada-388-db.dts:		spi-max-frequency = <108000000>;
arch/arm/boot/dts/dra76-evm.dts:	spi-max-frequency = <96000000>;
arch/arm/boot/dts/dra76-evm.dts:		spi-max-frequency = <96000000>;
arch/arm/boot/dts/dove-cubox.dts:	spi-flash@0 {
arch/arm/boot/dts/dove-cubox.dts:		spi-max-frequency = <20000000>;
arch/arm/boot/dts/bcm988312hr.dts:	bspi-sel = <0>;
arch/arm/boot/dts/bcm988312hr.dts:		spi-max-frequency = <12500000>;
arch/arm/boot/dts/bcm988312hr.dts:		spi-cpol;
arch/arm/boot/dts/bcm988312hr.dts:		spi-cpha;
arch/arm/boot/dts/bcm958625hr.dts:	bspi-sel = <0>;
arch/arm/boot/dts/bcm958625hr.dts:		spi-max-frequency = <12500000>;
arch/arm/boot/dts/bcm958625hr.dts:		spi-cpol;
arch/arm/boot/dts/bcm958625hr.dts:		spi-cpha;
arch/arm/boot/dts/am437x-idk-evm.dts:		spi-max-frequency = <1000000>;
arch/arm/boot/dts/am437x-idk-evm.dts:		spi-cpol;
arch/arm/boot/dts/am437x-idk-evm.dts:	spi-max-frequency = <48000000>;
arch/arm/boot/dts/am437x-idk-evm.dts:		spi-max-frequency = <48000000>;
arch/arm/boot/dts/am437x-idk-evm.dts:		spi-cpol;
arch/arm/boot/dts/am437x-idk-evm.dts:		spi-cpha;
arch/arm/boot/dts/am437x-idk-evm.dts:		spi-tx-bus-width = <1>;
arch/arm/boot/dts/am437x-idk-evm.dts:		spi-rx-bus-width = <4>;
arch/arm/boot/dts/.suniv-f1c100s-licheepi-nano-with-lcd.dtb.dts.tmp:  compatible = "winbond,w25q128", "jedec,spi-nor";
arch/arm/boot/dts/.suniv-f1c100s-licheepi-nano-with-lcd.dtb.dts.tmp:  spi-max-frequency = <50000000>;
arch/arm/boot/dts/usb_a9g20_lpw.dts:					compatible = "mmc-spi-slot";
arch/arm/boot/dts/usb_a9g20_lpw.dts:					spi-max-frequency = <25000000>;
arch/arm/boot/dts/keystone-k2g-evm.dts:		compatible = "jedec,spi-nor";
arch/arm/boot/dts/keystone-k2g-evm.dts:		spi-max-frequency = <5000000>;
arch/arm/boot/dts/keystone-k2g-evm.dts:		compatible = "s25fl512s", "jedec,spi-nor";
arch/arm/boot/dts/keystone-k2g-evm.dts:		spi-tx-bus-width = <1>;
arch/arm/boot/dts/keystone-k2g-evm.dts:		spi-rx-bus-width = <4>;
arch/arm/boot/dts/keystone-k2g-evm.dts:		spi-max-frequency = <96000000>;
arch/arm/boot/dts/imx6dl-rex-basic.dts:		compatible = "sst,sst25vf016b", "jedec,spi-nor";
arch/arm/boot/dts/imx6dl-rex-basic.dts:		spi-max-frequency = <20000000>;
arch/arm/boot/dts/tegra124-apalis-eval.dts:		spi-max-frequency = <50000000>;
arch/arm/boot/dts/tegra124-apalis-eval.dts:			spi-max-frequency = <50000000>;
arch/arm/boot/dts/tegra124-apalis-eval.dts:		spi-max-frequency = <50000000>;
arch/arm/boot/dts/tegra124-apalis-eval.dts:			spi-max-frequency = <50000000>;
arch/arm/boot/dts/imx50-evk.dts:		compatible = "m25p32", "jedec,spi-nor";
arch/arm/boot/dts/imx50-evk.dts:		spi-max-frequency = <25000000>;
arch/arm/boot/dts/qcom-mdm9615-wp8548-mangoh-green.dts:		spi-max-frequency = <24000000>;
arch/arm/boot/dts/kirkwood-dir665.dts:				compatible = "mxicy,mx25l12805d", "jedec,spi-nor";
arch/arm/boot/dts/kirkwood-dir665.dts:				spi-max-frequency = <50000000>;
arch/arm/boot/dts/vf-colibri-eval-v3.dtsi:		spi-max-frequency = <10000000>;
arch/arm/boot/dts/imx6q-marsboard.dts:		spi-max-frequency = <20000000>;
arch/arm/boot/dts/imx27-phytec-phycore-som.dtsi:		spi-cs-high;
arch/arm/boot/dts/imx27-phytec-phycore-som.dtsi:		spi-max-frequency = <20000000>;
arch/arm/boot/dts/qcom-ipq8064-ap148.dts:				spi-max-frequency = <50000000>;
arch/arm/boot/dts/qcom-ipq8064-ap148.dts:					spi-max-frequency = <50000000>;
arch/arm/boot/dts/armada-370-db.dts:	spi-flash@0 {
arch/arm/boot/dts/armada-370-db.dts:		compatible = "mx25l25635e", "jedec,spi-nor";
arch/arm/boot/dts/armada-370-db.dts:		spi-max-frequency = <50000000>;
arch/arm/boot/dts/am57xx-idk-common.dtsi:		spi-max-frequency = <1000000>;
arch/arm/boot/dts/am57xx-idk-common.dtsi:		spi-cpol;
arch/arm/boot/dts/am57xx-idk-common.dtsi:	spi-max-frequency = <76800000>;
arch/arm/boot/dts/am57xx-idk-common.dtsi:		compatible = "s25fl256s1", "jedec,spi-nor";
arch/arm/boot/dts/am57xx-idk-common.dtsi:		spi-max-frequency = <76800000>;
arch/arm/boot/dts/am57xx-idk-common.dtsi:		spi-tx-bus-width = <1>;
arch/arm/boot/dts/am57xx-idk-common.dtsi:		spi-rx-bus-width = <4>;
arch/arm/boot/dts/r8a7792-wheat.dts:		compatible = "spansion,s25fl512s", "jedec,spi-nor";
arch/arm/boot/dts/r8a7792-wheat.dts:		spi-max-frequency = <30000000>;
arch/arm/boot/dts/r8a7792-wheat.dts:		spi-tx-bus-width = <4>;
arch/arm/boot/dts/r8a7792-wheat.dts:		spi-rx-bus-width = <4>;
arch/arm/boot/dts/r8a7792-wheat.dts:		spi-cpol;
arch/arm/boot/dts/r8a7792-wheat.dts:		spi-cpha;
arch/arm/boot/dts/at91sam9g20ek_common.dtsi:					spi-max-frequency = <50000000>;
arch/arm/boot/dts/armada-398-db.dts:	spi-flash@0 {
arch/arm/boot/dts/armada-398-db.dts:		compatible = "n25q128a13", "jedec,spi-nor";
arch/arm/boot/dts/armada-398-db.dts:		spi-max-frequency = <108000000>;
arch/arm/boot/dts/am437x-sk-evm.dts:	spi-max-frequency = <48000000>;
arch/arm/boot/dts/am437x-sk-evm.dts:		spi-max-frequency = <48000000>;
arch/arm/boot/dts/am437x-sk-evm.dts:		spi-cpol;
arch/arm/boot/dts/am437x-sk-evm.dts:		spi-cpha;
arch/arm/boot/dts/am437x-sk-evm.dts:		spi-tx-bus-width = <1>;
arch/arm/boot/dts/am437x-sk-evm.dts:		spi-rx-bus-width = <4>;
arch/arm/boot/dts/r8a7745.dtsi:			compatible = "renesas,qspi-r8a7745", "renesas,qspi";
arch/arm/boot/dts/armada-390-db.dts:	spi-flash@1 {
arch/arm/boot/dts/armada-390-db.dts:			     "jedec,spi-nor";
arch/arm/boot/dts/armada-390-db.dts:		spi-max-frequency = <108000000>;
arch/arm/boot/dts/omap3.dtsi:			ti,spi-num-cs = <4>;
arch/arm/boot/dts/omap3.dtsi:			ti,spi-num-cs = <2>;
arch/arm/boot/dts/omap3.dtsi:			ti,spi-num-cs = <2>;
arch/arm/boot/dts/omap3.dtsi:			ti,spi-num-cs = <1>;
arch/arm/boot/dts/socfpga_cyclone5_socdk.dts:		spi-max-frequency = <100000000>;
arch/arm/boot/dts/socfpga_cyclone5_socdk.dts:		partition@qspi-boot {
arch/arm/boot/dts/socfpga_cyclone5_socdk.dts:		partition@qspi-rootfs {
arch/arm/boot/dts/socfpga_cyclone5_socdk.dts:		spi-max-frequency = <1000000>;
arch/arm/boot/dts/omap5-cm-t54.dts:		spi-max-frequency = <1500000>;
arch/arm/boot/dts/motorola-cpcap-mapphone.dtsi:		spi-max-frequency = <3000000>;
arch/arm/boot/dts/motorola-cpcap-mapphone.dtsi:		spi-cs-high;
arch/arm/boot/dts/imx6q-cm-fx6.dts:		compatible = "st,m25p", "jedec,spi-nor";
arch/arm/boot/dts/imx6q-cm-fx6.dts:		spi-max-frequency = <20000000>;
arch/arm/boot/dts/socfpga_arria10_socdk.dtsi:		spi-max-frequency = <100000>;
arch/arm/boot/dts/am437x-cm-t43.dts:		compatible = "jedec,spi-nor";
arch/arm/boot/dts/am437x-cm-t43.dts:		spi-max-frequency = <20000000>;
arch/arm/boot/dts/dove-dove-db.dts:	spi-flash@0 {
arch/arm/boot/dts/dove-dove-db.dts:		spi-max-frequency = <20000000>;
arch/arm/boot/dts/r8a7778-bockw.dts:		compatible = "spansion,s25fl008k", "jedec,spi-nor";
arch/arm/boot/dts/r8a7778-bockw.dts:		spi-max-frequency = <104000000>;
arch/arm/boot/dts/imx6sx-sdb-reva.dts:		compatible = "spansion,s25fl128s", "jedec,spi-nor";
arch/arm/boot/dts/imx6sx-sdb-reva.dts:		spi-max-frequency = <66000000>;
arch/arm/boot/dts/imx6sx-sdb-reva.dts:		compatible = "spansion,s25fl128s", "jedec,spi-nor";
arch/arm/boot/dts/imx6sx-sdb-reva.dts:		spi-max-frequency = <66000000>;
arch/arm/boot/dts/keystone-k2hk-evm.dts:		spi-max-frequency = <54000000>;
arch/arm/boot/dts/at91-qil_a9260.dts:					spi-max-frequency = <1000000>;
arch/arm/boot/dts/imx6qdl-nit6xlite.dtsi:		spi-max-frequency = <20000000>;
arch/arm/boot/dts/bcm958525er.dts:	bspi-sel = <0>;
arch/arm/boot/dts/bcm958525er.dts:		spi-max-frequency = <12500000>;
arch/arm/boot/dts/bcm958525er.dts:		spi-cpol;
arch/arm/boot/dts/bcm958525er.dts:		spi-cpha;
arch/arm/boot/dts/imx6dl-aristainetos2_4.dts:		spi-max-frequency = <10000000>;
arch/arm/boot/dts/omap4-var-om44customboard.dtsi:		spi-max-frequency = <24000000>;
arch/arm/boot/dts/imx27-eukrea-mbimxsd27-baseboard.dts:		spi-cpol;
arch/arm/boot/dts/imx27-eukrea-mbimxsd27-baseboard.dts:		spi-max-frequency = <1500000>;
arch/arm/boot/dts/kirkwood-dreamplug.dts:				compatible = "mxicy,mx25l1606e", "jedec,spi-nor";
arch/arm/boot/dts/kirkwood-dreamplug.dts:				spi-max-frequency = <50000000>;
arch/arm/boot/dts/rk3036.dtsi:			spi_txd:spi-txd {
arch/arm/boot/dts/rk3036.dtsi:			spi_rxd:spi-rxd {
arch/arm/boot/dts/rk3036.dtsi:			spi_clk:spi-clk {
arch/arm/boot/dts/rk3036.dtsi:			spi_cs0:spi-cs0 {
arch/arm/boot/dts/rk3036.dtsi:			spi_cs1:spi-cs1 {
arch/arm/boot/dts/bcm4708-buffalo-wzr-1750dhp.dts:		compatible = "spi-gpio";
arch/arm/boot/dts/bcm4708-buffalo-wzr-1750dhp.dts:			spi-max-frequency = <100000>;
arch/arm/boot/dts/at91sam9x5ek.dtsi:					spi-max-frequency = <50000000>;
arch/arm/boot/dts/kirkwood-synology.dtsi:				compatible = "st,m25p80", "jedec,spi-nor";
arch/arm/boot/dts/kirkwood-synology.dtsi:				spi-max-frequency = <20000000>;
arch/arm/boot/dts/bcm958522er.dts:	bspi-sel = <0>;
arch/arm/boot/dts/bcm958522er.dts:		spi-max-frequency = <12500000>;
arch/arm/boot/dts/bcm958522er.dts:		spi-cpol;
arch/arm/boot/dts/bcm958522er.dts:		spi-cpha;
arch/arm/boot/dts/tegra124-venice2.dts:			spi-max-frequency = <4000000>;
arch/arm/boot/dts/tegra124-venice2.dts:			google,cros-ec-spi-msg-delay = <2000>;
arch/arm/boot/dts/tegra124-venice2.dts:		spi-max-frequency = <25000000>;
arch/arm/boot/dts/tegra124-venice2.dts:		spi-flash@0 {
arch/arm/boot/dts/tegra124-venice2.dts:			spi-max-frequency = <20000000>;
arch/arm/boot/dts/armada-385-turris-omnia.dts:	spi-nor@0 {
arch/arm/boot/dts/armada-385-turris-omnia.dts:		compatible = "spansion,s25fl164k", "jedec,spi-nor";
arch/arm/boot/dts/armada-385-turris-omnia.dts:		spi-max-frequency = <40000000>;
arch/arm/boot/dts/imx6qdl-dfi-fs700-m60.dtsi:		compatible = "sst,sst25vf040b", "jedec,spi-nor";
arch/arm/boot/dts/imx6qdl-dfi-fs700-m60.dtsi:		spi-max-frequency = <20000000>;
arch/arm/boot/dts/imx51-eukrea-mbimxsd51-baseboard.dts:		spi-max-frequency = <10000000>;
arch/arm/boot/dts/bcm958525xmc.dts:	bspi-sel = <0>;
arch/arm/boot/dts/bcm958525xmc.dts:		spi-max-frequency = <12500000>;
arch/arm/boot/dts/bcm958525xmc.dts:		spi-cpol;
arch/arm/boot/dts/bcm958525xmc.dts:		spi-cpha;
arch/arm/boot/dts/mt2701-evb.dts:		compatible = "jedec,spi-nor";
arch/arm/boot/dts/atlas7.dtsi:				compatible = "sirf,atlas7-qspi-nor";
arch/arm/boot/dts/atlas6.dtsi:				sirf,spi-num-chipselects = <1>;
arch/arm/boot/dts/atlas6.dtsi:				sirf,spi-num-chipselects = <1>;
arch/arm/boot/dts/imx6q-evi.dts:		spi-max-frequency = <20000000>;
arch/arm/boot/dts/imx6q-evi.dts:		spi-max-frequency = <5000000>;
arch/arm/boot/dts/imx6q-evi.dts:		spi-max-frequency = <2450000>;
arch/arm/boot/dts/imx6q-evi.dts:		spi-cs-high;
arch/arm/boot/dts/at91sam9263ek.dts:					spi-max-frequency = <50000000>;
arch/arm/boot/dts/rk3288-veyron.dtsi:		compatible = "jedec,spi-nor";
arch/arm/boot/dts/rk3288-veyron.dtsi:		spi-max-frequency = <50000000>;
arch/arm/boot/dts/exynos5250-smdk5250.dts:		spi-max-frequency = <1000000>;
arch/arm/boot/dts/exynos5250-smdk5250.dts:			samsung,spi-feedback-delay = <0>;
arch/arm/boot/dts/armada-38x-solidrun-microsom.dtsi:	w25q32: spi-flash@0 {
arch/arm/boot/dts/armada-38x-solidrun-microsom.dtsi:		compatible = "w25q32", "jedec,spi-nor";
arch/arm/boot/dts/armada-38x-solidrun-microsom.dtsi:		spi-max-frequency = <3000000>;
arch/arm/boot/dts/keystone.dtsi:			ti,davinci-spi-intr-line = <0>;
arch/arm/boot/dts/keystone.dtsi:			ti,davinci-spi-intr-line = <0>;
arch/arm/boot/dts/keystone.dtsi:			ti,davinci-spi-intr-line = <0>;
arch/arm/boot/dts/bcm958623hr.dts:	bspi-sel = <0>;
arch/arm/boot/dts/bcm958623hr.dts:		spi-max-frequency = <12500000>;
arch/arm/boot/dts/bcm958623hr.dts:		spi-cpol;
arch/arm/boot/dts/bcm958623hr.dts:		spi-cpha;
arch/arm/boot/dts/exynos5420-peach-pit.dts:	ec_spi_cs: ec-spi-cs {
arch/arm/boot/dts/exynos5420-peach-pit.dts:	samsung,spi-src-clk = <0>;
arch/arm/boot/dts/exynos5420-peach-pit.dts:		spi-max-frequency = <3125000>;
arch/arm/boot/dts/exynos5420-peach-pit.dts:			samsung,spi-feedback-delay = <1>;
arch/arm/boot/dts/r8a7792.dtsi:			compatible = "renesas,qspi-r8a7792", "renesas,qspi";
arch/arm/boot/dts/qcom-ipq8064.dtsi:				compatible = "qcom,spi-qup-v1.1.1";
arch/arm/boot/dts/lpc4350-hitex-eval.dts:		compatible = "jedec,spi-nor";
arch/arm/boot/dts/lpc4350-hitex-eval.dts:		spi-rx-bus-width = <4>;
arch/arm/boot/dts/imx27-pdk.dts:		spi-cs-high;
arch/arm/boot/dts/imx27-pdk.dts:		spi-max-frequency = <1000000>;
arch/arm/boot/dts/keystone-k2g.dtsi:			compatible = "ti,k2g-qspi", "cdns,qspi-nor";
arch/arm/boot/dts/keystone-k2g.dtsi:			ti,davinci-spi-intr-line = <0>;
arch/arm/boot/dts/keystone-k2g.dtsi:			ti,davinci-spi-intr-line = <0>;
arch/arm/boot/dts/keystone-k2g.dtsi:			ti,davinci-spi-intr-line = <0>;
arch/arm/boot/dts/keystone-k2g.dtsi:			ti,davinci-spi-intr-line = <0>;
arch/arm/boot/dts/vf610-twr.dts:		spi-max-frequency = <16000000>;
arch/arm/boot/dts/vf610-twr.dts:		spi-cpol;
arch/arm/boot/dts/vf610-twr.dts:		spi-cpha;
arch/arm/boot/dts/armada-xp-synology-ds414.dts:	spi-flash@0 {
arch/arm/boot/dts/armada-xp-synology-ds414.dts:		compatible = "micron,n25q064", "jedec,spi-nor";
arch/arm/boot/dts/armada-xp-synology-ds414.dts:		spi-max-frequency = <20000000>;
arch/arm/boot/dts/vfxxx.dtsi:				spi-num-chipselects = <6>;
arch/arm/boot/dts/vfxxx.dtsi:				spi-num-chipselects = <4>;
arch/arm/boot/dts/vfxxx.dtsi:				spi-num-chipselects = <2>;
arch/arm/boot/dts/vfxxx.dtsi:				spi-num-chipselects = <2>;
arch/arm/boot/dts/imx6qdl-nitrogen6_som2.dtsi:		spi-max-frequency = <20000000>;
arch/arm/boot/dts/socfpga_cyclone5_sockit.dts:		spi-max-frequency = <100000000>;
arch/arm/boot/dts/qcom-msm8960.dtsi:				compatible = "qcom,spi-qup-v1.1.1";
arch/arm/boot/dts/qcom-msm8960.dtsi:				spi-max-frequency = <24000000>;
arch/arm/boot/dts/omap3-cm-t3x.dtsi:		spi-max-frequency = <1500000>;
arch/arm/boot/dts/kirkwood-cloudbox.dts:				compatible = "mxicy,mx25l4005a", "jedec,spi-nor";
arch/arm/boot/dts/kirkwood-cloudbox.dts:				spi-max-frequency = <20000000>;
arch/arm/boot/dts/qcom-ipq4019-ap.dk01.1.dtsi:				spi-max-frequency = <24000000>;
arch/arm/boot/dts/qcom-mdm9615.dtsi:				compatible = "qcom,spi-qup-v1.1.1";
arch/arm/boot/dts/qcom-mdm9615.dtsi:				spi-max-frequency = <24000000>;
arch/arm/boot/dts/kirkwood-b3.dts:				compatible = "st,m25p16", "jedec,spi-nor";
arch/arm/boot/dts/kirkwood-b3.dts:				spi-max-frequency = <40000000>;
arch/arm/boot/dts/lpc4357-ea4357-devkit.dts:		compatible = "jedec,spi-nor";
arch/arm/boot/dts/lpc4357-ea4357-devkit.dts:		spi-cpol;
arch/arm/boot/dts/lpc4357-ea4357-devkit.dts:		spi-cpha;
arch/arm/boot/dts/lpc4357-ea4357-devkit.dts:		spi-rx-bus-width = <4>;
arch/arm/boot/dts/imx6qdl-tx6.dtsi:		spi-max-frequency = <54000000>;
arch/arm/boot/dts/imx6qdl-tx6.dtsi:		spi-max-frequency = <54000000>;
arch/arm/boot/dts/aspeed-g4.dtsi:				compatible = "jedec,spi-nor";
arch/arm/boot/dts/aspeed-g4.dtsi:				compatible = "jedec,spi-nor";
arch/arm/boot/dts/omap5.dtsi:			ti,spi-num-cs = <4>;
arch/arm/boot/dts/omap5.dtsi:			ti,spi-num-cs = <2>;
arch/arm/boot/dts/omap5.dtsi:			ti,spi-num-cs = <2>;
arch/arm/boot/dts/omap5.dtsi:			ti,spi-num-cs = <1>;
arch/arm/boot/dts/imx53-ppd.dts:		spi-max-frequency = <1000000>;
arch/arm/boot/dts/imx53-ppd.dts:		spi-max-frequency = <1000000>;
arch/arm/boot/dts/imx53-ppd.dts:		spi-max-frequency = <1000000>;
arch/arm/boot/dts/imx53-ppd.dts:		spi-max-frequency = <1000000>;
arch/arm/boot/dts/imx53-ppd.dts:		spi-max-frequency = <1000000>;
arch/arm/boot/dts/dm8168-evm.dts:		spi-max-frequency = <48000000>;
arch/arm/boot/dts/bcm-hr2.dtsi:			compatible = "brcm,spi-bcm-qspi", "brcm,spi-nsp-qspi";
arch/arm/boot/dts/imx6q-rex-pro.dts:		compatible = "sst,sst25vf032b", "jedec,spi-nor";
arch/arm/boot/dts/imx6q-rex-pro.dts:		spi-max-frequency = <20000000>;
arch/arm/boot/dts/keystone-k2g-ice.dts:		compatible = "s25fl256s1", "jedec,spi-nor";
arch/arm/boot/dts/keystone-k2g-ice.dts:		spi-tx-bus-width = <1>;
arch/arm/boot/dts/keystone-k2g-ice.dts:		spi-rx-bus-width = <4>;
arch/arm/boot/dts/keystone-k2g-ice.dts:		spi-max-frequency = <96000000>;
arch/arm/boot/dts/imx51-digi-connectcore-som.dtsi:		spi-max-frequency = <16000000>;
arch/arm/boot/dts/imx51-digi-connectcore-som.dtsi:		spi-cs-high;
arch/arm/boot/dts/r8a7778.dtsi:		compatible = "renesas,hspi-r8a7778", "renesas,hspi";
arch/arm/boot/dts/r8a7778.dtsi:		compatible = "renesas,hspi-r8a7778", "renesas,hspi";
arch/arm/boot/dts/r8a7778.dtsi:		compatible = "renesas,hspi-r8a7778", "renesas,hspi";
arch/arm/boot/dts/dove-d2plug.dts:	spi-flash@0 {
arch/arm/boot/dts/dove-d2plug.dts:		spi-max-frequency = <20000000>;
arch/arm/boot/dts/imx6sx-nitrogen6sx.dts:		spi-max-frequency = <20000000>;
arch/arm/boot/dts/kirkwood-netxbig.dtsi:				compatible = "mxicy,mx25l4005a", "jedec,spi-nor";
arch/arm/boot/dts/kirkwood-netxbig.dtsi:				spi-max-frequency = <20000000>;
arch/arm/boot/dts/at91sam9260ek.dts:					spi-max-frequency = <50000000>;
arch/arm/boot/dts/armada-xp-db-xc3-24g4xg.dts:	spi-flash@0 {
arch/arm/boot/dts/armada-xp-db-xc3-24g4xg.dts:		spi-max-frequency = <20000000>;
arch/arm/boot/dts/am335x-icev2.dts:		spi-max-frequency = <1000000>;
arch/arm/boot/dts/am335x-icev2.dts:		spi-cpol;
arch/arm/boot/dts/am335x-icev2.dts:		compatible = "winbond,w25q64", "jedec,spi-nor";
arch/arm/boot/dts/am335x-icev2.dts:		spi-max-frequency = <80000000>;
arch/arm/boot/dts/zynq-7000.dtsi:			compatible = "xlnx,zynq-spi-r1p6";
arch/arm/boot/dts/zynq-7000.dtsi:			compatible = "xlnx,zynq-spi-r1p6";
arch/arm/boot/dts/r8a7791-koelsch.dts:		compatible = "spansion,s25fl512s", "jedec,spi-nor";
arch/arm/boot/dts/r8a7791-koelsch.dts:		spi-max-frequency = <30000000>;
arch/arm/boot/dts/r8a7791-koelsch.dts:		spi-tx-bus-width = <4>;
arch/arm/boot/dts/r8a7791-koelsch.dts:		spi-rx-bus-width = <4>;
arch/arm/boot/dts/r8a7791-koelsch.dts:		spi-cpha;
arch/arm/boot/dts/r8a7791-koelsch.dts:		spi-cpol;
arch/arm/boot/dts/r8a7791-koelsch.dts:		spi-max-frequency = <6000000>;
arch/arm/boot/dts/r8a7791-koelsch.dts:		spi-cpol;
arch/arm/boot/dts/r8a7791-koelsch.dts:		spi-cpha;
arch/arm/boot/dts/armada-388-gp.dts:	spi-flash@0 {
arch/arm/boot/dts/armada-388-gp.dts:		compatible = "st,m25p128", "jedec,spi-nor";
arch/arm/boot/dts/armada-388-gp.dts:		spi-max-frequency = <50000000>;
arch/arm/boot/dts/mt2701.dtsi:		clock-names = "parent-clk", "sel-clk", "spi-clk";
arch/arm/boot/dts/mt2701.dtsi:		clock-names = "parent-clk", "sel-clk", "spi-clk";
arch/arm/boot/dts/mt2701.dtsi:		clock-names = "parent-clk", "sel-clk", "spi-clk";
arch/arm/boot/dts/qcom-ipq4019.dtsi:			compatible = "qcom,spi-qup-v2.2.1";
arch/arm/boot/dts/efm32gg-dk3750.dts:				compatible = "mmc-spi-slot";
arch/arm/boot/dts/efm32gg-dk3750.dts:				spi-max-frequency = <100000>;
arch/arm/boot/dts/efm32gg-dk3750.dts:				spi-max-frequency = <6000000>;
arch/arm/boot/dts/mt7623.dtsi:		clock-names = "parent-clk", "sel-clk", "spi-clk";
arch/arm/boot/dts/mt7623.dtsi:		clock-names = "parent-clk", "sel-clk", "spi-clk";
arch/arm/boot/dts/mt7623.dtsi:		clock-names = "parent-clk", "sel-clk", "spi-clk";
arch/arm/boot/dts/imx6qdl-sabrelite.dtsi:		compatible = "sst,sst25vf016b", "jedec,spi-nor";
arch/arm/boot/dts/imx6qdl-sabrelite.dtsi:		spi-max-frequency = <20000000>;
arch/arm/boot/dts/socfpga_cyclone5_socrates.dts:		spi-max-frequency = <100000000>;
arch/arm/boot/dts/suniv-f1c100s-licheepi-nano.dts.tf:		compatible = "winbond,w25q128", "jedec,spi-nor";
arch/arm/boot/dts/suniv-f1c100s-licheepi-nano.dts.tf:		spi-max-frequency = <40000000>;
arch/arm/boot/dts/vf610-zii-dev-rev-c.dts:	spi-num-chipselects = <2>;
arch/arm/boot/dts/vf610-zii-dev-rev-c.dts:		compatible = "m25p128", "jedec,spi-nor";
arch/arm/boot/dts/vf610-zii-dev-rev-c.dts:		spi-max-frequency = <1000000>;
arch/arm/boot/dts/vf610-zii-dev-rev-c.dts:		spi-max-frequency = <7500000>;
arch/arm/boot/dts/vf610-zii-dev-rev-c.dts:		fsl,spi-cs-sck-delay = <180>;
arch/arm/boot/dts/vf610-zii-dev-rev-c.dts:		fsl,spi-sck-cs-delay = <250>;
arch/arm/boot/dts/bcm953012hr.dts:	spi-max-frequency = <62500000>;
arch/arm/boot/dts/imx6qdl-zii-rdu2.dtsi:		compatible = "st,m25p128", "jedec,spi-nor";
arch/arm/boot/dts/imx6qdl-zii-rdu2.dtsi:		spi-max-frequency = <20000000>;
arch/arm/boot/dts/r8a7793-gose.dts:		compatible = "spansion,s25fl512s", "jedec,spi-nor";
arch/arm/boot/dts/r8a7793-gose.dts:		spi-max-frequency = <30000000>;
arch/arm/boot/dts/r8a7793-gose.dts:		spi-tx-bus-width = <4>;
arch/arm/boot/dts/r8a7793-gose.dts:		spi-rx-bus-width = <4>;
arch/arm/boot/dts/r8a7793-gose.dts:		spi-cpol;
arch/arm/boot/dts/r8a7793-gose.dts:		spi-cpha;
arch/arm/boot/dts/ls1021a-twr.dts:		spi-max-frequency = <16000000>;
arch/arm/boot/dts/ls1021a-twr.dts:		spi-cpol;
arch/arm/boot/dts/ls1021a-twr.dts:		spi-cpha;
arch/arm/boot/dts/am43x-epos-evm.dts:	spi-max-frequency = <48000000>;
arch/arm/boot/dts/am43x-epos-evm.dts:		spi-max-frequency = <48000000>;
arch/arm/boot/dts/am43x-epos-evm.dts:		spi-cpol;
arch/arm/boot/dts/am43x-epos-evm.dts:		spi-cpha;
arch/arm/boot/dts/am43x-epos-evm.dts:		spi-tx-bus-width = <1>;
arch/arm/boot/dts/am43x-epos-evm.dts:		spi-rx-bus-width = <4>;
arch/arm/boot/dts/sama5d3xmb_cmp.dtsi:					spi-max-frequency = <50000000>;
arch/arm/boot/dts/armada-xp-gp.dts:	spi-flash@0 {
arch/arm/boot/dts/armada-xp-gp.dts:		compatible = "n25q128a13", "jedec,spi-nor";
arch/arm/boot/dts/armada-xp-gp.dts:		spi-max-frequency = <108000000>;
Binary file arch/arm/boot/dts/suniv-f1c100s-licheepi-nano-with-lcd.dtb matches
arch/arm/boot/dts/imx6qdl-nitrogen6_max.dtsi:		spi-max-frequency = <20000000>;
arch/arm/boot/dts/armada-xp-linksys-mamba.dts:	spi-flash@0 {
arch/arm/boot/dts/armada-xp-linksys-mamba.dts:		spi-max-frequency = <40000000>;
arch/arm/boot/dts/r8a7794-silk.dts:		compatible = "spansion,s25fl512s", "jedec,spi-nor";
arch/arm/boot/dts/r8a7794-silk.dts:		spi-max-frequency = <30000000>;
arch/arm/boot/dts/r8a7794-silk.dts:		spi-tx-bus-width = <4>;
arch/arm/boot/dts/r8a7794-silk.dts:		spi-rx-bus-width = <4>;
arch/arm/boot/dts/r8a7794-silk.dts:		spi-cpol;
arch/arm/boot/dts/r8a7794-silk.dts:		spi-cpha;
arch/arm/boot/dts/armada-xp-db-dxbc2.dts:	spi-flash@0 {
arch/arm/boot/dts/armada-xp-db-dxbc2.dts:		spi-max-frequency = <20000000>;
arch/arm/boot/dts/am33xx.dtsi:			ti,spi-num-cs = <2>;
arch/arm/boot/dts/am33xx.dtsi:			ti,spi-num-cs = <2>;
arch/arm/boot/dts/lpc3250-phy3250.dts:		spi-max-frequency = <5000000>;
arch/arm/boot/dts/am335x-moxa-uc-8100-me-t.dts:		spi-max-frequency = <40000000>;
arch/arm/boot/dts/am335x-moxa-uc-8100-me-t.dts:		spi-cpol;
arch/arm/boot/dts/am335x-moxa-uc-8100-me-t.dts:		spi-cpha;
arch/arm/boot/dts/imx53-tx53.dtsi:		spi-max-frequency = <54000000>;
arch/arm/boot/dts/imx53-tx53.dtsi:		spi-max-frequency = <54000000>;
arch/arm/boot/dts/r8a7791.dtsi:		compatible = "renesas,qspi-r8a7791", "renesas,qspi";
arch/arm/boot/dts/imx28-sps1.dts:					spi-max-frequency = <40000000>;
arch/arm/boot/dts/qcom-apq8064.dtsi:				compatible = "qcom,spi-qup-v1.1.1";
arch/arm/boot/dts/at91-sama5d4_xplained.dts:					spi-max-frequency = <50000000>;
arch/arm/boot/dts/exynos5440-ssdk5440.dts:		spi-max-frequency = <15625000>;
arch/arm/boot/dts/exynos5440-ssdk5440.dts:			samsung,spi-feedback-delay = <0>;
arch/arm/boot/dts/bcm-nsp.dtsi:			compatible = "brcm,spi-bcm-qspi", "brcm,spi-nsp-qspi";
arch/arm/boot/dts/bcm5301x.dtsi:		compatible = "brcm,spi-bcm-qspi", "brcm,spi-nsp-qspi";
arch/arm/boot/dts/bcm5301x.dtsi:		spi_nor: spi-nor@0 {
arch/arm/boot/dts/bcm5301x.dtsi:			compatible = "jedec,spi-nor";
arch/arm/boot/dts/bcm5301x.dtsi:			spi-max-frequency = <20000000>;
arch/arm/boot/dts/socfpga_arria5_socdk.dts:		spi-max-frequency = <100000000>;
arch/arm/boot/dts/socfpga_arria5_socdk.dts:		partition@qspi-boot {
arch/arm/boot/dts/socfpga_arria5_socdk.dts:		partition@qspi-rootfs {
arch/arm/boot/dts/keystone-k2l.dtsi:       ti,davinci-spi-num-cs = <5>;
arch/arm/boot/dts/keystone-k2l.dtsi:       ti,davinci-spi-num-cs = <3>;
arch/arm/boot/dts/keystone-k2l.dtsi:       ti,davinci-spi-num-cs = <5>;
arch/arm/boot/dts/imx6qdl-aristainetos.dtsi:		compatible = "micron,n25q128a11", "jedec,spi-nor";
arch/arm/boot/dts/imx6qdl-aristainetos.dtsi:		spi-max-frequency = <20000000>;
arch/arm/boot/dts/imx28-duckbill-2-spi.dts:					spi-cpha;
arch/arm/boot/dts/imx28-duckbill-2-spi.dts:					spi-cpol;
arch/arm/boot/dts/imx28-duckbill-2-spi.dts:					spi-max-frequency = <8000000>;
arch/arm/boot/dts/omap3-n950.dts:		spi-max-frequency = <48000000>;
arch/arm/boot/dts/da850-lego-ev3.dts:		compatible = "n25q128a13", "jedec,spi-nor";
arch/arm/boot/dts/da850-lego-ev3.dts:		spi-max-frequency = <50000000>;
arch/arm/boot/dts/da850-lego-ev3.dts:		ti,spi-wdelay = <8>;
arch/arm/boot/dts/da850-lego-ev3.dts:		spi-max-frequency = <10000000>;
arch/arm/boot/dts/da850-lego-ev3.dts:		spi-max-frequency = <10000000>;
arch/arm/boot/dts/keystone-k2e-evm.dts:		spi-max-frequency = <54000000>;
arch/arm/boot/dts/atlas6-evb.dts:					spi-max-frequency = <1000000>;
arch/arm/boot/dts/tegra124-nyan.dtsi:			spi-max-frequency = <3000000>;
arch/arm/boot/dts/tegra124-nyan.dtsi:			google,cros-ec-spi-msg-delay = <2000>;
arch/arm/boot/dts/tegra124-nyan.dtsi:		spi-max-frequency = <25000000>;
arch/arm/boot/dts/tegra124-nyan.dtsi:			spi-max-frequency = <25000000>;
arch/arm/boot/dts/imx6qdl-aristainetos2.dtsi:		compatible = "micron,n25q128a11", "jedec,spi-nor";
arch/arm/boot/dts/imx6qdl-aristainetos2.dtsi:		spi-max-frequency = <20000000>;
arch/arm/boot/dts/r8a7790.dtsi:		compatible = "renesas,qspi-r8a7790", "renesas,qspi";
arch/arm/boot/dts/omap4-sdp.dts:		spi-max-frequency = <24000000>;
arch/arm/boot/dts/omap3-pandora-common.dtsi:		spi-max-frequency = <1000000>;
arch/arm/boot/dts/omap3-pandora-common.dtsi:		spi-max-frequency = <100000>;
arch/arm/boot/dts/omap3-pandora-common.dtsi:		spi-cpol;
arch/arm/boot/dts/omap3-pandora-common.dtsi:		spi-cpha;
arch/arm/boot/dts/omap3-lilly-a83x.dtsi:		spi-max-frequency = <1000000>;
arch/arm/boot/dts/imx6qdl-ts4900.dtsi:		compatible = "micron,n25q064", "jedec,spi-nor";
arch/arm/boot/dts/imx6qdl-ts4900.dtsi:		spi-max-frequency = <20000000>;
arch/arm/boot/dts/r7s72100.dtsi:		compatible = "renesas,rspi-r7s72100", "renesas,rspi-rz";
arch/arm/boot/dts/r7s72100.dtsi:		compatible = "renesas,rspi-r7s72100", "renesas,rspi-rz";
arch/arm/boot/dts/r7s72100.dtsi:		compatible = "renesas,rspi-r7s72100", "renesas,rspi-rz";
arch/arm/boot/dts/r7s72100.dtsi:		compatible = "renesas,rspi-r7s72100", "renesas,rspi-rz";
arch/arm/boot/dts/r7s72100.dtsi:		compatible = "renesas,rspi-r7s72100", "renesas,rspi-rz";
arch/arm/boot/dts/prima2.dtsi:				sirf,spi-num-chipselects = <1>;
arch/arm/boot/dts/prima2.dtsi:				sirf,spi-num-chipselects = <1>;
arch/arm/boot/dts/imx27-apf27dev.dts:		spi-max-frequency = <10000000>;
arch/arm/boot/dts/spear1310-evb.dts:					spi-max-frequency = <1000000>;
arch/arm/boot/dts/spear1310-evb.dts:					spi-cpha;
arch/arm/boot/dts/spear1310-evb.dts:					spi-max-frequency = <12000000>;
arch/arm/boot/dts/spear1310-evb.dts:					spi-cpol;
arch/arm/boot/dts/spear1310-evb.dts:					spi-cpha;
arch/arm/boot/dts/spear1310-evb.dts:					spi-max-frequency = <25000000>;
arch/arm/boot/dts/spear1310-evb.dts:					spi-cpha;
arch/arm/boot/dts/kirkwood-ts219.dtsi:				compatible = "m25p128", "jedec,spi-nor";
arch/arm/boot/dts/kirkwood-ts219.dtsi:				spi-max-frequency = <20000000>;
arch/arm/boot/dts/r7s72100-genmai.dts:		spi-max-frequency = <5000000>;
arch/arm/boot/dts/tegra30-colibri-eval-v3.dts:		spi-max-frequency = <25000000>;
arch/arm/boot/dts/tegra30-colibri-eval-v3.dts:			spi-max-frequency = <10000000>;
arch/arm/boot/dts/tegra30-colibri-eval-v3.dts:			spi-max-frequency = <25000000>;
Binary file arch/arm/boot/dts/suniv-f1c100s-licheepi-nano.dtb matches
arch/arm/boot/dts/tegra124-apalis.dtsi:		spi-max-frequency = <25000000>;
arch/arm/boot/dts/dra72-evm-common.dtsi:	spi-max-frequency = <76800000>;
arch/arm/boot/dts/dra72-evm-common.dtsi:		spi-max-frequency = <76800000>;
arch/arm/boot/dts/dra72-evm-common.dtsi:		spi-tx-bus-width = <1>;
arch/arm/boot/dts/dra72-evm-common.dtsi:		spi-rx-bus-width = <4>;
arch/arm/boot/dts/at91-sama5d2_xplained.dts:					spi-max-frequency = <50000000>;
arch/arm/boot/dts/rk3288-phycore-som.dtsi:		compatible = "micron,n25q128a13", "jedec,spi-nor";
arch/arm/boot/dts/rk3288-phycore-som.dtsi:		spi-max-frequency = <50000000>;
arch/arm/boot/dts/dra7.dtsi:			ti,spi-num-cs = <4>;
arch/arm/boot/dts/dra7.dtsi:			ti,spi-num-cs = <2>;
arch/arm/boot/dts/dra7.dtsi:			ti,spi-num-cs = <2>;
arch/arm/boot/dts/dra7.dtsi:			ti,spi-num-cs = <1>;
arch/arm/boot/dts/imx6sl-evk.dts:		compatible = "st,m25p32", "jedec,spi-nor";
arch/arm/boot/dts/imx6sl-evk.dts:		spi-max-frequency = <20000000>;
arch/arm/boot/dts/r8a7793.dtsi:		compatible = "renesas,qspi-r8a7793", "renesas,qspi";
arch/arm/boot/dts/omap3-gta04.dtsi:		compatible = "spi-gpio";
arch/arm/boot/dts/omap3-gta04.dtsi:			spi-max-frequency = <100000>;
arch/arm/boot/dts/omap3-gta04.dtsi:			spi-cpol;
arch/arm/boot/dts/omap3-gta04.dtsi:			spi-cpha;
arch/arm/boot/dts/armada-385-synology-ds116.dts:	spi-flash@0 {
arch/arm/boot/dts/armada-385-synology-ds116.dts:		compatible = "macronix,mx25l6405d", "jedec,spi-nor";
arch/arm/boot/dts/armada-385-synology-ds116.dts:		spi-max-frequency = <50000000>;
arch/arm/boot/dts/tegra30-beaver.dts:		spi-max-frequency = <25000000>;
arch/arm/boot/dts/tegra30-beaver.dts:		spi-flash@1 {
arch/arm/boot/dts/tegra30-beaver.dts:			spi-max-frequency = <20000000>;
arch/arm/boot/dts/rk322x.dtsi:		spi-0 {
arch/arm/boot/dts/rk322x.dtsi:		spi-1 {
arch/arm/boot/dts/bcm47081-buffalo-wzr-600dhp2.dts:		compatible = "spi-gpio";
arch/arm/boot/dts/bcm47081-buffalo-wzr-600dhp2.dts:			spi-max-frequency = <100000>;
arch/arm/boot/dts/imx6q-bx50v3.dtsi:		spi-max-frequency = <10000000>;
arch/arm/boot/dts/imx51-babbage.dts:		spi-max-frequency = <6000000>;
arch/arm/boot/dts/imx51-babbage.dts:		spi-cs-high;
arch/arm/boot/dts/imx51-babbage.dts:		spi-max-frequency = <25000000>;
arch/arm/boot/dts/imx28-m28evk.dts:					compatible = "m25p80", "jedec,spi-nor";
arch/arm/boot/dts/imx28-m28evk.dts:					spi-max-frequency = <40000000>;
arch/arm/boot/dts/ste-u300.dts:			spi-dummy@1 {
arch/arm/boot/dts/ste-u300.dts:				spi-max-frequency = <20000000>;
arch/arm/boot/dts/armada-xp-db.dts:	spi-flash@0 {
arch/arm/boot/dts/armada-xp-db.dts:		compatible = "m25p64", "jedec,spi-nor";
arch/arm/boot/dts/armada-xp-db.dts:		spi-max-frequency = <20000000>;
arch/arm/boot/dts/imx7-colibri-eval-v3.dtsi:		spi-max-frequency = <10000000>;
arch/arm/boot/dts/bcm953012k.dts:	spi-max-frequency = <62500000>;
arch/arm/boot/dts/imx28-cfa10055.dts:		compatible = "spi-gpio";
arch/arm/boot/dts/imx28-cfa10055.dts:			spi-max-frequency = <100000>;
arch/arm/boot/dts/imx28-cfa10055.dts:			spi-cpol;
arch/arm/boot/dts/imx28-cfa10055.dts:			spi-cpha;
arch/arm/boot/dts/exynos4412-trats2.dts:		spi-max-frequency = <50000000>;
arch/arm/boot/dts/exynos4412-trats2.dts:			samsung,spi-feedback-delay = <2>;
arch/arm/boot/dts/aspeed-g5.dtsi:				compatible = "jedec,spi-nor";
arch/arm/boot/dts/aspeed-g5.dtsi:				compatible = "jedec,spi-nor";
arch/arm/boot/dts/aspeed-g5.dtsi:				compatible = "jedec,spi-nor";
arch/arm/boot/dts/aspeed-g5.dtsi:				compatible = "jedec,spi-nor";
arch/arm/boot/dts/aspeed-g5.dtsi:				compatible = "jedec,spi-nor";
arch/arm/boot/dts/aspeed-g5.dtsi:				compatible = "jedec,spi-nor";
arch/arm/boot/dts/aspeed-g5.dtsi:				compatible = "jedec,spi-nor";
arch/arm/boot/dts/imx53-smd.dts:		spi-max-frequency = <8000000>;
arch/arm/boot/dts/imx53-smd.dts:		compatible = "st,m25p32", "st,m25p", "jedec,spi-nor";
arch/arm/boot/dts/imx53-smd.dts:		spi-max-frequency = <20000000>;
arch/arm/boot/dts/stih407-pinctrl.dtsi:						spi-fsm-clk = <&pio40 1 ALT1 OUT>;
arch/arm/boot/dts/stih407-pinctrl.dtsi:						spi-fsm-cs = <&pio40 0 ALT1 OUT>;
arch/arm/boot/dts/stih407-pinctrl.dtsi:						spi-fsm-mosi = <&pio40 2 ALT1 OUT>;
arch/arm/boot/dts/stih407-pinctrl.dtsi:						spi-fsm-miso = <&pio40 3 ALT1 IN>;
arch/arm/boot/dts/stih407-pinctrl.dtsi:						spi-fsm-hol = <&pio40 5 ALT1 OUT>;
arch/arm/boot/dts/stih407-pinctrl.dtsi:						spi-fsm-wp = <&pio40 4 ALT1 OUT>;
arch/arm/boot/dts/ls1021a-moxa-uc-8410a.dts:	fsl,spi-num-chipselects = <2>;
arch/arm/boot/dts/ls1021a-moxa-uc-8410a.dts:	fsl,spi-flash-chipselects = <0>;
arch/arm/boot/dts/ls1021a-moxa-uc-8410a.dts:	fsl,qspi-has-second-chip;
arch/arm/boot/dts/ls1021a-moxa-uc-8410a.dts:		spi-max-frequency = <20000000>;
arch/arm/boot/dts/sama5d3xmb.dtsi:					spi-max-frequency = <50000000>;
arch/arm/boot/dts/spear1340-evb.dts:					spi-max-frequency = <12000000>;
arch/arm/boot/dts/spear1340-evb.dts:					spi-cpol;
arch/arm/boot/dts/spear1340-evb.dts:					spi-cpha;
arch/arm/boot/dts/spear1340-evb.dts:					spi-max-frequency = <1000000>;
arch/arm/boot/dts/spear1340-evb.dts:					spi-cpha;
arch/arm/boot/dts/spear1340-evb.dts:					spi-max-frequency = <25000000>;
arch/arm/boot/dts/spear1340-evb.dts:					spi-cpha;
arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts:		spi-max-frequency = <40000000>;
arch/arm/boot/dts/atlas7-evb.dts:					spi-max-frequency = <37500000>;
arch/arm/boot/dts/atlas7-evb.dts:					spi-cpha;
arch/arm/boot/dts/atlas7-evb.dts:					spi-cpol;
arch/arm/boot/dts/imx6ul-tx6ul.dtsi:	spi_gpio: spi-gpio {
arch/arm/boot/dts/imx6ul-tx6ul.dtsi:		compatible = "spi-gpio";
arch/arm/boot/dts/imx6ul-tx6ul.dtsi:			spi-max-frequency = <660000>;
arch/arm/boot/dts/imx6ul-tx6ul.dtsi:			spi-max-frequency = <660000>;
arch/arm/boot/dts/imx6ul-tx6ul.dtsi:		spi-max-frequency = <60000000>;
arch/arm/boot/dts/imx6ul-tx6ul.dtsi:		spi-max-frequency = <60000000>;
arch/arm/boot/dts/imx6ul-tx6ul.dtsi:	pinctrl_spi_gpio: spi-gpiogrp {
arch/arm/boot/dts/suniv-f1c100s-licheepi-nano.dts:	// spi-max-frequency = <60000000>;
arch/arm/boot/dts/suniv-f1c100s-licheepi-nano.dts:		compatible = "winbond,w25q128", "jedec,spi-nor";
arch/arm/boot/dts/suniv-f1c100s-licheepi-nano.dts:		spi-max-frequency = <50000000>;
arch/arm/boot/dts/imx6qdl-nitrogen6x.dtsi:		compatible = "sst,sst25vf016b", "jedec,spi-nor";
arch/arm/boot/dts/imx6qdl-nitrogen6x.dtsi:		spi-max-frequency = <20000000>;
arch/arm/boot/dts/omap3-overo-common-lcd43.dtsi:		spi-max-frequency = <1500000>;
arch/arm/boot/dts/socfpga_arria10.dtsi:			compatible = "cdns,qspi-nor";
arch/arm/boot/dts/at91sam9m10g45ek.dts:					spi-max-frequency = <13000000>;
arch/arm/boot/dts/r8a7791-porter.dts:		compatible = "spansion,s25fl512s", "jedec,spi-nor";
arch/arm/boot/dts/r8a7791-porter.dts:		spi-max-frequency = <30000000>;
arch/arm/boot/dts/r8a7791-porter.dts:		spi-tx-bus-width = <4>;
arch/arm/boot/dts/r8a7791-porter.dts:		spi-rx-bus-width = <4>;
arch/arm/boot/dts/r8a7794-alt.dts:		compatible = "spansion,s25fl512s", "jedec,spi-nor";
arch/arm/boot/dts/r8a7794-alt.dts:		spi-max-frequency = <30000000>;
arch/arm/boot/dts/r8a7794-alt.dts:		spi-tx-bus-width = <4>;
arch/arm/boot/dts/r8a7794-alt.dts:		spi-rx-bus-width = <4>;
arch/arm/boot/dts/r8a7794-alt.dts:		spi-cpol;
arch/arm/boot/dts/r8a7794-alt.dts:		spi-cpha;
arch/arm/boot/dts/r8a7790-lager.dts:		compatible = "spansion,s25fl512s", "jedec,spi-nor";
arch/arm/boot/dts/r8a7790-lager.dts:		spi-max-frequency = <30000000>;
arch/arm/boot/dts/r8a7790-lager.dts:		spi-tx-bus-width = <4>;
arch/arm/boot/dts/r8a7790-lager.dts:		spi-rx-bus-width = <4>;
arch/arm/boot/dts/r8a7790-lager.dts:		spi-cpha;
arch/arm/boot/dts/r8a7790-lager.dts:		spi-cpol;
arch/arm/boot/dts/r8a7790-lager.dts:		spi-max-frequency = <6000000>;
arch/arm/boot/dts/r8a7790-lager.dts:		spi-cpol;
arch/arm/boot/dts/r8a7790-lager.dts:		spi-cpha;
arch/arm/boot/dts/dove.dtsi:			spi0: spi-ctrl@10600 {
arch/arm/boot/dts/dove.dtsi:			spi1: spi-ctrl@14600 {
arch/arm/boot/dts/omap3-devkit8000-lcd-common.dtsi:		spi-max-frequency = <1500000>;
arch/arm/boot/dts/kirkwood-ns2-common.dtsi:				compatible = "mxicy,mx25l4005a", "jedec,spi-nor";
arch/arm/boot/dts/kirkwood-ns2-common.dtsi:				spi-max-frequency = <20000000>;
arch/arm/boot/dts/imx6ul-opos6uldev.dts:		spi-max-frequency = <5000000>;
arch/arm/boot/dts/imx6ul-opos6uldev.dts:		spi-max-frequency = <5000000>;
arch/arm/boot/dts/omap3-n900.dts:		spi-max-frequency = <6000000>;
arch/arm/boot/dts/omap3-n900.dts:		spi-max-frequency = <6000000>;
arch/arm/boot/dts/omap3-n900.dts:		spi-max-frequency = <48000000>;
arch/arm/boot/dts/omap3-n900.dts:		spi-cpol;
arch/arm/boot/dts/omap3-n900.dts:		spi-cpha;
arch/arm/boot/dts/ls1021a-qds.dts:		spi-max-frequency = <16000000>;
arch/arm/boot/dts/ls1021a-qds.dts:		spi-cpol;
arch/arm/boot/dts/ls1021a-qds.dts:		spi-cpha;
arch/arm/boot/dts/imx28-evk.dts:					compatible = "sst,sst25vf016b", "jedec,spi-nor";
arch/arm/boot/dts/imx28-evk.dts:					spi-max-frequency = <40000000>;
arch/arm/boot/dts/at91-sam9_l9260.dts:					spi-max-frequency = <15000000>;
arch/arm/boot/dts/imx6q-mccmon6.dts:		compatible = "jedec,spi-nor";
arch/arm/boot/dts/imx6q-mccmon6.dts:		spi-max-frequency = <40000000>;
arch/arm/boot/dts/dm816x.dtsi:			ti,spi-num-cs = <4>;
arch/arm/boot/dts/armada-385-db-ap.dts:	spi-flash@0 {
arch/arm/boot/dts/armada-385-db-ap.dts:		compatible = "st,m25p128", "jedec,spi-nor";
arch/arm/boot/dts/armada-385-db-ap.dts:		spi-max-frequency = <54000000>;
arch/arm/boot/dts/suniv-f1c100s-licheepi-nano.dts.bk:		compatible = "winbond,w25q128", "jedec,spi-nor";
arch/arm/boot/dts/suniv-f1c100s-licheepi-nano.dts.bk:		spi-max-frequency = <40000000>;
arch/arm/boot/dts/keystone-k2l-evm.dts:		spi-max-frequency = <54000000>;
arch/arm/boot/dts/armada-370-synology-ds213j.dts:	spi-flash@0 {
arch/arm/boot/dts/armada-370-synology-ds213j.dts:		compatible = "micron,n25q064", "jedec,spi-nor";
arch/arm/boot/dts/armada-370-synology-ds213j.dts:		spi-max-frequency = <20000000>;
arch/arm/boot/dts/imx6sx-sdb.dts:		compatible = "micron,n25q256a", "jedec,spi-nor";
arch/arm/boot/dts/imx6sx-sdb.dts:		spi-max-frequency = <29000000>;
arch/arm/boot/dts/imx6sx-sdb.dts:		compatible = "micron,n25q256a", "jedec,spi-nor";
arch/arm/boot/dts/imx6sx-sdb.dts:		spi-max-frequency = <29000000>;
arch/arm/boot/dts/kirkwood-lsxl.dtsi:				compatible = "m25p40", "jedec,spi-nor";
arch/arm/boot/dts/kirkwood-lsxl.dtsi:				spi-max-frequency = <25000000>;
arch/arm/boot/dts/tegra114-dalmore.dts:		spi-max-frequency = <25000000>;
arch/arm/boot/dts/tegra114-dalmore.dts:		spi-flash@0 {
arch/arm/boot/dts/tegra114-dalmore.dts:			spi-max-frequency = <20000000>;
arch/arm/boot/dts/tegra20-trimslice.dts:		spi-max-frequency = <48000000>;
arch/arm/boot/dts/tegra20-trimslice.dts:		spi-flash@0 {
arch/arm/boot/dts/tegra20-trimslice.dts:			spi-max-frequency = <48000000>;
arch/arm/boot/dts/imx6q-ba16.dtsi:		compatible = "jedec,spi-nor";
arch/arm/boot/dts/imx6q-ba16.dtsi:		spi-max-frequency = <20000000>;
arch/arm/boot/dts/tegra30-apalis-eval.dts:		spi-max-frequency = <25000000>;
arch/arm/boot/dts/tegra30-apalis-eval.dts:			spi-max-frequency = <25000000>;
arch/arm/boot/dts/tegra30-apalis-eval.dts:		spi-max-frequency = <25000000>;
arch/arm/boot/dts/tegra30-apalis-eval.dts:			spi-max-frequency = <25000000>;
arch/arm/boot/dts/kirkwood-t5325.dts:				compatible = "st,m25p80", "jedec,spi-nor";
arch/arm/boot/dts/kirkwood-t5325.dts:				spi-max-frequency = <86000000>;
arch/arm/boot/dts/armada-388-rd.dts:	spi-flash@0 {
arch/arm/boot/dts/armada-388-rd.dts:		compatible = "st,m25p128", "jedec,spi-nor";
arch/arm/boot/dts/armada-388-rd.dts:		spi-max-frequency = <108000000>;
arch/arm/boot/dts/at91sam9261ek.dts:					spi-max-frequency = <15000000>;
arch/arm/boot/dts/at91sam9261ek.dts:					spi-max-frequency = <3000000>;
arch/arm/boot/dts/tegra30-apalis.dtsi:		spi-max-frequency = <10000000>;
arch/arm/boot/dts/tegra30-apalis.dtsi:			spi-max-frequency = <10000000>;
arch/arm/boot/dts/tegra30-apalis.dtsi:		spi-max-frequency = <10000000>;
arch/arm/boot/dts/tegra30-apalis.dtsi:			spi-max-frequency = <10000000>;
arch/arm/boot/dts/logicpd-torpedo-baseboard.dtsi:		spi-max-frequency = <5000000>;
arch/arm/boot/dts/logicpd-torpedo-baseboard.dtsi:		spi-cpha;
arch/arm/boot/dts/logicpd-torpedo-baseboard.dtsi:		spi-cpol;
arch/arm/boot/dts/r8a7779.dtsi:		compatible = "renesas,hspi-r8a7779", "renesas,hspi";
arch/arm/boot/dts/r8a7779.dtsi:		compatible = "renesas,hspi-r8a7779", "renesas,hspi";
arch/arm/boot/dts/r8a7779.dtsi:		compatible = "renesas,hspi-r8a7779", "renesas,hspi";
arch/arm/boot/dts/qcom-msm8960-cdp.dts:					spi-max-frequency = <5400000>;
arch/arm/boot/dts/bcm958625k.dts:	bspi-sel = <0>;
arch/arm/boot/dts/bcm958625k.dts:		spi-max-frequency = <12500000>;
arch/arm/boot/dts/bcm958625k.dts:		spi-cpol;
arch/arm/boot/dts/bcm958625k.dts:		spi-cpha;
arch/arm/boot/dts/r8a7794.dtsi:		compatible = "renesas,qspi-r8a7794", "renesas,qspi";
arch/arm/boot/dts/imx6q-display5.dtsi:		compatible = "jedec,spi-nor";
arch/arm/boot/dts/imx6q-display5.dtsi:		spi-max-frequency = <40000000>;
arch/arm/boot/dts/.suniv-f1c100s-licheepi-nano.dtb.dts.tmp:  compatible = "winbond,w25q128", "jedec,spi-nor";
arch/arm/boot/dts/.suniv-f1c100s-licheepi-nano.dtb.dts.tmp:  spi-max-frequency = <50000000>;
arch/arm/boot/dts/bcm947189acdbmr.dts:		compatible = "spi-gpio";
arch/arm/boot/dts/armada-375-db.dts:	spi-flash@0 {
arch/arm/boot/dts/armada-375-db.dts:		compatible = "n25q128a13", "jedec,spi-nor";
arch/arm/boot/dts/armada-375-db.dts:		spi-max-frequency = <108000000>;
arch/arm/boot/dts/meson8-minix-neo-x8.dts:	spi-flash@0 {
arch/arm/boot/dts/meson8-minix-neo-x8.dts:		spi-max-frequency = <30000000>;
arch/arm/boot/dts/usb_a9263.dts:					spi-max-frequency = <15000000>;
arch/arm/boot/dts/exynos4210-universal_c210.dts:	spi-lcd {
arch/arm/boot/dts/exynos4210-universal_c210.dts:		compatible = "spi-gpio";
arch/arm/boot/dts/exynos4210-universal_c210.dts:			spi-max-frequency = <1200000>;
arch/arm/boot/dts/exynos4210-universal_c210.dts:			spi-cpol;
arch/arm/boot/dts/exynos4210-universal_c210.dts:			spi-cpha;
arch/arm/boot/dts/kirkwood-linkstation.dtsi:				compatible = "st,m25p40", "jedec,spi-nor";
arch/arm/boot/dts/kirkwood-linkstation.dtsi:				spi-max-frequency = <25000000>;
arch/arm/boot/dts/imx6qdl-sabreauto.dtsi:		compatible = "st,m25p32", "jedec,spi-nor";
arch/arm/boot/dts/imx6qdl-sabreauto.dtsi:		spi-max-frequency = <20000000>;
arch/arm/boot/dts/r8a7743.dtsi:			compatible = "renesas,qspi-r8a7743", "renesas,qspi";
arch/arm/boot/dts/at91rm9200ek.dts:					spi-max-frequency = <15000000>;
arch/arm/boot/dts/omap3-overo-common-lcd35.dtsi:		spi-max-frequency = <500000>;
arch/arm/boot/dts/omap3-overo-common-lcd35.dtsi:		spi-cpol;
arch/arm/boot/dts/omap3-overo-common-lcd35.dtsi:		spi-cpha;
arch/arm/boot/dts/omap3-overo-common-lcd35.dtsi:		spi-max-frequency = <1500000>;
arch/arm/boot/dts/kirkwood-mv88f6281gtw-ge.dts:				compatible = "mxicy,mx25l12805d", "jedec,spi-nor";
arch/arm/boot/dts/kirkwood-mv88f6281gtw-ge.dts:				spi-max-frequency = <50000000>;
arch/arm/boot/dts/tegra30-cardhu.dtsi:		spi-max-frequency = <25000000>;
arch/arm/boot/dts/tegra30-cardhu.dtsi:		spi-flash@1 {
arch/arm/boot/dts/tegra30-cardhu.dtsi:			spi-max-frequency = <20000000>;
arch/arm/boot/dts/da850-evm.dts:				spi-max-frequency = <30000000>;
arch/arm/boot/dts/exynos5440.dtsi:		samsung,spi-src-clk = <0>;
arch/arm/boot/dts/dove-cm-a510.dtsi:		spi-max-frequency = <80000000>;
arch/arm/boot/dts/dove-cm-a510.dtsi:		spi-max-frequency = <2500000>;
arch/arm/boot/dts/dra7-evm-common.dtsi:	spi-max-frequency = <76800000>;
arch/arm/boot/dts/dra7-evm-common.dtsi:		spi-max-frequency = <76800000>;
arch/arm/boot/dts/dra7-evm-common.dtsi:		spi-tx-bus-width = <1>;
arch/arm/boot/dts/dra7-evm-common.dtsi:		spi-rx-bus-width = <4>;
arch/arm/boot/dts/imx7d-sdb.dts:		compatible = "spi-gpio";
arch/arm/boot/dts/imx7d-sdb.dts:			spi-max-frequency = <100000>;
arch/arm/boot/dts/imx7d-sdb.dts:		spi-max-frequency = <1000000>;
arch/arm/boot/dts/imx28-tx28.dts:	spi_gpio: spi-gpio {
arch/arm/boot/dts/imx28-tx28.dts:		compatible = "spi-gpio";
arch/arm/boot/dts/imx28-tx28.dts:			spi-max-frequency = <57600000>;
arch/arm/boot/dts/imx28-tx28.dts:			spi-max-frequency = <57600000>;
arch/arm/boot/dts/imx28-tx28.dts:			spi-max-frequency = <57600000>;
arch/arm/boot/dts/imx28-tx28.dts:	tx28_spi_gpio_pins: spi-gpiogrp {
arch/arm/boot/dts/imx28-tx28.dts:		spi-max-frequency = <57600000>;
arch/arm/boot/dts/imx28-tx28.dts:		spi-max-frequency = <57600000>;
arch/arm/boot/dts/imx28-tx28.dts:		spi-max-frequency = <57600000>;
arch/arm/boot/dts/imx6qdl-phytec-pfla02.dtsi:		compatible = "m25p80", "jedec,spi-nor";
arch/arm/boot/dts/imx6qdl-phytec-pfla02.dtsi:		spi-max-frequency = <20000000>;
arch/arm/boot/dts/exynos5800-peach-pi.dts:	ec_spi_cs: ec-spi-cs {
arch/arm/boot/dts/exynos5800-peach-pi.dts:	samsung,spi-src-clk = <0>;
arch/arm/boot/dts/exynos5800-peach-pi.dts:		spi-max-frequency = <3125000>;
arch/arm/boot/dts/exynos5800-peach-pi.dts:			samsung,spi-feedback-delay = <1>;
arch/arm/boot/dts/am57xx-cl-som-am57x.dts:	spi-max-frequency = <48000000>;
arch/arm/boot/dts/am57xx-cl-som-am57x.dts:		compatible = "spansion,m25p80", "jedec,spi-nor";
arch/arm/boot/dts/am57xx-cl-som-am57x.dts:		spi-max-frequency = <48000000>;
arch/arm/boot/dts/am57xx-cl-som-am57x.dts:		spi-max-frequency = <1500000>;
arch/arm/boot/dts/imx6q-dmo-edmqmx6.dts:		compatible = "m25p80", "jedec,spi-nor";
arch/arm/boot/dts/imx6q-dmo-edmqmx6.dts:		spi-max-frequency = <40000000>;
arch/arm/boot/dts/am335x-cm-t335.dts:		spi-max-frequency = <48000000>;
arch/arm/boot/dts/socfpga.dtsi:			compatible = "cdns,qspi-nor";
arch/arm/boot/dts/imx28-cfa10056.dts:		compatible = "spi-gpio";
arch/arm/boot/dts/imx28-cfa10056.dts:			spi-max-frequency = <100000>;
arch/arm/boot/dts/imx28-cfa10056.dts:			spi-cpol;
arch/arm/boot/dts/imx28-cfa10056.dts:			spi-cpha;
arch/arm/boot/dts/imx6q-gw5400-a.dts:		compatible = "sst,w25q256", "jedec,spi-nor";
arch/arm/boot/dts/imx6q-gw5400-a.dts:		spi-max-frequency = <30000000>;
arch/arm/boot/dts/da850.dtsi:			ti,davinci-spi-intr-line = <1>;
arch/arm/boot/dts/da850.dtsi:			ti,davinci-spi-intr-line = <1>;
arch/arm/boot/dts/bcm958622hr.dts:	bspi-sel = <0>;
arch/arm/boot/dts/bcm958622hr.dts:		spi-max-frequency = <12500000>;
arch/arm/boot/dts/bcm958622hr.dts:		spi-cpol;
arch/arm/boot/dts/bcm958622hr.dts:		spi-cpha;
arch/arm/boot/dts/bcm53340-ubnt-unifi-switch8.dts:	bspi-sel = <0>;
arch/arm/boot/dts/bcm53340-ubnt-unifi-switch8.dts:		spi-max-frequency = <12500000>;
arch/arm/boot/dts/bcm53340-ubnt-unifi-switch8.dts:		spi-cpol;
arch/arm/boot/dts/bcm53340-ubnt-unifi-switch8.dts:		spi-cpha;
arch/arm/boot/dts/at91-sama5d4ek.dts:					spi-max-frequency = <50000000>;
arch/arm/boot/dts/imx6qdl-sabresd.dtsi:		compatible = "st,m25p32", "jedec,spi-nor";
arch/arm/boot/dts/imx6qdl-sabresd.dtsi:		spi-max-frequency = <20000000>;
arch/arm/boot/dts/armada-xp-axpwifiap.dts:	spi-flash@0 {
arch/arm/boot/dts/armada-xp-axpwifiap.dts:		compatible = "n25q128a13", "jedec,spi-nor";
arch/arm/boot/dts/armada-xp-axpwifiap.dts:		spi-max-frequency = <108000000>;
arch/arm/boot/dts/at91sam9n12ek.dts:					spi-max-frequency = <50000000>;
arch/arm/boot/dts/socfpga_arria10_socdk_qspi.dts:		spi-max-frequency = <100000000>;
arch/arm/boot/dts/socfpga_arria10_socdk_qspi.dts:		partition@qspi-boot {
arch/arm/boot/dts/socfpga_arria10_socdk_qspi.dts:		partition@qspi-rootfs {
arch/arm/boot/dts/socfpga_cyclone5_vining_fpga.dts:		spi-max-frequency = <100000000>;
arch/arm/boot/dts/socfpga_cyclone5_vining_fpga.dts:		spi-max-frequency = <100000000>;
arch/arm/boot/dts/exynos5250-snow-common.dtsi:	samsung,spi-src-clk = <0>;
arch/arm/boot/dts/am335x-phycore-som.dtsi:		compatible = "jedec,spi-nor";
arch/arm/boot/dts/am335x-phycore-som.dtsi:		spi-max-frequency = <48000000>;
arch/arm/boot/dts/vf610-zii-dev-rev-b.dts:		compatible = "spi-gpio";
arch/arm/boot/dts/vf610-zii-dev-rev-b.dts:			compatible = "m25p128", "jedec,spi-nor";
arch/arm/boot/dts/vf610-zii-dev-rev-b.dts:			spi-max-frequency = <1000000>;
arch/arm/boot/dts/vf610-zii-dev-rev-b.dts:			spi-max-frequency = <500000>;
arch/arm/boot/dts/vf610-zii-dev-rev-b.dts:			spi-cs-high;
arch/arm/boot/dts/at91-sama5d4_ma5d4.dtsi:					spi-max-frequency = <50000000>;
arch/arm/boot/dts/at91-sama5d4_ma5d4.dtsi:					spi-max-frequency = <10000000>;
arch/arm/boot/dts/at91-sama5d4_ma5d4.dtsi:					spi-max-frequency = <10000000>;
arch/arm/boot/dts/exynos3250.dtsi:			samsung,spi-src-clk = <0>;
arch/arm/boot/dts/exynos3250.dtsi:			samsung,spi-src-clk = <0>;
Binary file arch/arm/boot/Image matches
arch/arm/mach-pxa/z2.c:	spi->bits_per_word = 16;
arch/arm/mach-pxa/z2.c:	spi->mode = SPI_MODE_2,
arch/arm/mach-pxa/cm-x270.c:	spi->bits_per_word = 16;
arch/arm/mach-pxa/em-x270.c:	spi->bits_per_word = 16;
arch/powerpc/platforms/83xx/mpc832x_rdb.c:	pr_debug("%s %d %d\n", __func__, spi->chip_select, on);
arch/powerpc/platforms/83xx/mpc832x_rdb.c:	 * mmc-spi-slot node.
arch/powerpc/platforms/83xx/mpc832x_rdb.c:	if (of_find_compatible_node(NULL, NULL, "mmc-spi-slot"))
arch/powerpc/boot/dts/mpc8610_hpcd.dts:					     "mmc-spi-slot";
arch/powerpc/boot/dts/mpc8610_hpcd.dts:				spi-max-frequency = <50000000>;
arch/powerpc/boot/dts/ac14xx.dts:				spi-max-frequency = <20000000>;
arch/powerpc/boot/dts/ac14xx.dts:					label = "spi-flash0";
arch/powerpc/boot/dts/ac14xx.dts:			fsl,mode = "spi-master";
arch/powerpc/boot/dts/ac14xx.dts:				spi-max-frequency = <100000>;
arch/powerpc/boot/dts/ac14xx.dts:				spi-cpol;
arch/powerpc/boot/dts/ac14xx.dts:				spi-cpha;
arch/powerpc/boot/dts/digsy_mtc.dts:				spi-max-frequency = <32000>;
arch/powerpc/boot/dts/mpc832x_rdb.dts:					     "mmc-spi-slot";
arch/powerpc/boot/dts/mpc832x_rdb.dts:				spi-max-frequency = <50000000>;
arch/powerpc/boot/dts/yosemite.dts:				compatible = "amcc,spi-440ep";
arch/powerpc/boot/dts/fsl/p4080ds.dts:				compatible = "spansion,s25sl12801", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/p4080ds.dts:				spi-max-frequency = <40000000>; /* input clock */
arch/powerpc/boot/dts/fsl/bsc9131rdb.dtsi:			compatible = "spansion,s25sl12801", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/bsc9131rdb.dtsi:			spi-max-frequency = <50000000>;
arch/powerpc/boot/dts/fsl/p1020rdb-pc.dtsi:			compatible = "spansion,s25sl12801", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/p1020rdb-pc.dtsi:			spi-max-frequency = <40000000>; /* input clock */
arch/powerpc/boot/dts/fsl/t104xqds.dtsi:				compatible = "micron,n25q128a11", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/t104xqds.dtsi:				spi-max-frequency = <10000000>; /* input clock */
arch/powerpc/boot/dts/fsl/t104xrdb.dtsi:				compatible = "micron,n25q512ax3", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/t104xrdb.dtsi:				spi-max-frequency = <10000000>; /* input clock */
arch/powerpc/boot/dts/fsl/t104xrdb.dtsi:				spi-max-frequency = <2000000>; /* input clock */
arch/powerpc/boot/dts/fsl/p1023si-post.dtsi:/include/ "pq3-espi-0.dtsi"
arch/powerpc/boot/dts/fsl/p1023si-post.dtsi:		fsl,espi-num-chipselects = <4>;
arch/powerpc/boot/dts/fsl/t208xqds.dtsi:				compatible = "micron,n25q128a11", "jedec,spi-nor"; /* 16MB */
arch/powerpc/boot/dts/fsl/t208xqds.dtsi:				spi-max-frequency = <40000000>; /* input clock */
arch/powerpc/boot/dts/fsl/t208xqds.dtsi:				compatible = "sst,sst25wf040", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/t208xqds.dtsi:				spi-max-frequency = <35000000>;
arch/powerpc/boot/dts/fsl/t208xqds.dtsi:				compatible = "eon,en25s64", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/t208xqds.dtsi:				spi-max-frequency = <35000000>;
arch/powerpc/boot/dts/fsl/p1020rdb-pd.dts:				compatible = "spansion,s25sl12801", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/p1020rdb-pd.dts:				spi-max-frequency = <40000000>;
arch/powerpc/boot/dts/fsl/p1020rdb-pd.dts:				spi-max-frequency = <8000000>;
arch/powerpc/boot/dts/fsl/p1020rdb-pd.dts:				spi-max-frequency = <8000000>;
arch/powerpc/boot/dts/fsl/bsc9132si-post.dtsi:/include/ "pq3-espi-0.dtsi"
arch/powerpc/boot/dts/fsl/bsc9132si-post.dtsi:		fsl,espi-num-chipselects = <1>;
arch/powerpc/boot/dts/fsl/p3041ds.dts:				compatible = "spansion,s25sl12801", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/p3041ds.dts:				spi-max-frequency = <35000000>; /* input clock */
arch/powerpc/boot/dts/fsl/t104xd4rdb.dtsi:				compatible = "micron,n25q512ax3", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/t104xd4rdb.dtsi:				spi-max-frequency = <10000000>;
arch/powerpc/boot/dts/fsl/t104xd4rdb.dtsi:				spi-max-frequency = <2000000>; /* input clock */
arch/powerpc/boot/dts/fsl/t104xd4rdb.dtsi:				spi-max-frequency = <2000000>; /* input clock */
arch/powerpc/boot/dts/fsl/t208xrdb.dtsi:				compatible = "micron,n25q512ax3", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/t208xrdb.dtsi:				spi-max-frequency = <10000000>; /* input clock */
arch/powerpc/boot/dts/fsl/p3041si-post.dtsi:/include/ "qoriq-espi-0.dtsi"
arch/powerpc/boot/dts/fsl/p3041si-post.dtsi:		fsl,espi-num-chipselects = <4>;
arch/powerpc/boot/dts/fsl/p2020rdb-pc.dtsi:			compatible = "spansion,m25p80", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/p2020rdb-pc.dtsi:			spi-max-frequency = <40000000>;
arch/powerpc/boot/dts/fsl/c293pcie.dts:			compatible = "spansion,s25sl12801", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/c293pcie.dts:			spi-max-frequency = <50000000>;
arch/powerpc/boot/dts/fsl/mpc8536si-post.dtsi:/include/ "pq3-espi-0.dtsi"
arch/powerpc/boot/dts/fsl/mpc8536si-post.dtsi:		fsl,espi-num-chipselects = <4>;
arch/powerpc/boot/dts/fsl/t1023si-post.dtsi:/include/ "qoriq-espi-0.dtsi"
arch/powerpc/boot/dts/fsl/t1023si-post.dtsi:		fsl,espi-num-chipselects = <4>;
arch/powerpc/boot/dts/fsl/p5020si-post.dtsi:/include/ "qoriq-espi-0.dtsi"
arch/powerpc/boot/dts/fsl/p5020si-post.dtsi:		fsl,espi-num-chipselects = <4>;
arch/powerpc/boot/dts/fsl/c293si-post.dtsi:/include/ "pq3-espi-0.dtsi"
arch/powerpc/boot/dts/fsl/c293si-post.dtsi:		fsl,espi-num-chipselects = <1>;
arch/powerpc/boot/dts/fsl/kmcoge4.dts:				compatible = "spansion,s25fl256s1", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/kmcoge4.dts:				spi-max-frequency = <20000000>; /* input clock */
arch/powerpc/boot/dts/fsl/kmcoge4.dts:				spi-max-frequency = <8000000>;
arch/powerpc/boot/dts/fsl/kmcoge4.dts:				compatible = "micron,m25p32", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/kmcoge4.dts:				spi-max-frequency = <15000000>;
arch/powerpc/boot/dts/fsl/b4si-post.dtsi:/include/ "qoriq-espi-0.dtsi"
arch/powerpc/boot/dts/fsl/b4si-post.dtsi:		fsl,espi-num-chipselects = <4>;
arch/powerpc/boot/dts/fsl/bsc9132qds.dtsi:			compatible = "spansion,s25sl12801", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/bsc9132qds.dtsi:			spi-max-frequency = <30000000>;
arch/powerpc/boot/dts/fsl/p2041rdb.dts:				compatible = "spansion,s25sl12801", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/p2041rdb.dts:				spi-max-frequency = <40000000>; /* input clock */
arch/powerpc/boot/dts/fsl/t4240si-post.dtsi:/include/ "qoriq-espi-0.dtsi"
arch/powerpc/boot/dts/fsl/t4240si-post.dtsi:		fsl,espi-num-chipselects = <4>;
arch/powerpc/boot/dts/fsl/p2020rdb.dts:				compatible = "spansion,s25sl12801", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/p2020rdb.dts:				spi-max-frequency = <40000000>;
arch/powerpc/boot/dts/fsl/p1020si-post.dtsi:/include/ "pq3-espi-0.dtsi"
arch/powerpc/boot/dts/fsl/p1020si-post.dtsi:		fsl,espi-num-chipselects = <4>;
arch/powerpc/boot/dts/fsl/t1024qds.dts:				compatible = "micron,n25q128a11", "jedec,spi-nor";  /* 16MB */
arch/powerpc/boot/dts/fsl/t1024qds.dts:				spi-max-frequency = <10000000>;
arch/powerpc/boot/dts/fsl/t1024qds.dts:				compatible = "sst,sst25wf040", "jedec,spi-nor";  /* 512KB */
arch/powerpc/boot/dts/fsl/t1024qds.dts:				spi-max-frequency = <10000000>;
arch/powerpc/boot/dts/fsl/t1024qds.dts:				compatible = "eon,en25s64", "jedec,spi-nor";   /* 8MB */
arch/powerpc/boot/dts/fsl/t1024qds.dts:				spi-max-frequency = <10000000>;
arch/powerpc/boot/dts/fsl/t1024qds.dts:				spi-max-frequency = <2000000>;
arch/powerpc/boot/dts/fsl/t1024qds.dts:				spi-max-frequency = <2000000>;
arch/powerpc/boot/dts/fsl/t4240qds.dts:				compatible = "sst,sst25wf040", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/t4240qds.dts:				spi-max-frequency = <40000000>; /* input clock */
arch/powerpc/boot/dts/fsl/p1021rdb-pc.dtsi:			compatible = "spansion,s25sl12801", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/p1021rdb-pc.dtsi:			spi-max-frequency = <40000000>; /* input clock */
arch/powerpc/boot/dts/fsl/p1021mds.dts:				compatible = "spansion,s25sl12801", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/p1021mds.dts:				spi-max-frequency = <40000000>; /* input clock */
arch/powerpc/boot/dts/fsl/t2081si-post.dtsi:/include/ "qoriq-espi-0.dtsi"
arch/powerpc/boot/dts/fsl/t2081si-post.dtsi:		fsl,espi-num-chipselects = <4>;
arch/powerpc/boot/dts/fsl/p1024rdb.dtsi:			compatible = "spansion,m25p80", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/p1024rdb.dtsi:			spi-max-frequency = <40000000>;
arch/powerpc/boot/dts/fsl/p5020ds.dts:				compatible = "spansion,s25sl12801", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/p5020ds.dts:				spi-max-frequency = <40000000>; /* input clock */
arch/powerpc/boot/dts/fsl/p1022si-post.dtsi:/include/ "pq3-espi-0.dtsi"
arch/powerpc/boot/dts/fsl/p1022si-post.dtsi:		fsl,espi-num-chipselects = <4>;
arch/powerpc/boot/dts/fsl/p1010si-post.dtsi:/include/ "pq3-espi-0.dtsi"
arch/powerpc/boot/dts/fsl/p1010si-post.dtsi:		fsl,espi-num-chipselects = <1>;
arch/powerpc/boot/dts/fsl/t4240rdb.dts:				compatible = "sst,sst25wf040", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/t4240rdb.dts:				spi-max-frequency = <40000000>; /* input clock */
arch/powerpc/boot/dts/fsl/p5040si-post.dtsi:/include/ "qoriq-espi-0.dtsi"
arch/powerpc/boot/dts/fsl/p5040si-post.dtsi:		fsl,espi-num-chipselects = <4>;
arch/powerpc/boot/dts/fsl/p1010rdb.dtsi:			compatible = "spansion,s25sl12801", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/p1010rdb.dtsi:			spi-max-frequency = <40000000>;
arch/powerpc/boot/dts/fsl/p1022rdk.dts:				compatible = "spansion,m25p80", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/p1022rdk.dts:				spi-max-frequency = <1000000>;
arch/powerpc/boot/dts/fsl/p1022rdk.dts:					label = "full-spi-flash";
arch/powerpc/boot/dts/fsl/mvme2500.dts:			fsl,espi-num-chipselects = <2>;
arch/powerpc/boot/dts/fsl/mvme2500.dts:				compatible = "atmel,at25df641", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/mvme2500.dts:				spi-max-frequency = <10000000>;
arch/powerpc/boot/dts/fsl/mvme2500.dts:				compatible = "atmel,at25df641", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/mvme2500.dts:				spi-max-frequency = <10000000>;
arch/powerpc/boot/dts/fsl/t1024rdb.dts:				compatible = "micron,n25q512ax3", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/t1024rdb.dts:				spi-max-frequency = <10000000>; /* input clk */
arch/powerpc/boot/dts/fsl/t1024rdb.dts:				spi-max-frequency = <2000000>;
arch/powerpc/boot/dts/fsl/t1024rdb.dts:				spi-max-frequency = <2000000>;
arch/powerpc/boot/dts/fsl/p4080si-post.dtsi:/include/ "qoriq-espi-0.dtsi"
arch/powerpc/boot/dts/fsl/p4080si-post.dtsi:		fsl,espi-num-chipselects = <4>;
arch/powerpc/boot/dts/fsl/b4qds.dtsi:				compatible = "sst,sst25wf040", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/b4qds.dtsi:				spi-max-frequency = <40000000>; /* input clock */
arch/powerpc/boot/dts/fsl/p1025rdb.dtsi:			compatible = "spansion,s25sl12801", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/p1025rdb.dtsi:			spi-max-frequency = <40000000>; /* input clock */
arch/powerpc/boot/dts/fsl/p1022ds.dtsi:			compatible = "spansion,s25sl12801", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/p1022ds.dtsi:			spi-max-frequency = <40000000>; /* input clock */
arch/powerpc/boot/dts/fsl/kmcent2.dts:				spi-max-frequency = <1000000>;
arch/powerpc/boot/dts/fsl/p1020rdb.dtsi:			compatible = "spansion,s25sl12801", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/p1020rdb.dtsi:			spi-max-frequency = <40000000>; /* input clock */
arch/powerpc/boot/dts/fsl/p2020si-post.dtsi:/include/ "pq3-espi-0.dtsi"
arch/powerpc/boot/dts/fsl/p2020si-post.dtsi:		fsl,espi-num-chipselects = <4>;
arch/powerpc/boot/dts/fsl/p5040ds.dts:				compatible = "spansion,s25sl12801", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/p5040ds.dts:				spi-max-frequency = <40000000>; /* input clock */
arch/powerpc/boot/dts/fsl/mpc8536ds.dtsi:			compatible = "spansion,s25sl12801", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/mpc8536ds.dtsi:			spi-max-frequency = <40000000>;
arch/powerpc/boot/dts/fsl/mpc8536ds.dtsi:			compatible = "spansion,s25sl12801", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/mpc8536ds.dtsi:			spi-max-frequency = <40000000>;
arch/powerpc/boot/dts/fsl/mpc8536ds.dtsi:			compatible = "spansion,s25sl12801", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/mpc8536ds.dtsi:			spi-max-frequency = <40000000>;
arch/powerpc/boot/dts/fsl/mpc8536ds.dtsi:			compatible = "spansion,s25sl12801", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/mpc8536ds.dtsi:			spi-max-frequency = <40000000>;
arch/powerpc/boot/dts/fsl/t1023rdb.dts:				compatible = "spansion,s25fl512s", "jedec,spi-nor";
arch/powerpc/boot/dts/fsl/t1023rdb.dts:				spi-max-frequency = <10000000>; /* input clk */
arch/powerpc/boot/dts/fsl/p2041si-post.dtsi:/include/ "qoriq-espi-0.dtsi"
arch/powerpc/boot/dts/fsl/p2041si-post.dtsi:		fsl,espi-num-chipselects = <4>;
arch/powerpc/boot/dts/fsl/t1040si-post.dtsi:/include/ "qoriq-espi-0.dtsi"
arch/powerpc/boot/dts/fsl/t1040si-post.dtsi:		fsl,espi-num-chipselects = <4>;
arch/powerpc/boot/dts/fsl/p1021si-post.dtsi:/include/ "pq3-espi-0.dtsi"
arch/powerpc/boot/dts/fsl/p1021si-post.dtsi:		fsl,espi-num-chipselects = <4>;
arch/powerpc/boot/dts/fsl/mpc8569mds.dts:				spi-max-frequency = <25000000>;
arch/powerpc/boot/dts/fsl/bsc9131si-post.dtsi:/include/ "pq3-espi-0.dtsi"
arch/powerpc/boot/dts/fsl/bsc9131si-post.dtsi:		fsl,espi-num-chipselects = <1>;
arch/powerpc/boot/dts/o2d.dtsi:				spi-max-frequency = <250000>;
arch/powerpc/boot/dts/virtex440-ml510.dts:			compatible = "xlnx,xps-spi-2.00.b";
arch/powerpc/boot/dts/pdm360ng.dts:				spi-max-frequency = <3000000>;
arch/powerpc/boot/dts/acadia.dts:				compatible = "amcc,spi-405ez";
arch/powerpc/boot/dts/mgcoge.dts:					spi-max-frequency = <8000000>;
arch/m68k/coldfire/stmark2.c:#include <linux/spi/spi-fsl-dspi.h>
.idea/workspace.xml:      <change beforePath="$PROJECT_DIR$/drivers/mtd/spi-nor/spi-nor.c" beforeDir="false" afterPath="$PROJECT_DIR$/drivers/mtd/spi-nor/spi-nor.c" afterDir="false" />
.idea/workspace.xml:      <change beforePath="$PROJECT_DIR$/drivers/spi/spi-sun4i.c" beforeDir="false" afterPath="$PROJECT_DIR$/drivers/spi/spi-sun4i.c" afterDir="false" />
fs/ufs/util.c:	if (size & ~uspi->s_fmask)
fs/ufs/util.c:	count = size >> uspi->s_fshift;
fs/ufs/util.c:	if (size & ~uspi->s_fmask)
fs/ufs/util.c:	count = size >> uspi->s_fshift;
fs/ufs/util.c:	if (size > (ubh->count << uspi->s_fshift))
fs/ufs/util.c:		size = ubh->count << uspi->s_fshift;
fs/ufs/util.c:		len = min_t(unsigned int, size, uspi->s_fsize);
fs/ufs/util.c:		mem += uspi->s_fsize;
fs/ufs/util.c:	if (size > (ubh->count << uspi->s_fshift))
fs/ufs/util.c:		size = ubh->count << uspi->s_fshift;
fs/ufs/util.c:		len = min_t(unsigned int, size, uspi->s_fsize);
fs/ufs/util.c:		mem += uspi->s_fsize;
fs/ufs/util.h:	return &spi->s_ubh;
fs/ufs/util.h:	index = offset >> uspi->s_fshift;
fs/ufs/util.h:	offset &= ~uspi->s_fmask;
fs/ufs/util.h:	return uspi->s_ubh.bh[index]->b_data + offset;
fs/ufs/util.h:	((u8*)(ubh)->bh[(begin) >> uspi->s_fshift]->b_data + \
fs/ufs/util.h:	((begin) & ~uspi->s_fmask))
fs/ufs/util.h:	(((__fs16*)((ubh)->bh[(begin) >> (uspi->s_fshift-1)]->b_data)) + \
fs/ufs/util.h:	((begin) & ((uspi->fsize>>1) - 1)))
fs/ufs/util.h:	(((__fs32*)((ubh)->bh[(begin) >> (uspi->s_fshift-2)]->b_data)) + \
fs/ufs/util.h:	((begin) & ((uspi->s_fsize>>2) - 1)))
fs/ufs/util.h:	(((__fs64*)((ubh)->bh[(begin) >> (uspi->s_fshift-3)]->b_data)) + \
fs/ufs/util.h:	((begin) & ((uspi->s_fsize>>3) - 1)))
fs/ufs/util.h:	if (uspi->fs_magic == UFS2_MAGIC)
fs/ufs/util.h:	((*ubh_get_addr(ubh, (begin) + ((bit) >> 3)) >> ((bit) & 7)) & (0xff >> (UFS_MAXFRAG - uspi->s_fpb)))
fs/ufs/util.h:	return ufs_blkstofrags(uspi->cs_total.cs_nbfree) +
fs/ufs/util.h:		uspi->cs_total.cs_nffree;
fs/ufs/util.h:	(ucpi)->c_boff + (((cylno) * uspi->s_nrpos + (rpos)) << 1 ))))
fs/ufs/util.h:	base = offset >> uspi->s_bpfshift;
fs/ufs/util.h:	offset &= uspi->s_bpfmask;
fs/ufs/util.h:		count = min_t(unsigned int, size + offset, uspi->s_bpf);
fs/ufs/util.h:	return (base << uspi->s_bpfshift) + pos - begin;
fs/ufs/util.h:	base = start >> uspi->s_bpfshift;
fs/ufs/util.h:	start &= uspi->s_bpfmask;
fs/ufs/util.h:			    size + (uspi->s_bpf - start), uspi->s_bpf)
fs/ufs/util.h:			- (uspi->s_bpf - start);
fs/ufs/util.h:		start = uspi->s_bpf;
fs/ufs/util.h:	return (base << uspi->s_bpfshift) + pos - begin;
fs/ufs/util.h:	switch (uspi->s_fpb) {
fs/ufs/util.h:	switch (uspi->s_fpb) {
fs/ufs/util.h:	switch (uspi->s_fpb) {
fs/ufs/util.h:	for (pos = 0; pos < uspi->s_fpb; pos++) {
fs/ufs/util.h:	if (fragsize > 0 && fragsize < uspi->s_fpb)
fs/ufs/util.h:	return uspi->fs_magic == UFS2_MAGIC ?
fs/ufs/util.h:	return UFS_SB(sb)->s_uspi->fs_magic == UFS2_MAGIC ?
fs/ufs/util.h:	if (UFS_SB(sb)->s_uspi->fs_magic == UFS2_MAGIC)
fs/ufs/util.h:	if (uspi->fs_magic == UFS2_MAGIC)
fs/ufs/util.h:	if (uspi->fs_magic == UFS2_MAGIC)
fs/ufs/ufs_fs.h:#define UFS_NDIR_FRAGMENT (UFS_NDADDR << uspi->s_fpbshift)
fs/ufs/ufs_fs.h:#define UFS_IND_FRAGMENT (UFS_IND_BLOCK << uspi->s_fpbshift)
fs/ufs/ufs_fs.h:#define UFS_DIND_FRAGMENT (UFS_DIND_BLOCK << uspi->s_fpbshift)
fs/ufs/ufs_fs.h:#define UFS_TIND_FRAGMENT (UFS_TIND_BLOCK << uspi->s_fpbshift)
fs/ufs/ufs_fs.h:#define	ufs_cgbase(c)	(uspi->s_fpg * (c))
fs/ufs/ufs_fs.h:	(ufs_cgbase(c)  + uspi->s_cgoffset * ((c) & ~uspi->s_cgmask)))
fs/ufs/ufs_fs.h:#define	ufs_cgsblock(c)	(ufs_cgstart(c) + uspi->s_sblkno)	/* super blk */
fs/ufs/ufs_fs.h:#define	ufs_cgcmin(c)	(ufs_cgstart(c) + uspi->s_cblkno)	/* cg block */
fs/ufs/ufs_fs.h:#define	ufs_cgimin(c)	(ufs_cgstart(c) + uspi->s_iblkno)	/* inode blk */
fs/ufs/ufs_fs.h:#define	ufs_cgdmin(c)	(ufs_cgstart(c) + uspi->s_dblkno)	/* 1st data */
fs/ufs/ufs_fs.h:#define	ufs_inotocg(x)		((x) / uspi->s_ipg)
fs/ufs/ufs_fs.h:#define	ufs_inotocgoff(x)	((x) % uspi->s_ipg)
fs/ufs/ufs_fs.h:#define	ufs_inotofsba(x)	(((u64)ufs_cgimin(ufs_inotocg(x))) + ufs_inotocgoff(x) / uspi->s_inopf)
fs/ufs/ufs_fs.h:#define	ufs_inotofsbo(x)	((x) % uspi->s_inopf)
fs/ufs/ufs_fs.h:	((bno) * uspi->s_nspf / uspi->s_spc)
fs/ufs/ufs_fs.h:	 (((((bno) * uspi->s_nspf % uspi->s_spc) %	      \
fs/ufs/ufs_fs.h:	    uspi->s_nsect) *				      \
fs/ufs/ufs_fs.h:	   uspi->s_nrpos) / uspi->s_nsect)		      \
fs/ufs/ufs_fs.h:	((((bno) * uspi->s_nspf % uspi->s_spc / uspi->s_nsect \
fs/ufs/ufs_fs.h:	* uspi->s_trackskew + (bno) * uspi->s_nspf % uspi->s_spc \
fs/ufs/ufs_fs.h:	% uspi->s_nsect * uspi->s_interleave) % uspi->s_nsect \
fs/ufs/ufs_fs.h:	  * uspi->s_nrpos) / uspi->s_npsect))
fs/ufs/ufs_fs.h:#define ufs_blkoff(loc)		((loc) & uspi->s_qbmask)
fs/ufs/ufs_fs.h:#define ufs_fragoff(loc)	((loc) & uspi->s_qfmask)
fs/ufs/ufs_fs.h:#define ufs_lblktosize(blk)	((blk) << uspi->s_bshift)
fs/ufs/ufs_fs.h:#define ufs_lblkno(loc)		((loc) >> uspi->s_bshift)
fs/ufs/ufs_fs.h:#define ufs_numfrags(loc)	((loc) >> uspi->s_fshift)
fs/ufs/ufs_fs.h:#define ufs_blkroundup(size)	(((size) + uspi->s_qbmask) & uspi->s_bmask)
fs/ufs/ufs_fs.h:#define ufs_fragroundup(size)	(((size) + uspi->s_qfmask) & uspi->s_fmask)
fs/ufs/ufs_fs.h:#define ufs_fragstoblks(frags)	((frags) >> uspi->s_fpbshift)
fs/ufs/ufs_fs.h:#define ufs_blkstofrags(blks)	((blks) << uspi->s_fpbshift)
fs/ufs/ufs_fs.h:#define ufs_fragnum(fsb)	((fsb) & uspi->s_fpbmask)
fs/ufs/ufs_fs.h:#define ufs_blknum(fsb)		((fsb) & ~uspi->s_fpbmask)
fs/ufs/cylinder.c:	UCPI_UBH(ucpi)->count = uspi->s_cgsize >> sb->s_blocksize_bits;
fs/ufs/cylinder.c:	if (uspi->s_ncg > UFS_MAX_GROUP_LOADED && bitmap_nr >= sbi->s_cg_loaded) {
fs/ufs/cylinder.c:	if (cgno >= uspi->s_ncg) {
fs/ufs/cylinder.c:	if (uspi->s_ncg <= UFS_MAX_GROUP_LOADED) {
fs/ufs/ialloc.c:	if (!((ino > 1) && (ino < (uspi->s_ncg * uspi->s_ipg )))) {
fs/ufs/ialloc.c:		uspi->cs_total.cs_nifree++;
fs/ufs/ialloc.c:			uspi->cs_total.cs_ndir--;
fs/ufs/ialloc.c:	sector_t beg = uspi->s_sbbase +
fs/ufs/ialloc.c:		ufs_inotofsba(ucpi->c_cgx * uspi->s_ipg +
fs/ufs/ialloc.c:	sector_t end = beg + uspi->s_fpb;
fs/ufs/ialloc.c:	fs32_add(sb, &ucg->cg_u.cg_u2.cg_initediblk, uspi->s_inopb);
fs/ufs/ialloc.c:	for ( j = 1; j < uspi->s_ncg; j <<= 1 ) {
fs/ufs/ialloc.c:		if (i >= uspi->s_ncg)
fs/ufs/ialloc.c:			i -= uspi->s_ncg;
fs/ufs/ialloc.c:	for (j = 2; j < uspi->s_ncg; j++) {
fs/ufs/ialloc.c:		if (i >= uspi->s_ncg)
fs/ufs/ialloc.c:	bit = ubh_find_next_zero_bit (UCPI_UBH(ucpi), ucpi->c_iusedoff, uspi->s_ipg, start);
fs/ufs/ialloc.c:	if (!(bit < uspi->s_ipg)) {
fs/ufs/ialloc.c:	UFSD("start = %u, bit = %u, ipg = %u\n", start, bit, uspi->s_ipg);
fs/ufs/ialloc.c:	if (uspi->fs_magic == UFS2_MAGIC) {
fs/ufs/ialloc.c:		if (bit + uspi->s_inopb > initediblk &&
fs/ufs/ialloc.c:	uspi->cs_total.cs_nifree--;
fs/ufs/ialloc.c:		uspi->cs_total.cs_ndir++;
fs/ufs/ialloc.c:	inode->i_ino = cg * uspi->s_ipg + bit;
fs/ufs/ialloc.c:	if (uspi->fs_magic == UFS2_MAGIC) {
fs/ufs/ialloc.c:		bh = sb_bread(sb, uspi->s_sbbase + ufs_inotofsba(inode->i_ino));
fs/ufs/ufs.h:/* #define	ufs_dtog(d)	((d) / uspi->s_fpg) */
fs/ufs/ufs.h:	do_div(b, uspi->s_fpg);
fs/ufs/ufs.h:/* #define	ufs_dtogd(d)	((d) % uspi->s_fpg) */
fs/ufs/ufs.h:	return do_div(b, uspi->s_fpg);
fs/ufs/dir.c:	const unsigned chunk_mask = UFS_SB(sb)->s_uspi->s_dirblksize - 1;
fs/ufs/dir.c:		if (fs32_to_cpu(sb, p->d_ino) > (UFS_SB(sb)->s_uspi->s_ipg *
fs/ufs/dir.c:						  UFS_SB(sb)->s_uspi->s_ncg))
fs/ufs/dir.c:	const unsigned int chunk_size = UFS_SB(sb)->s_uspi->s_dirblksize;
fs/ufs/dir.c:	unsigned chunk_mask = ~(UFS_SB(sb)->s_uspi->s_dirblksize - 1);
fs/ufs/dir.c:	unsigned from = ((char*)dir - kaddr) & ~(UFS_SB(sb)->s_uspi->s_dirblksize - 1);
fs/ufs/dir.c:	const unsigned int chunk_size = UFS_SB(sb)->s_uspi->s_dirblksize;
fs/ufs/inode.c:	int ptrs = uspi->s_apb;
fs/ufs/inode.c:	int ptrs_bits = uspi->s_apbshift;
fs/ufs/inode.c:	UFSD("ptrs=uspi->s_apb = %d,double_blocks=%ld \n",ptrs,double_blocks);
fs/ufs/inode.c:	u64 mask = (u64) uspi->s_apbmask>>uspi->s_fpbshift;
fs/ufs/inode.c:	int shift = uspi->s_apbshift-uspi->s_fpbshift;
fs/ufs/inode.c:	UFSD(": uspi->s_fpbshift = %d ,uspi->s_apbmask = %x, mask=%llx\n",
fs/ufs/inode.c:		uspi->s_fpbshift, uspi->s_apbmask,
fs/ufs/inode.c:		bh = sb_bread(sb, uspi->s_sbbase +
fs/ufs/inode.c:		bh = sb_bread(sb, uspi->s_sbbase +
fs/ufs/inode.c:	res += uspi->s_sbbase;
fs/ufs/inode.c:	if (writes_to < (lastfrag | uspi->s_fpbmask))
fs/ufs/inode.c:		new_size = (writes_to & uspi->s_fpbmask) + 1;
fs/ufs/inode.c:		new_size = uspi->s_fpb;
fs/ufs/inode.c:				new_size - (lastfrag & uspi->s_fpbmask), err,
fs/ufs/inode.c:	unsigned nfrags = uspi->s_fpb;
fs/ufs/inode.c:		nfrags = (new_fragment & uspi->s_fpbmask) + 1;
fs/ufs/inode.c:			goal += uspi->s_fpb;
fs/ufs/inode.c:	return tmp + uspi->s_sbbase;
fs/ufs/inode.c: *  (block will hold this fragment and also uspi->s_fpb-1)
fs/ufs/inode.c:	int shift = uspi->s_apbshift - uspi->s_fpbshift;
fs/ufs/inode.c:	index &= uspi->s_apbmask >> uspi->s_fpbshift;
fs/ufs/inode.c:	if (uspi->fs_magic == UFS2_MAGIC)
fs/ufs/inode.c:	if (index && (uspi->fs_magic == UFS2_MAGIC ?
fs/ufs/inode.c:		goal = tmp + uspi->s_fpb;
fs/ufs/inode.c:		goal = bh->b_blocknr + uspi->s_fpb;
fs/ufs/inode.c:				uspi->s_fpb, err, locked_page);
fs/ufs/inode.c:		tmp += uspi->s_sbbase;
fs/ufs/inode.c:	int depth = ufs_block_to_path(inode, fragment >> uspi->s_fpbshift, offsets);
fs/ufs/inode.c:	unsigned frag = fragment & uspi->s_fpbmask;
fs/ufs/inode.c:		unsigned tailfrags = lastfrag & uspi->s_fpbmask;
fs/ufs/inode.c:	if (ino < UFS_ROOTINO || ino > (uspi->s_ncg * uspi->s_ipg)) {
fs/ufs/inode.c:	bh = sb_bread(sb, uspi->s_sbbase + ufs_inotofsba(inode->i_ino));
fs/ufs/inode.c:		(inode->i_size + uspi->s_fsize - 1) >> uspi->s_fshift;
fs/ufs/inode.c:	    inode->i_ino > (uspi->s_ncg * uspi->s_ipg)) {
fs/ufs/inode.c:	if (uspi->fs_magic == UFS2_MAGIC) {
fs/ufs/inode.c:#define DIRECT_FRAGMENT ((inode->i_size + uspi->s_fsize - 1) >> uspi->s_fshift)
fs/ufs/inode.c:	frag2 = ((frag1 & uspi->s_fpbmask) ? ((frag1 | uspi->s_fpbmask) + 1) : frag1);
fs/ufs/inode.c:	frag3 = frag4 & ~uspi->s_fpbmask;
fs/ufs/inode.c:		free_data(&ctx, tmp, uspi->s_fpb);
fs/ufs/inode.c:	struct ufs_buffer_head *ubh = ubh_bread(sb, ind_block, uspi->s_bsize);
fs/ufs/inode.c:		for (i = 0; i < uspi->s_apb; i++) {
fs/ufs/inode.c:		for (i = 0; i < uspi->s_apb; i++) {
fs/ufs/inode.c:				free_data(&ctx, block, uspi->s_fpb);
fs/ufs/inode.c:	ufs_free_blocks(inode, ind_block, uspi->s_fpb);
fs/ufs/inode.c:		for (i = from; i < uspi->s_apb ; i++) {
fs/ufs/inode.c:		for (i = from; i < uspi->s_apb; i++) {
fs/ufs/inode.c:				free_data(&ctx, block, uspi->s_fpb);
fs/ufs/inode.c:	lastfrag = (size + uspi->s_fsize - 1) >> uspi->s_fshift;
fs/ufs/inode.c:	       end = uspi->s_fpb - ufs_fragnum(lastfrag) - 1;
fs/ufs/inode.c:		sector_t last = (inode->i_size - 1) >> uspi->s_bshift;
fs/ufs/inode.c:		if (offsets[depth2] != uspi->s_apb - 1)
fs/ufs/inode.c:			ubh[i] = ubh_bread(sb, block, uspi->s_bsize);
fs/ufs/super.c:	if (ino < UFS_ROOTINO || ino > uspi->s_ncg * uspi->s_ipg)
fs/ufs/super.c:		uspi->cs_total.cs_ndir = fs64_to_cpu(sb, usb2->fs_un.fs_u2.cs_ndir);
fs/ufs/super.c:		uspi->cs_total.cs_nbfree = fs64_to_cpu(sb, usb2->fs_un.fs_u2.cs_nbfree);
fs/ufs/super.c:		uspi->cs_total.cs_nifree = fs64_to_cpu(sb, usb3->fs_un1.fs_u2.cs_nifree);
fs/ufs/super.c:		uspi->cs_total.cs_nffree = fs64_to_cpu(sb, usb3->fs_un1.fs_u2.cs_nffree);
fs/ufs/super.c:		uspi->cs_total.cs_ndir = fs32_to_cpu(sb, usb1->fs_cstotal.cs_ndir);
fs/ufs/super.c:		uspi->cs_total.cs_nbfree = fs32_to_cpu(sb, usb1->fs_cstotal.cs_nbfree);
fs/ufs/super.c:		uspi->cs_total.cs_nifree = fs32_to_cpu(sb, usb1->fs_cstotal.cs_nifree);
fs/ufs/super.c:		uspi->cs_total.cs_nffree = fs32_to_cpu(sb, usb1->fs_cstotal.cs_nffree);
fs/ufs/super.c:	size = uspi->s_cssize;
fs/ufs/super.c:	blks = (size + uspi->s_fsize - 1) >> uspi->s_fshift;
fs/ufs/super.c:	for (i = 0; i < blks; i += uspi->s_fpb) {
fs/ufs/super.c:		size = uspi->s_bsize;
fs/ufs/super.c:		if (i + uspi->s_fpb > blks)
fs/ufs/super.c:			size = (blks - i) * uspi->s_fsize;
fs/ufs/super.c:		ubh = ubh_bread(sb, uspi->s_csaddr + i, size);
fs/ufs/super.c:	if (!(sbi->s_ucg = kmalloc (sizeof(struct buffer_head *) * uspi->s_ncg, GFP_NOFS)))
fs/ufs/super.c:	for (i = 0; i < uspi->s_ncg; i++) 
fs/ufs/super.c:	for (i = 0; i < uspi->s_ncg; i++) {
fs/ufs/super.c:		for (i = 0; i < uspi->s_ncg; i++)
fs/ufs/super.c:			cpu_to_fs64(sb, uspi->cs_total.cs_ndir);
fs/ufs/super.c:			cpu_to_fs64(sb, uspi->cs_total.cs_nbfree);
fs/ufs/super.c:			cpu_to_fs64(sb, uspi->cs_total.cs_nifree);
fs/ufs/super.c:			cpu_to_fs64(sb, uspi->cs_total.cs_nffree);
fs/ufs/super.c:			cpu_to_fs64(sb, uspi->cs_total.cs_ndir);
fs/ufs/super.c:			cpu_to_fs64(sb, uspi->cs_total.cs_nbfree);
fs/ufs/super.c:			cpu_to_fs64(sb, uspi->cs_total.cs_nifree);
fs/ufs/super.c:			cpu_to_fs64(sb, uspi->cs_total.cs_nffree);
fs/ufs/super.c:	usb1->fs_cstotal.cs_ndir = cpu_to_fs32(sb, uspi->cs_total.cs_ndir);
fs/ufs/super.c:	usb1->fs_cstotal.cs_nbfree = cpu_to_fs32(sb, uspi->cs_total.cs_nbfree);
fs/ufs/super.c:	usb1->fs_cstotal.cs_nifree = cpu_to_fs32(sb, uspi->cs_total.cs_nifree);
fs/ufs/super.c:	usb1->fs_cstotal.cs_nffree = cpu_to_fs32(sb, uspi->cs_total.cs_nffree);
fs/ufs/super.c:	size = uspi->s_cssize;
fs/ufs/super.c:	blks = (size + uspi->s_fsize - 1) >> uspi->s_fshift;
fs/ufs/super.c:	for (i = 0; i < blks; i += uspi->s_fpb) {
fs/ufs/super.c:		size = uspi->s_bsize;
fs/ufs/super.c:		if (i + uspi->s_fpb > blks)
fs/ufs/super.c:			size = (blks - i) * uspi->s_fsize;
fs/ufs/super.c:		ubh = ubh_bread(sb, uspi->s_csaddr + i, size);
fs/ufs/super.c:	for (i = 0; i < uspi->s_ncg; i++) 
fs/ufs/super.c:	int bits = uspi->s_apbshift;
fs/ufs/super.c:	if (res >= (MAX_LFS_FILESIZE >> uspi->s_bshift))
fs/ufs/super.c:	return res << uspi->s_bshift;
fs/ufs/super.c:	uspi->s_dirblksize = UFS_SECTOR_SIZE;
fs/ufs/super.c:		uspi->s_fsize = block_size = 512;
fs/ufs/super.c:		uspi->s_fmask = ~(512 - 1);
fs/ufs/super.c:		uspi->s_fshift = 9;
fs/ufs/super.c:		uspi->s_sbsize = super_block_size = 1536;
fs/ufs/super.c:		uspi->s_sbbase = 0;
fs/ufs/super.c:		uspi->s_fsize = block_size = 512;
fs/ufs/super.c:		uspi->s_fmask = ~(512 - 1);
fs/ufs/super.c:		uspi->s_fshift = 9;
fs/ufs/super.c:		uspi->s_sbsize = super_block_size = 1536;
fs/ufs/super.c:		uspi->s_sbbase =  0;
fs/ufs/super.c:		uspi->s_fsize = block_size = 1024;
fs/ufs/super.c:		uspi->s_fmask = ~(1024 - 1);
fs/ufs/super.c:		uspi->s_fshift = 10;
fs/ufs/super.c:		uspi->s_sbsize = super_block_size = 2048;
fs/ufs/super.c:		uspi->s_sbbase = 0;
fs/ufs/super.c:		uspi->s_maxsymlinklen = 0; /* Not supported on disk */
fs/ufs/super.c:		uspi->s_fsize = block_size = 1024;
fs/ufs/super.c:		uspi->s_fmask = ~(1024 - 1);
fs/ufs/super.c:		uspi->s_fshift = 10;
fs/ufs/super.c:		uspi->s_sbsize = 2048;
fs/ufs/super.c:		uspi->s_sbbase = 0;
fs/ufs/super.c:		uspi->s_maxsymlinklen = 0; /* Not supported on disk */
fs/ufs/super.c:		uspi->s_fsize = block_size = 1024;
fs/ufs/super.c:		uspi->s_fmask = ~(1024 - 1);
fs/ufs/super.c:		uspi->s_fshift = 10;
fs/ufs/super.c:		uspi->s_sbsize = super_block_size = 2048;
fs/ufs/super.c:		uspi->s_sbbase = 0;
fs/ufs/super.c:		uspi->s_maxsymlinklen = 0; /* Not supported on disk */
fs/ufs/super.c:		uspi->s_fsize = block_size = 1024;
fs/ufs/super.c:		uspi->s_fmask = ~(1024 - 1);
fs/ufs/super.c:		uspi->s_fshift = 10;
fs/ufs/super.c:		uspi->s_sbsize = super_block_size = 2048;
fs/ufs/super.c:		uspi->s_sbbase = 0;
fs/ufs/super.c:		uspi->s_fsize = block_size = 1024;
fs/ufs/super.c:		uspi->s_fmask = ~(1024 - 1);
fs/ufs/super.c:		uspi->s_fshift = 10;
fs/ufs/super.c:		uspi->s_sbsize = super_block_size = 2048;
fs/ufs/super.c:		uspi->s_sbbase = 0;
fs/ufs/super.c:		uspi->s_dirblksize = 1024;
fs/ufs/super.c:		uspi->s_fsize = block_size = 2048;
fs/ufs/super.c:		uspi->s_fmask = ~(2048 - 1);
fs/ufs/super.c:		uspi->s_fshift = 11;
fs/ufs/super.c:		uspi->s_sbsize = super_block_size = 2048;
fs/ufs/super.c:		uspi->s_sbbase = 0;
fs/ufs/super.c:		uspi->s_dirblksize = 1024;
fs/ufs/super.c:		uspi->s_fsize = block_size = 1024;
fs/ufs/super.c:		uspi->s_fmask = ~(1024 - 1);
fs/ufs/super.c:		uspi->s_fshift = 10;
fs/ufs/super.c:		uspi->s_sbsize = super_block_size = 2048;
fs/ufs/super.c:		uspi->s_sbbase = 0;
fs/ufs/super.c:		uspi->s_dirblksize = 1024;
fs/ufs/super.c:		uspi->s_fsize = block_size = 1024;
fs/ufs/super.c:		uspi->s_fmask = ~(1024 - 1);
fs/ufs/super.c:		uspi->s_fshift = 10;
fs/ufs/super.c:		uspi->s_sbsize = super_block_size = 2048;
fs/ufs/super.c:		uspi->s_sbbase = 0;
fs/ufs/super.c:	ubh = ubh_bread_uspi(uspi, sb, uspi->s_sbbase + super_block_offset/block_size, super_block_size);
fs/ufs/super.c:	uspi->s_postblformat = fs32_to_cpu(sb, usb3->fs_postblformat);
fs/ufs/super.c:	    (uspi->s_postblformat != UFS_42POSTBLFMT)) {
fs/ufs/super.c:	    uspi->s_postblformat == UFS_42POSTBLFMT) {
fs/ufs/super.c:	switch ((uspi->fs_magic = fs32_to_cpu(sb, usb3->fs_magic))) {
fs/ufs/super.c:	switch ((uspi->fs_magic = fs32_to_cpu(sb, usb3->fs_magic))) {
fs/ufs/super.c:	  && uspi->s_sbbase < 256) {
fs/ufs/super.c:		uspi->s_sbbase += 8;
fs/ufs/super.c:	uspi->s_bsize = fs32_to_cpu(sb, usb1->fs_bsize);
fs/ufs/super.c:	uspi->s_fsize = fs32_to_cpu(sb, usb1->fs_fsize);
fs/ufs/super.c:	uspi->s_sbsize = fs32_to_cpu(sb, usb1->fs_sbsize);
fs/ufs/super.c:	uspi->s_fmask = fs32_to_cpu(sb, usb1->fs_fmask);
fs/ufs/super.c:	uspi->s_fshift = fs32_to_cpu(sb, usb1->fs_fshift);
fs/ufs/super.c:	if (!is_power_of_2(uspi->s_fsize)) {
fs/ufs/super.c:		       __func__, uspi->s_fsize);
fs/ufs/super.c:	if (uspi->s_fsize < 512) {
fs/ufs/super.c:		       __func__, uspi->s_fsize);
fs/ufs/super.c:	if (uspi->s_fsize > 4096) {
fs/ufs/super.c:		       __func__, uspi->s_fsize);
fs/ufs/super.c:	if (!is_power_of_2(uspi->s_bsize)) {
fs/ufs/super.c:		       __func__, uspi->s_bsize);
fs/ufs/super.c:	if (uspi->s_bsize < 4096) {
fs/ufs/super.c:		       __func__, uspi->s_bsize);
fs/ufs/super.c:	if (uspi->s_bsize / uspi->s_fsize > 8) {
fs/ufs/super.c:		       __func__, uspi->s_bsize / uspi->s_fsize);
fs/ufs/super.c:	if (uspi->s_fsize != block_size || uspi->s_sbsize != super_block_size) {
fs/ufs/super.c:		block_size = uspi->s_fsize;
fs/ufs/super.c:		super_block_size = uspi->s_sbsize;
fs/ufs/super.c:	uspi->s_sblkno = fs32_to_cpu(sb, usb1->fs_sblkno);
fs/ufs/super.c:	uspi->s_cblkno = fs32_to_cpu(sb, usb1->fs_cblkno);
fs/ufs/super.c:	uspi->s_iblkno = fs32_to_cpu(sb, usb1->fs_iblkno);
fs/ufs/super.c:	uspi->s_dblkno = fs32_to_cpu(sb, usb1->fs_dblkno);
fs/ufs/super.c:	uspi->s_cgoffset = fs32_to_cpu(sb, usb1->fs_cgoffset);
fs/ufs/super.c:	uspi->s_cgmask = fs32_to_cpu(sb, usb1->fs_cgmask);
fs/ufs/super.c:		uspi->s_size  = fs64_to_cpu(sb, usb3->fs_un1.fs_u2.fs_size);
fs/ufs/super.c:		uspi->s_dsize = fs64_to_cpu(sb, usb3->fs_un1.fs_u2.fs_dsize);
fs/ufs/super.c:		uspi->s_size  =  fs32_to_cpu(sb, usb1->fs_size);
fs/ufs/super.c:		uspi->s_dsize =  fs32_to_cpu(sb, usb1->fs_dsize);
fs/ufs/super.c:	uspi->s_ncg = fs32_to_cpu(sb, usb1->fs_ncg);
fs/ufs/super.c:	uspi->s_fpb = fs32_to_cpu(sb, usb1->fs_frag);
fs/ufs/super.c:	uspi->s_minfree = fs32_to_cpu(sb, usb1->fs_minfree);
fs/ufs/super.c:	uspi->s_bmask = fs32_to_cpu(sb, usb1->fs_bmask);
fs/ufs/super.c:	uspi->s_fmask = fs32_to_cpu(sb, usb1->fs_fmask);
fs/ufs/super.c:	uspi->s_bshift = fs32_to_cpu(sb, usb1->fs_bshift);
fs/ufs/super.c:	uspi->s_fshift = fs32_to_cpu(sb, usb1->fs_fshift);
fs/ufs/super.c:	UFSD("uspi->s_bshift = %d,uspi->s_fshift = %d", uspi->s_bshift,
fs/ufs/super.c:		uspi->s_fshift);
fs/ufs/super.c:	uspi->s_fpbshift = fs32_to_cpu(sb, usb1->fs_fragshift);
fs/ufs/super.c:	uspi->s_fsbtodb = fs32_to_cpu(sb, usb1->fs_fsbtodb);
fs/ufs/super.c:	uspi->s_csmask = fs32_to_cpu(sb, usb1->fs_csmask);
fs/ufs/super.c:	uspi->s_csshift = fs32_to_cpu(sb, usb1->fs_csshift);
fs/ufs/super.c:	uspi->s_nindir = fs32_to_cpu(sb, usb1->fs_nindir);
fs/ufs/super.c:	uspi->s_inopb = fs32_to_cpu(sb, usb1->fs_inopb);
fs/ufs/super.c:	uspi->s_nspf = fs32_to_cpu(sb, usb1->fs_nspf);
fs/ufs/super.c:	uspi->s_npsect = ufs_get_fs_npsect(sb, usb1, usb3);
fs/ufs/super.c:	uspi->s_interleave = fs32_to_cpu(sb, usb1->fs_interleave);
fs/ufs/super.c:	uspi->s_trackskew = fs32_to_cpu(sb, usb1->fs_trackskew);
fs/ufs/super.c:	if (uspi->fs_magic == UFS2_MAGIC)
fs/ufs/super.c:		uspi->s_csaddr = fs64_to_cpu(sb, usb3->fs_un1.fs_u2.fs_csaddr);
fs/ufs/super.c:		uspi->s_csaddr = fs32_to_cpu(sb, usb1->fs_csaddr);
fs/ufs/super.c:	uspi->s_cssize = fs32_to_cpu(sb, usb1->fs_cssize);
fs/ufs/super.c:	uspi->s_cgsize = fs32_to_cpu(sb, usb1->fs_cgsize);
fs/ufs/super.c:	uspi->s_ntrak = fs32_to_cpu(sb, usb1->fs_ntrak);
fs/ufs/super.c:	uspi->s_nsect = fs32_to_cpu(sb, usb1->fs_nsect);
fs/ufs/super.c:	uspi->s_spc = fs32_to_cpu(sb, usb1->fs_spc);
fs/ufs/super.c:	uspi->s_ipg = fs32_to_cpu(sb, usb1->fs_ipg);
fs/ufs/super.c:	uspi->s_fpg = fs32_to_cpu(sb, usb1->fs_fpg);
fs/ufs/super.c:	uspi->s_cpc = fs32_to_cpu(sb, usb2->fs_un.fs_u1.fs_cpc);
fs/ufs/super.c:	uspi->s_contigsumsize = fs32_to_cpu(sb, usb3->fs_un2.fs_44.fs_contigsumsize);
fs/ufs/super.c:	uspi->s_qbmask = ufs_get_fs_qbmask(sb, usb3);
fs/ufs/super.c:	uspi->s_qfmask = ufs_get_fs_qfmask(sb, usb3);
fs/ufs/super.c:	uspi->s_nrpos = fs32_to_cpu(sb, usb3->fs_nrpos);
fs/ufs/super.c:	uspi->s_postbloff = fs32_to_cpu(sb, usb3->fs_postbloff);
fs/ufs/super.c:	uspi->s_rotbloff = fs32_to_cpu(sb, usb3->fs_rotbloff);
fs/ufs/super.c:	uspi->s_root_blocks = mul_u64_u32_div(uspi->s_dsize,
fs/ufs/super.c:					      uspi->s_minfree, 100);
fs/ufs/super.c:	if (uspi->s_minfree <= 5) {
fs/ufs/super.c:		uspi->s_time_to_space = ~0ULL;
fs/ufs/super.c:		uspi->s_space_to_time = 0;
fs/ufs/super.c:		uspi->s_time_to_space = (uspi->s_root_blocks / 2) + 1;
fs/ufs/super.c:		uspi->s_space_to_time = mul_u64_u32_div(uspi->s_dsize,
fs/ufs/super.c:					      uspi->s_minfree - 2, 100) - 1;
fs/ufs/super.c:	uspi->s_fpbmask = uspi->s_fpb - 1;
fs/ufs/super.c:		uspi->s_apbshift = uspi->s_bshift - 3;
fs/ufs/super.c:		uspi->s_apbshift = uspi->s_bshift - 2;
fs/ufs/super.c:	uspi->s_2apbshift = uspi->s_apbshift * 2;
fs/ufs/super.c:	uspi->s_3apbshift = uspi->s_apbshift * 3;
fs/ufs/super.c:	uspi->s_apb = 1 << uspi->s_apbshift;
fs/ufs/super.c:	uspi->s_2apb = 1 << uspi->s_2apbshift;
fs/ufs/super.c:	uspi->s_3apb = 1 << uspi->s_3apbshift;
fs/ufs/super.c:	uspi->s_apbmask = uspi->s_apb - 1;
fs/ufs/super.c:	uspi->s_nspfshift = uspi->s_fshift - UFS_SECTOR_BITS;
fs/ufs/super.c:	uspi->s_nspb = uspi->s_nspf << uspi->s_fpbshift;
fs/ufs/super.c:	uspi->s_inopf = uspi->s_inopb >> uspi->s_fpbshift;
fs/ufs/super.c:	uspi->s_bpf = uspi->s_fsize << 3;
fs/ufs/super.c:	uspi->s_bpfshift = uspi->s_fshift + 3;
fs/ufs/super.c:	uspi->s_bpfmask = uspi->s_bpf - 1;
fs/ufs/super.c:		uspi->s_maxsymlinklen =
fs/ufs/super.c:	if (uspi->fs_magic == UFS2_MAGIC)
fs/ufs/super.c:	if (uspi->s_maxsymlinklen > maxsymlen) {
fs/ufs/super.c:			    "fast symlink size (%u)\n", uspi->s_maxsymlinklen);
fs/ufs/super.c:		uspi->s_maxsymlinklen = maxsymlen;
fs/ufs/super.c:	buf->f_blocks = uspi->s_dsize;
fs/ufs/super.c:	buf->f_ffree = uspi->cs_total.cs_nifree;
fs/ufs/super.c:	buf->f_bavail = (buf->f_bfree > uspi->s_root_blocks)
fs/ufs/super.c:		? (buf->f_bfree - uspi->s_root_blocks) : 0;
fs/ufs/super.c:	buf->f_files = uspi->s_ncg * uspi->s_ipg;
fs/ufs/namei.c:	if (l > UFS_SB(sb)->s_uspi->s_maxsymlinklen) {
fs/ufs/balloc.c:	if (ufs_fragnum(fragment) + count > uspi->s_fpg)
fs/ufs/balloc.c:	if (cgno >= uspi->s_ncg) {
fs/ufs/balloc.c:	inode_sub_bytes(inode, count << uspi->s_fshift);
fs/ufs/balloc.c:	uspi->cs_total.cs_nffree += count;
fs/ufs/balloc.c:		fs32_sub(sb, &ucg->cg_cs.cs_nffree, uspi->s_fpb);
fs/ufs/balloc.c:		uspi->cs_total.cs_nffree -= uspi->s_fpb;
fs/ufs/balloc.c:		fs32_sub(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nffree, uspi->s_fpb);
fs/ufs/balloc.c:		uspi->cs_total.cs_nbfree++;
fs/ufs/balloc.c:		if (uspi->fs_magic != UFS2_MAGIC) {
fs/ufs/balloc.c:	if ((fragment & uspi->s_fpbmask) || (count & uspi->s_fpbmask)) {
fs/ufs/balloc.c:	if (cgno >= uspi->s_ncg) {
fs/ufs/balloc.c:	if (end_bit > uspi->s_fpg) {
fs/ufs/balloc.c:		overflow = bit + count - uspi->s_fpg;
fs/ufs/balloc.c:	for (i = bit; i < end_bit; i += uspi->s_fpb) {
fs/ufs/balloc.c:		inode_sub_bytes(inode, uspi->s_fpb << uspi->s_fshift);
fs/ufs/balloc.c:		uspi->cs_total.cs_nbfree++;
fs/ufs/balloc.c:		if (uspi->fs_magic != UFS2_MAGIC) {
fs/ufs/balloc.c:	if (count + ufs_fragnum(fragment) > uspi->s_fpb) {
fs/ufs/balloc.c:		count = uspi->s_fpb - ufs_fragnum(fragment); 
fs/ufs/balloc.c:	if (unlikely(ufs_freefrags(uspi) <= uspi->s_root_blocks)) {
fs/ufs/balloc.c:	if (goal >= uspi->s_size) 
fs/ufs/balloc.c:		if (uspi->cs_total.cs_nffree < uspi->s_space_to_time)
fs/ufs/balloc.c:		request = uspi->s_fpb;
fs/ufs/balloc.c:		if (uspi->cs_total.cs_nffree > uspi->s_time_to_space)
fs/ufs/balloc.c:				   uspi->s_sbbase + tmp,
fs/ufs/balloc.c:				   uspi->s_sbbase + result, locked_page);
fs/ufs/balloc.c:	if ((ufs_fragnum (fragment) + newcount) > uspi->s_fpb)
fs/ufs/balloc.c:	for (i = newcount; i < (uspi->s_fpb - fragoff); i++)
fs/ufs/balloc.c:	uspi->cs_total.cs_nffree -= count;
fs/ufs/balloc.c:	for (k = count; k < uspi->s_fpb; k++) \
fs/ufs/balloc.c:	for (j = 1; j < uspi->s_ncg; j *= 2) {
fs/ufs/balloc.c:		if (cgno >= uspi->s_ncg) 
fs/ufs/balloc.c:			cgno -= uspi->s_ncg;
fs/ufs/balloc.c:	cgno = (oldcg + 1) % uspi->s_ncg;
fs/ufs/balloc.c:	for (j = 2; j < uspi->s_ncg; j++) {
fs/ufs/balloc.c:		if (cgno >= uspi->s_ncg)
fs/ufs/balloc.c:	if (count == uspi->s_fpb) {
fs/ufs/balloc.c:	for (allocsize = count; allocsize < uspi->s_fpb; allocsize++)
fs/ufs/balloc.c:	if (allocsize == uspi->s_fpb) {
fs/ufs/balloc.c:		for (i = count; i < uspi->s_fpb; i++)
fs/ufs/balloc.c:		i = uspi->s_fpb - count;
fs/ufs/balloc.c:		inode_sub_bytes(inode, i << uspi->s_fshift);
fs/ufs/balloc.c:		uspi->cs_total.cs_nffree += i;
fs/ufs/balloc.c:	uspi->cs_total.cs_nffree -= count;
fs/ufs/balloc.c:	result += cgno * uspi->s_fpg;
fs/ufs/balloc.c:	result = ufs_bitmap_search (sb, ucpi, goal, uspi->s_fpb);
fs/ufs/balloc.c:	if (!try_add_frags(inode, uspi->s_fpb))
fs/ufs/balloc.c:	uspi->cs_total.cs_nbfree--;
fs/ufs/balloc.c:	if (uspi->fs_magic != UFS2_MAGIC) {
fs/ufs/balloc.c:	offset = begin & ~uspi->s_fmask;
fs/ufs/balloc.c:	begin >>= uspi->s_fshift;
fs/ufs/balloc.c:		if ((offset + size) < uspi->s_fsize)
fs/ufs/balloc.c:			rest = uspi->s_fsize - offset;
fs/ufs/balloc.c:	length = ((uspi->s_fpg + 7) >> 3) - start;
fs/ufs/balloc.c:		(uspi->s_fpb == 8) ? ufs_fragtable_8fpb : ufs_fragtable_other,
fs/ufs/balloc.c:		1 << (count - 1 + (uspi->s_fpb & 7))); 
fs/ufs/balloc.c:				(uspi->s_fpb == 8) ? ufs_fragtable_8fpb :
fs/ufs/balloc.c:				1 << (count - 1 + (uspi->s_fpb & 7)));
fs/ufs/balloc.c:	for (end = result + 8; result < end; result += uspi->s_fpb) {
fs/ufs/balloc.c:		for (pos = 0; pos <= uspi->s_fpb - count; pos++) {
fs/ufs/balloc.c:	if (uspi->s_contigsumsize <= 0)
fs/ufs/balloc.c:	end = start + uspi->s_contigsumsize;
fs/ufs/balloc.c:	end = start - uspi->s_contigsumsize;
fs/ufs/balloc.c:	if (i > uspi->s_contigsumsize)
fs/ufs/balloc.c:		i = uspi->s_contigsumsize;
fs/jffs2/summary.c:				ino = je32_to_cpu(spi->inode);
fs/jffs2/summary.c:					    jeb->offset + je32_to_cpu(spi->offset),
fs/jffs2/summary.c:					    jeb->offset + je32_to_cpu(spi->offset) + je32_to_cpu(spi->totlen));
fs/jffs2/summary.c:				sum_link_node_ref(c, jeb, je32_to_cpu(spi->offset) | REF_UNCHECKED,
fs/jffs2/summary.c:						  PAD(je32_to_cpu(spi->totlen)), ic);
fs/jffs2/summary.c:				*pseudo_random += je32_to_cpu(spi->version);
Binary file vmlinux.o matches
out/lib/modules/4.15.0-next-20180202-licheepi-nano+/modules.builtin:kernel/drivers/mtd/spi-nor/spi-nor.ko
out/lib/modules/4.15.0-next-20180202-licheepi-nano+/modules.builtin:kernel/drivers/spi/spi-sun6i.ko
Binary file .tmp_vmlinux2 matches
Next/Trees:spi-nor-fixes	git	git://git.infradead.org/linux-mtd.git#spi-nor/fixes
Next/Trees:spi-nor		git	git://git.infradead.org/linux-mtd.git#spi-nor/next
Next/SHA1s:spi-nor-fixes	10a6a6975691775bbcc677a04c6fd3120b5c1160
Next/SHA1s:spi-nor		23bae78e8a57f0249ed9e3f9c3f40fc1499ce0d4
Next/merge.log: .../devicetree/bindings/spi/spi-davinci.txt        |     2 +-
Next/merge.log: .../devicetree/bindings/spi/spi-lantiq-ssc.txt     |     2 +-
Next/merge.log:Merging spi-nor-fixes/spi-nor/fixes (10a6a6975691 Revert "dt-bindings: mtd: add sst25wf040b and en25s64 to sip-nor list")
Next/merge.log:$ git merge spi-nor-fixes/spi-nor/fixes
Next/merge.log: arch/arm/mach-s3c24xx/spi-core.h                   |    5 +-
Next/merge.log:Merging spi-nor/spi-nor/next (23bae78e8a57 mtd: mtk-nor: modify functions' name more generally)
Next/merge.log:$ git merge spi-nor/spi-nor/next
Next/merge.log:Merging spi/for-next (d0cb047a0edb Merge tag 'spi-v4.16' into spi-next)
Binary file built-in.o matches
Binary file vmlinux matches
net/netfilter/xt_HMARK.c:		pr_info("xt_HMARK: spi-mask and port-mask can't be combined\n");
net/netfilter/xt_HMARK.c:		pr_info("xt_HMARK: spi-set and port-set can't be combined\n");
net/nfc/nci/spi.c:	t.delay_usecs = nspi->xfer_udelay;
net/nfc/nci/spi.c:	t.speed_hz = nspi->xfer_speed_hz;
net/nfc/nci/spi.c:	return spi_sync(nspi->spi, &m);
net/nfc/nci/spi.c:	hdr[1] = nspi->acknowledge_mode;
net/nfc/nci/spi.c:	if (nspi->acknowledge_mode == NCI_SPI_CRC_ENABLED) {
net/nfc/nci/spi.c:	if (ret != 0 || nspi->acknowledge_mode == NCI_SPI_CRC_DISABLED)
net/nfc/nci/spi.c:	reinit_completion(&nspi->req_completion);
net/nfc/nci/spi.c:							&nspi->req_completion,
net/nfc/nci/spi.c:	if (completion_rc <= 0 || nspi->req_result == ACKNOWLEDGE_NACK)
net/nfc/nci/spi.c:	nspi = devm_kzalloc(&spi->dev, sizeof(struct nci_spi), GFP_KERNEL);
net/nfc/nci/spi.c:	nspi->acknowledge_mode = acknowledge_mode;
net/nfc/nci/spi.c:	nspi->xfer_udelay = delay;
net/nfc/nci/spi.c:	nspi->xfer_speed_hz = 0;
net/nfc/nci/spi.c:	nspi->spi = spi;
net/nfc/nci/spi.c:	nspi->ndev = ndev;
net/nfc/nci/spi.c:	init_completion(&nspi->req_completion);
net/nfc/nci/spi.c:	skb = nci_skb_alloc(nspi->ndev, 0, GFP_KERNEL);
net/nfc/nci/spi.c:	req[1] = nspi->acknowledge_mode;
net/nfc/nci/spi.c:	tx.speed_hz = nspi->xfer_speed_hz;
net/nfc/nci/spi.c:	rx.speed_hz = nspi->xfer_speed_hz;
net/nfc/nci/spi.c:	ret = spi_sync(nspi->spi, &m);
net/nfc/nci/spi.c:	if (nspi->acknowledge_mode == NCI_SPI_CRC_ENABLED)
net/nfc/nci/spi.c:	skb = nci_skb_alloc(nspi->ndev, rx_len, GFP_KERNEL);
net/nfc/nci/spi.c:	rx.delay_usecs = nspi->xfer_udelay;
net/nfc/nci/spi.c:	rx.speed_hz = nspi->xfer_speed_hz;
net/nfc/nci/spi.c:	ret = spi_sync(nspi->spi, &m);
net/nfc/nci/spi.c:	if (nspi->acknowledge_mode == NCI_SPI_CRC_ENABLED) {
net/nfc/nci/spi.c:	if (nspi->acknowledge_mode == NCI_SPI_CRC_ENABLED) {
net/nfc/nci/spi.c:		nspi->req_result = nci_spi_get_ack(skb);
net/nfc/nci/spi.c:		if (nspi->req_result)
net/nfc/nci/spi.c:			complete(&nspi->req_completion);
net/nfc/nci/spi.c:	if (nspi->acknowledge_mode == NCI_SPI_CRC_ENABLED)
net/nfc/nci/Makefile:nci_spi-y += spi.o
net/ipv6/xfrm6_tunnel.c:		if (xfrm6_addr_equal(&x6spi->addr, saddr))
net/ipv6/xfrm6_tunnel.c:	spi = x6spi ? x6spi->spi : 0;
net/ipv6/xfrm6_tunnel.c:		if (x6spi->spi == spi)
net/ipv6/xfrm6_tunnel.c:	memcpy(&x6spi->addr, saddr, sizeof(x6spi->addr));
net/ipv6/xfrm6_tunnel.c:	x6spi->spi = spi;
net/ipv6/xfrm6_tunnel.c:	refcount_set(&x6spi->refcnt, 1);
net/ipv6/xfrm6_tunnel.c:	hlist_add_head_rcu(&x6spi->list_byspi, &xfrm6_tn->spi_byspi[index]);
net/ipv6/xfrm6_tunnel.c:	hlist_add_head_rcu(&x6spi->list_byaddr, &xfrm6_tn->spi_byaddr[index]);
net/ipv6/xfrm6_tunnel.c:		refcount_inc(&x6spi->refcnt);
net/ipv6/xfrm6_tunnel.c:		spi = x6spi->spi;
net/ipv6/xfrm6_tunnel.c:		if (xfrm6_addr_equal(&x6spi->addr, saddr)) {
net/ipv6/xfrm6_tunnel.c:			if (refcount_dec_and_test(&x6spi->refcnt)) {
net/ipv6/xfrm6_tunnel.c:				hlist_del_rcu(&x6spi->list_byaddr);
net/ipv6/xfrm6_tunnel.c:				hlist_del_rcu(&x6spi->list_byspi);
net/ipv6/xfrm6_tunnel.c:				call_rcu(&x6spi->rcu_head, x6spi_destroy_rcu);
include/config/auto.conf.cmd:	drivers/mtd/spi-nor/Kconfig \
include/linux/spi/mmc_spi.h: * REVISIT This is not a spi-specific notion.  Any card slot should be
include/linux/spi/mmc_spi.h:	return spi->dev.platform_data;
include/linux/spi/spi.h: * @messages:      number of spi-messages handled
include/linux/spi/spi.h:	return (spi && get_device(&spi->dev)) ? spi : NULL;
include/linux/spi/spi.h:		put_device(&spi->dev);
include/linux/spi/spi.h:	return spi->controller_state;
include/linux/spi/spi.h:	spi->controller_state = state;
include/linux/spi/spi.h:	dev_set_drvdata(&spi->dev, data);
include/linux/spi/spi.h:	return dev_get_drvdata(&spi->dev);
include/linux/spi/spi.h: * @spi_flash_read: to support spi-controller hardwares that provide
include/linux/spi/spi.h:	struct spi_controller *ctlr = spi->controller;
include/linux/spi/spi.h:	struct spi_controller *ctlr = spi->controller;
include/linux/spi/spi.h: * spi-masters that provide accelerated flash read interfaces
include/linux/spi/spi.h:	return spi->controller->spi_flash_read &&
include/linux/spi/spi.h:	       (!spi->controller->flash_read_supported ||
include/linux/spi/spi.h:	       spi->controller->flash_read_supported(spi));
include/linux/spi/spi_bitbang.h:	u8			flags;		/* extra spi->mode support */
include/linux/mtd/spi-nor.h: * @info:		spi-nor part JDEC MFR id and other info
include/linux/mtd/spi-nor.h: *			spi-nor will send the erase opcode via write_reg()
include/linux/platform_data/st_sensors_pdata.h: * @spi_3wire: enable spi-3wire mode.
include/trace/events/spi.h:		__entry->bus_num = msg->spi->controller->bus_num;
include/trace/events/spi.h:		__entry->chip_select = msg->spi->chip_select;
include/trace/events/spi.h:		__entry->bus_num = msg->spi->controller->bus_num;
include/trace/events/spi.h:		__entry->chip_select = msg->spi->chip_select;
include/trace/events/spi.h:		__entry->bus_num = msg->spi->controller->bus_num;
include/trace/events/spi.h:		__entry->chip_select = msg->spi->chip_select;
Binary file .tmp_vmlinux1 matches
